[
    {
        "sql_id": 1,
        "database_name": "BUTTERTrans_1",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select a1,a2,b,min(c) from t1 where (ord(a1) > 97) and (ord(a2) + ord(a1) > 194) and (b = 'a') group by a1,a2,b; -- ORD",
        "target_query": "select a1,a2,b,min(c) from t1 where (ASCII(a1) > 97) and (ASCII(a2) + ASCII(a1) > 194) and (b = 'a') group by a1,a2,b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "ORD",
                "start_pos": 37,
                "end_pos": 40
            },
            {
                "dialect_token": "ORD",
                "start_pos": 56,
                "end_pos": 59
            },
            {
                "dialect_token": "ORD",
                "start_pos": 66,
                "end_pos": 69
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ORD(string)",
                "description": "The ORD() function returns the Unicode code point of the first character of a string.",
                "examples": [
                    "SELECT ORD('A');",
                    "SELECT ORD('B');",
                    "SELECT ORD('C') > 60;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "ASCII(string)",
                "description": "MonetDB uses ASCII() to return the ASCII value of the first character in the string. It does not have a direct equivalent to ORD() for Unicode code points, but ASCII() can work for characters in the basic ASCII range.",
                "examples": [
                    "SELECT ASCII('A');",
                    "SELECT ASCII('B');",
                    "SELECT ASCII('C') > 60;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n"
        ]
    },
    {
        "sql_id": 2,
        "database_name": "BUTTERTrans_2",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
        "target_query": "select a1 || min(c), b from t1 where a1 < 'd' group by a1,a2,b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n",
            "select a1,a2,b,min(c) from t1 where (ord(a1) > 97) and (ord(a2) + ord(a1) > 194) and (b = 'a') group by a1,a2,b; -- ORD\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n",
            "select a1,a2,b,min(c) from t1 where (ASCII(a1) > 97) and (ASCII(a2) + ASCII(a1) > 194) and (b = 'a') group by a1,a2,b;\n"
        ]
    },
    {
        "sql_id": 3,
        "database_name": "BUTTERTrans_3",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(a1,min(c)),b,max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
        "target_query": "select a1 || min(c), b, max(c) from t1 where a1 < 'd' group by a1,a2,b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n",
            "select a1,a2,b,min(c) from t1 where (ord(a1) > 97) and (ord(a2) + ord(a1) > 194) and (b = 'a') group by a1,a2,b; -- ORD\n",
            "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n",
            "select a1,a2,b,min(c) from t1 where (ASCII(a1) > 97) and (ASCII(a2) + ASCII(a1) > 194) and (b = 'a') group by a1,a2,b;\n",
            "select a1 || min(c), b from t1 where a1 < 'd' group by a1,a2,b;\n"
        ]
    },
    {
        "sql_id": 4,
        "database_name": "BUTTERTrans_4",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(a1,a2),b,min(c),max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT",
        "target_query": "select a1 || a2, b, min(c), max(c) from t1 where a1 < 'd' group by a1,a2,b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n",
            "select a1,a2,b,min(c) from t1 where (ord(a1) > 97) and (ord(a2) + ord(a1) > 194) and (b = 'a') group by a1,a2,b; -- ORD\n",
            "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT\n",
            "select concat(a1,min(c)),b,max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n",
            "select a1,a2,b,min(c) from t1 where (ASCII(a1) > 97) and (ASCII(a2) + ASCII(a1) > 194) and (b = 'a') group by a1,a2,b;\n",
            "select a1 || min(c), b from t1 where a1 < 'd' group by a1,a2,b;\n",
            "select a1 || min(c), b, max(c) from t1 where a1 < 'd' group by a1,a2,b;\n"
        ]
    },
    {
        "sql_id": 5,
        "database_name": "BUTTERTrans_5",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(ord(min(b)),ord(max(b))),min(b),max(b) from t1 group by a1,a2; -- CONCAT, ORD",
        "target_query": "select ASCII(min(b)) || ASCII(max(b)), min(b), max(b) from t1 group by a1,a2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "ORD",
                "start_pos": 14,
                "end_pos": 17
            },
            {
                "dialect_token": "ORD",
                "start_pos": 26,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "ORD(string)",
                "description": "The ORD() function returns the Unicode code point of the first character of a string.",
                "examples": [
                    "SELECT ORD('A');",
                    "SELECT ORD('B');",
                    "SELECT ORD('C') > 60;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            },
            {
                "expression": "ASCII(string)",
                "description": "MonetDB uses ASCII() to return the ASCII value of the first character in the string. It does not have a direct equivalent to ORD() for Unicode code points, but ASCII() can work for characters in the basic ASCII range.",
                "examples": [
                    "SELECT ASCII('A');",
                    "SELECT ASCII('B');",
                    "SELECT ASCII('C') > 60;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n",
            "select a1,a2,b,min(c) from t1 where (ord(a1) > 97) and (ord(a2) + ord(a1) > 194) and (b = 'a') group by a1,a2,b; -- ORD\n",
            "select concat(a1,min(c)),b from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT\n",
            "select concat(a1,min(c)),b,max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT\n",
            "select concat(a1,a2),b,min(c),max(c) from t1 where a1 < 'd' group by a1,a2,b; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a1 char(64), a2 char(64), b char(16), c char(16) not null, d char(16), dummy char(248) default ' ');\n",
            "insert into t1 (a1, a2, b, c, d) values('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('b','a','a','a211','xy1'),('b','a','a','b211','xy2'),('b','a','a','c211','xy3'),('c','a','a','a311','xy1'),('c','a','a','b311','xy2'),('c','a','a','c311','xy3'),('d','a','a','a411','xy1'),('d','a','a','b411','xy2'),('d','a','a','c411','xy3');\n",
            "select a1,a2,b,min(c) from t1 where (ASCII(a1) > 97) and (ASCII(a2) + ASCII(a1) > 194) and (b = 'a') group by a1,a2,b;\n",
            "select a1 || min(c), b from t1 where a1 < 'd' group by a1,a2,b;\n",
            "select a1 || min(c), b, max(c) from t1 where a1 < 'd' group by a1,a2,b;\n",
            "select a1 || a2, b, min(c), max(c) from t1 where a1 < 'd' group by a1,a2,b;\n"
        ]
    },
    {
        "sql_id": 6,
        "database_name": "BUTTERTrans_6",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP",
        "target_query": "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMP",
                "start_pos": 7,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
                "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
                "examples": [
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 7,
        "database_name": "BUTTERTrans_7",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF",
        "target_query": "SELECT DATE '2007-12-31 23:59:59' - DATE '2007-12-30 00:00:00';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATEDIFF(date1, date2)",
                "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
                "examples": [
                    "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
                    "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
                    "SELECT DATEDIFF(NULL, '2025-01-01');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "date1 - date2",
                "description": "Subtracting one DATE from another returns the day difference as an integer.",
                "examples": [
                    "SELECT DATE '2025-12-31' - DATE '2025-12-01';",
                    "SELECT DATE '2025-01-01' - DATE '2024-12-31';"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 8,
        "database_name": "BUTTERTrans_8",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM timestamp '2000-01-01 00:00:00' - timestamp '2000-01-01 00:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP\n",
            "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);\n",
            "SELECT DATE '2007-12-31 23:59:59' - DATE '2007-12-30 00:00:00';\n"
        ]
    },
    {
        "sql_id": 9,
        "database_name": "BUTTERTrans_9",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2009-10-10 23:59:59', 'W MM YYYY');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP\n",
            "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF\n",
            "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);\n",
            "SELECT DATE '2007-12-31 23:59:59' - DATE '2007-12-30 00:00:00';\n",
            "SELECT EXTRACT(EPOCH FROM timestamp '2000-01-01 00:00:00' - timestamp '2000-01-01 00:00:00');\n"
        ]
    },
    {
        "sql_id": 10,
        "database_name": "BUTTERTrans_10",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME",
        "target_query": "SELECT sys.time_to_str(TIMESTAMP '2003-12-31 23:59:59', '%H:%M:%S');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIME",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.time_to_str(time-value, format)",
                "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP\n",
            "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF\n",
            "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF\n",
            "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);\n",
            "SELECT DATE '2007-12-31 23:59:59' - DATE '2007-12-30 00:00:00';\n",
            "SELECT EXTRACT(EPOCH FROM timestamp '2000-01-01 00:00:00' - timestamp '2000-01-01 00:00:00');\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '2009-10-10 23:59:59', 'W MM YYYY');\n"
        ]
    },
    {
        "sql_id": 11,
        "database_name": "BUTTERTrans_11",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, '2003-01-02 23:59:59' ); -- TIMESTAMPADD",
        "target_query": "SELECT TIMESTAMP '2003-01-02 23:59:59' + INTERVAL '1' MINUTE;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMPADD",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
                "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
                    "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
                    "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime_expr + INTERVAL 'n' unit",
                "description": "Adds a time interval to a timestamp or date using SQL standard INTERVAL syntax with integer value and time unit.",
                "examples": [
                    "SELECT DATE '2023-01-01' + INTERVAL '2' DAY;",
                    "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5' MINUTE;",
                    "SELECT DATE '2020-06-15' + INTERVAL '1' YEAR;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP\n",
            "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF\n",
            "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF\n",
            "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT\n",
            "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);\n",
            "SELECT DATE '2007-12-31 23:59:59' - DATE '2007-12-30 00:00:00';\n",
            "SELECT EXTRACT(EPOCH FROM timestamp '2000-01-01 00:00:00' - timestamp '2000-01-01 00:00:00');\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '2009-10-10 23:59:59', 'W MM YYYY');\n",
            "SELECT sys.time_to_str(TIMESTAMP '2003-12-31 23:59:59', '%H:%M:%S');\n"
        ]
    },
    {
        "sql_id": 12,
        "database_name": "BUTTERTrans_12",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIMESTAMPDIFF(MONTH, '2003-02-01 23:59:59', '2003-05-01' ); -- TIMESTAMPDIFF",
        "target_query": "SELECT CAST(DATE '2003-05-01' AS DATE) - CAST(DATE '2003-02-01 23:59:59' AS DATE);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMPDIFF",
                "start_pos": 7,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
                "description": "Returns the difference between two datetime values in the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
                    "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
                    "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(end_date AS DATE) - CAST(start_date AS DATE)",
                "description": "MonetDB calculates the difference between two dates using UNIX timestamps (seconds since '1970-01-01 00:00:00'). The result is returned in seconds. For example, the difference between '2005-01-01' and '2001-01-01' in MonetDB is calculated in seconds, and this must be converted manually into days, months, or years by further calculations.",
                "examples": [
                    "SELECT CAST(DATE '2005-01-01' AS DATE) - CAST(DATE '2001-01-01' AS DATE);  -- 126230400 seconds"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP\n",
            "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF\n",
            "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF\n",
            "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT\n",
            "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME\n",
            "SELECT TIMESTAMPADD(MINUTE, 1, '2003-01-02 23:59:59' ); -- TIMESTAMPADD\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);\n",
            "SELECT DATE '2007-12-31 23:59:59' - DATE '2007-12-30 00:00:00';\n",
            "SELECT EXTRACT(EPOCH FROM timestamp '2000-01-01 00:00:00' - timestamp '2000-01-01 00:00:00');\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '2009-10-10 23:59:59', 'W MM YYYY');\n",
            "SELECT sys.time_to_str(TIMESTAMP '2003-12-31 23:59:59', '%H:%M:%S');\n",
            "SELECT TIMESTAMP '2003-01-02 23:59:59' + INTERVAL '1' MINUTE;\n"
        ]
    },
    {
        "sql_id": 13,
        "database_name": "BUTTERTrans_13",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TO_SECONDS( '2009-11-29 23:59:59' ); -- TO_SECONDS",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2009-11-29 23:59:59') + 62167219200;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TO_SECONDS",
                "start_pos": 7,
                "end_pos": 17
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_SECONDS(datetime_expr)",
                "description": "Returns the number of seconds since year 0 to the given datetime.",
                "examples": [
                    "SELECT TO_SECONDS('2000-01-01 00:00:00');",
                    "SELECT TO_SECONDS(NOW());",
                    "SELECT TO_SECONDS(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM ts) + 62167219200",
                "description": "Converts timestamp to the number of seconds since the year 0 by extracting the Unix epoch and adding the seconds from year 0 to 1970.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
                    "SELECT EXTRACT(EPOCH FROM NOW()) + 62167219200;",
                    "SELECT CASE WHEN NULL IS NULL THEN NULL ELSE EXTRACT(EPOCH FROM NULL) + 62167219200 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP( '2001-01-01 00:00:00' ); -- TIMESTAMP\n",
            "SELECT DATEDIFF( '2007-12-31 23:59:59', '2007-12-30  00:00:00' ); -- DATEDIFF\n",
            "SELECT TIMEDIFF( '2000:01:01 00:00:00','2000:01:01 00:00:00' ); -- TIMEDIFF\n",
            "SELECT DATE_FORMAT( '2009-10-10 23:59:59', '%W %M %Y' ); -- DATE_FORMAT\n",
            "SELECT TIME( '2003-12-31 23:59:59' ); -- TIME\n",
            "SELECT TIMESTAMPADD(MINUTE, 1, '2003-01-02 23:59:59' ); -- TIMESTAMPADD\n",
            "SELECT TIMESTAMPDIFF(MONTH, '2003-02-01 23:59:59', '2003-05-01' ); -- TIMESTAMPDIFF\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (ts int);\n",
            "DROP TABLE t1;\n",
            "SELECT CAST('2001-01-01 00:00:00' AS TIMESTAMP);\n",
            "SELECT DATE '2007-12-31 23:59:59' - DATE '2007-12-30 00:00:00';\n",
            "SELECT EXTRACT(EPOCH FROM timestamp '2000-01-01 00:00:00' - timestamp '2000-01-01 00:00:00');\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '2009-10-10 23:59:59', 'W MM YYYY');\n",
            "SELECT sys.time_to_str(TIMESTAMP '2003-12-31 23:59:59', '%H:%M:%S');\n",
            "SELECT TIMESTAMP '2003-01-02 23:59:59' + INTERVAL '1' MINUTE;\n",
            "SELECT CAST(DATE '2003-05-01' AS DATE) - CAST(DATE '2003-02-01 23:59:59' AS DATE);\n"
        ]
    },
    {
        "sql_id": 14,
        "database_name": "BUTTERTrans_14",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select length(concat('*',s1,'*',s2,'*')) from t1; -- LENGTH, CONCAT",
        "target_query": "select octet_length('*' || s1 || '*' || s2 || '*') from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 14,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (s1 blob);\n",
            "insert into t1 values (0x61), (0x6120), (0x612020);\n",
            "drop table t1;\n",
            "create table t1 (s1 blob, s2 blob);\n",
            "insert into t1 values (0x4100,0x4100);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (s1 blob);\n",
            "insert into t1 values (X'61'), (X'6120'), (X'612020');\n",
            "drop table t1;\n",
            "create table t1 (s1 blob, s2 blob);\n",
            "insert into t1 values (X'4100',X'4100');\n"
        ]
    },
    {
        "sql_id": 15,
        "database_name": "BUTTERTrans_15",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select convert(123456789,unsigned); -- CONVERT",
        "target_query": "select CAST(123456789 AS BIGINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONVERT",
                "start_pos": 7,
                "end_pos": 14
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONVERT(expression USING charset)",
                "description": "Converts data types or changes the character set.",
                "examples": [
                    "SELECT CONVERT('Hello World' USING utf8);",
                    "SELECT CONVERT(1234, CHAR);",
                    "SELECT CONVERT(column_name USING latin1) FROM my_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(expression AS target_type)",
                "description": "MonetDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
                "examples": [
                    "SELECT CAST('Hello World' AS TEXT);",
                    "SELECT CAST(1234 AS VARCHAR);",
                    "SELECT CAST(column_name AS TEXT) FROM my_table;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (s1 blob);\n",
            "insert into t1 values (0x61), (0x6120), (0x612020);\n",
            "drop table t1;\n",
            "create table t1 (s1 blob, s2 blob);\n",
            "insert into t1 values (0x4100,0x4100);\n",
            "select length(concat('*',s1,'*',s2,'*')) from t1; -- LENGTH, CONCAT\n",
            "drop table t1;\n",
            "create table t1 (s1 blob, s2 varchar(1));\n",
            "insert into t1 values (0x41,'a'), (0x4100,'b'), (0x41,'c'), (0x4100,'d');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (s1 blob);\n",
            "insert into t1 values (X'61'), (X'6120'), (X'612020');\n",
            "drop table t1;\n",
            "create table t1 (s1 blob, s2 blob);\n",
            "insert into t1 values (X'4100',X'4100');\n",
            "select octet_length('*' || s1 || '*' || s2 || '*') from t1;\n",
            "drop table t1;\n",
            "create table t1 (s1 blob, s2 varchar(1));\n",
            "insert into t1 values (X'41','a'), (X'4100','b'), (X'41','c'), (X'4100','d');\n"
        ]
    },
    {
        "sql_id": 16,
        "database_name": "BUTTERTrans_16",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW",
        "target_query": "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE",
                "start_pos": 23,
                "end_pos": 27
            },
            {
                "dialect_token": "NOW",
                "start_pos": 28,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
                "examples": [
                    "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
                    "SELECT CAST(NOW() AS DATE) AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n"
        ]
    },
    {
        "sql_id": 17,
        "database_name": "BUTTERTrans_17",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 34,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);\n"
        ]
    },
    {
        "sql_id": 18,
        "database_name": "BUTTERTrans_18",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW",
        "target_query": "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE",
                "start_pos": 23,
                "end_pos": 27
            },
            {
                "dialect_token": "NOW",
                "start_pos": 28,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
                "examples": [
                    "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
                    "SELECT CAST(NOW() AS DATE) AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n"
        ]
    },
    {
        "sql_id": 19,
        "database_name": "BUTTERTrans_19",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 34,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);\n"
        ]
    },
    {
        "sql_id": 20,
        "database_name": "BUTTERTrans_20",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP AND b = 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 34,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n"
        ]
    },
    {
        "sql_id": 21,
        "database_name": "BUTTERTrans_21",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE",
        "target_query": "CREATE TABLE t1 AS SELECT current_date AS f1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CURDATE",
                "start_pos": 23,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CURDATE()",
                "description": "Returns the current date without the time component.",
                "examples": [
                    "SELECT CURDATE();",
                    "SELECT CONCAT('Today\\'s date is: ', CURDATE());",
                    "SELECT 1 WHERE CURDATE() = CURDATE();"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "current_date",
                "description": "Returns the current date without the time component, equivalent to MySQL's CURDATE().",
                "examples": [
                    "SELECT current_date;",
                    "SELECT CONCAT('Today\\'s date is: ', current_date);",
                    "SELECT 1 WHERE current_date = current_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP AND b = 1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 22,
        "database_name": "BUTTERTrans_22",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT hour(f1), minute(f1), second(f1) FROM t1; -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HOUR",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "MINUTE",
                "start_pos": 17,
                "end_pos": 23
            },
            {
                "dialect_token": "SECOND",
                "start_pos": 29,
                "end_pos": 35
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Returns the hour component of a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "\"minute\"()",
                "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
                "examples": [
                    "SELECT \"minute\"(time '12:34:56');",
                    "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
                    "SELECT \"minute\"(NULL);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP AND b = 1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT current_date AS f1;\n"
        ]
    },
    {
        "sql_id": 23,
        "database_name": "BUTTERTrans_23",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT 1 FROM (SELECT MAKEDATE(2011,0)) a; -- MAKEDATE",
        "target_query": "SELECT 1 FROM (SELECT DATE '2011-01-01' + INTERVAL '-1' DAY) a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKEDATE",
                "start_pos": 22,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
                "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
                "examples": [
                    "SELECT DATE '2009-01-01' AS first_day_of_year;",
                    "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
                    "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 1); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n",
            "INSERT INTO t1 VALUES (DATE(NOW()), 2); -- DATE, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW(); -- COUNT, NOW\n",
            "SELECT COUNT(*) FROM t1 WHERE a = NOW() AND b = 1; -- COUNT, NOW\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 SELECT curdate() AS f1; -- CURDATE\n",
            "SELECT hour(f1), minute(f1), second(f1) FROM t1; -- HOUR, MINUTE, SECOND\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(a DATE, b YEAR);\n",
            "INSERT INTO t1 VALUES ('2011-01-01',2011);\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE, b INT);\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 1);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n",
            "INSERT INTO t1 VALUES (CAST(CURRENT_TIMESTAMP AS DATE), 2);\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP;\n",
            "SELECT COUNT(*) FROM t1 WHERE a = CURRENT_TIMESTAMP AND b = 1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT current_date AS f1;\n",
            "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(a DATE, b SMALLINT);\n",
            "INSERT INTO t1 VALUES ('2011-01-01',2011);\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 24,
        "database_name": "BUTTERTrans_24",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select Fld1, max(Fld2) from t1 group by Fld1 having std(Fld2) is not null; -- STD",
        "target_query": "select Fld1, max(Fld2) from t1 group by Fld1 having stddev_samp(Fld2) is not null;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STD",
                "start_pos": 52,
                "end_pos": 55
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STD(expression)",
                "description": "Calculates the standard deviation for the sample of a given expression.",
                "examples": [
                    "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), STD(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
                    "SELECT another_dimension, COUNT(*), STD(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
                    "SELECT ROUND(STD(expression1 / expression2), 5) FROM more_data;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "stddev_samp(expression)",
                "description": "Calculates the standard deviation for the sample of a given expression.",
                "examples": [
                    "SELECT some_dimension, COUNT(*), MIN(some_expression), MAX(some_expression), SUM(some_expression), AVG(some_expression), stddev_samp(some_expression) FROM some_data GROUP BY some_dimension LIMIT 5;",
                    "SELECT another_dimension, COUNT(*), stddev_samp(expression1 / expression2) FROM another_data GROUP BY another_dimension ORDER BY another_dimension;",
                    "SELECT ROUND(stddev_samp(expression1 / expression2), 5) FROM more_data;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (Fld1 int(11) default NULL,Fld2 int(11) default NULL);\n",
            "INSERT INTO t1 VALUES (1,10),(1,20),(2,NULL),(2,NULL),(3,50);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (Fld1 int default NULL,Fld2 int default NULL);\n",
            "INSERT INTO t1 VALUES (1,10),(1,20),(2,NULL),(2,NULL),(3,50),(3,40);\n"
        ]
    },
    {
        "sql_id": 25,
        "database_name": "BUTTERTrans_25",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT",
        "target_query": "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(2000+A.a AS STRING) || '=w', 'filler-1' FROM t2 A;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 22,
                "end_pos": 28
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 52,
                "end_pos": 58
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(a int);\n",
            "insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2(a int);\n",
            "insert into t2 select A.a + 10*(B.a + 10*C.a) from t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "create table t3 (a char(8) not null, b char(8) not null, filler char(200));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT);\n",
            "INSERT INTO t1 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT);\n",
            "INSERT INTO t2 SELECT A.a + 10*(B.a + 10*C.a) FROM t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3 (a CHAR(8) NOT NULL, b CHAR(8) NOT NULL, filler CHAR(200));\n"
        ]
    },
    {
        "sql_id": 26,
        "database_name": "BUTTERTrans_26",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 3000+A.a, '=w'),'filler-2' from t2 A; -- CONCAT",
        "target_query": "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(3000+A.a AS STRING) || '=w', 'filler-2' FROM t2 A;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 22,
                "end_pos": 28
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 52,
                "end_pos": 58
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(a int);\n",
            "insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2(a int);\n",
            "insert into t2 select A.a + 10*(B.a + 10*C.a) from t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "create table t3 (a char(8) not null, b char(8) not null, filler char(200));\n",
            "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT);\n",
            "INSERT INTO t1 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT);\n",
            "INSERT INTO t2 SELECT A.a + 10*(B.a + 10*C.a) FROM t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3 (a CHAR(8) NOT NULL, b CHAR(8) NOT NULL, filler CHAR(200));\n",
            "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(2000+A.a AS STRING) || '=w', 'filler-1' FROM t2 A;\n"
        ]
    },
    {
        "sql_id": 27,
        "database_name": "BUTTERTrans_27",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT",
        "target_query": "UPDATE t1 SET b=REPEAT(CAST(65+a AS CHAR), 20) WHERE a < 25;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 16,
                "end_pos": 22
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(a int);\n",
            "insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2(a int);\n",
            "insert into t2 select A.a + 10*(B.a + 10*C.a) from t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "create table t3 (a char(8) not null, b char(8) not null, filler char(200));\n",
            "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT\n",
            "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 3000+A.a, '=w'),'filler-2' from t2 A; -- CONCAT\n",
            "insert into t3 values ('c-1013=z', 'c-1013=z', 'err');\n",
            "insert into t3 values ('a-1014=w', 'a-1014=w', 'err');\n",
            "delete from t3 where b in ('c-1013=z', 'a-1014=w');\n",
            "insert into t3 values ('c-1013=w', 'del-me', 'inserted');\n",
            "delete from t3 where b='del-me';\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "DROP TABLE t3;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "create table t0 (a int);\n",
            "insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "create table t1 (a int, b char(20), filler char(200));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT);\n",
            "INSERT INTO t1 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT);\n",
            "INSERT INTO t2 SELECT A.a + 10*(B.a + 10*C.a) FROM t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3 (a CHAR(8) NOT NULL, b CHAR(8) NOT NULL, filler CHAR(200));\n",
            "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(2000+A.a AS STRING) || '=w', 'filler-1' FROM t2 A;\n",
            "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(3000+A.a AS STRING) || '=w', 'filler-2' FROM t2 A;\n",
            "INSERT INTO t3 VALUES ('c-1013=z', 'c-1013=z', 'err');\n",
            "INSERT INTO t3 VALUES ('a-1014=w', 'a-1014=w', 'err');\n",
            "DELETE FROM t3 WHERE b IN ('c-1013=z', 'a-1014=w');\n",
            "INSERT INTO t3 VALUES ('c-1013=w', 'del-me', 'inserted');\n",
            "DELETE FROM t3 WHERE b='del-me';\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "DROP TABLE t3;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0 (a INT);\n",
            "INSERT INTO t0 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "CREATE TABLE t1 (a INT, b char(20), filler CHAR(200));\n"
        ]
    },
    {
        "sql_id": 28,
        "database_name": "BUTTERTrans_28",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "explain select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE a < 10 AND b = REPEAT(CAST(65+a AS CHAR), 20);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 46,
                "end_pos": 52
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(a int);\n",
            "insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2(a int);\n",
            "insert into t2 select A.a + 10*(B.a + 10*C.a) from t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "create table t3 (a char(8) not null, b char(8) not null, filler char(200));\n",
            "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT\n",
            "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 3000+A.a, '=w'),'filler-2' from t2 A; -- CONCAT\n",
            "insert into t3 values ('c-1013=z', 'c-1013=z', 'err');\n",
            "insert into t3 values ('a-1014=w', 'a-1014=w', 'err');\n",
            "delete from t3 where b in ('c-1013=z', 'a-1014=w');\n",
            "insert into t3 values ('c-1013=w', 'del-me', 'inserted');\n",
            "delete from t3 where b='del-me';\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "DROP TABLE t3;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "create table t0 (a int);\n",
            "insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "create table t1 (a int, b char(20), filler char(200));\n",
            "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT);\n",
            "INSERT INTO t1 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT);\n",
            "INSERT INTO t2 SELECT A.a + 10*(B.a + 10*C.a) FROM t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3 (a CHAR(8) NOT NULL, b CHAR(8) NOT NULL, filler CHAR(200));\n",
            "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(2000+A.a AS STRING) || '=w', 'filler-1' FROM t2 A;\n",
            "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(3000+A.a AS STRING) || '=w', 'filler-2' FROM t2 A;\n",
            "INSERT INTO t3 VALUES ('c-1013=z', 'c-1013=z', 'err');\n",
            "INSERT INTO t3 VALUES ('a-1014=w', 'a-1014=w', 'err');\n",
            "DELETE FROM t3 WHERE b IN ('c-1013=z', 'a-1014=w');\n",
            "INSERT INTO t3 VALUES ('c-1013=w', 'del-me', 'inserted');\n",
            "DELETE FROM t3 WHERE b='del-me';\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "DROP TABLE t3;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0 (a INT);\n",
            "INSERT INTO t0 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "CREATE TABLE t1 (a INT, b char(20), filler CHAR(200));\n",
            "UPDATE t1 SET b=REPEAT(CAST(65+a AS CHAR), 20) WHERE a < 25;\n"
        ]
    },
    {
        "sql_id": 29,
        "database_name": "BUTTERTrans_29",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT",
        "target_query": "SELECT * FROM t1 WHERE a < 10 AND b = REPEAT(CAST(65+a AS CHAR), 20);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 38,
                "end_pos": 44
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(a int);\n",
            "insert into t1 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2(a int);\n",
            "insert into t2 select A.a + 10*(B.a + 10*C.a) from t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "create table t3 (a char(8) not null, b char(8) not null, filler char(200));\n",
            "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 2000+A.a, '=w'),'filler-1' from t2 A; -- CONCAT\n",
            "insert into t3 select concat('c-', 1000+A.a, '=w'), concat('c-', 3000+A.a, '=w'),'filler-2' from t2 A; -- CONCAT\n",
            "insert into t3 values ('c-1013=z', 'c-1013=z', 'err');\n",
            "insert into t3 values ('a-1014=w', 'a-1014=w', 'err');\n",
            "delete from t3 where b in ('c-1013=z', 'a-1014=w');\n",
            "insert into t3 values ('c-1013=w', 'del-me', 'inserted');\n",
            "delete from t3 where b='del-me';\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "DROP TABLE t3;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "create table t0 (a int);\n",
            "insert into t0 values (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "create table t1 (a int, b char(20), filler char(200));\n",
            "update t1 set b=repeat(char(65+a), 20) where a < 25; -- REPEAT\n",
            "explain select * from t1 where a < 10 and b = repeat(char(65+a), 20); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT);\n",
            "INSERT INTO t1 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT);\n",
            "INSERT INTO t2 SELECT A.a + 10*(B.a + 10*C.a) FROM t1 A, t1 B, t1 C;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3 (a CHAR(8) NOT NULL, b CHAR(8) NOT NULL, filler CHAR(200));\n",
            "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(2000+A.a AS STRING) || '=w', 'filler-1' FROM t2 A;\n",
            "INSERT INTO t3 SELECT 'c-' || CAST(1000+A.a AS STRING) || '=w', 'c-' || CAST(3000+A.a AS STRING) || '=w', 'filler-2' FROM t2 A;\n",
            "INSERT INTO t3 VALUES ('c-1013=z', 'c-1013=z', 'err');\n",
            "INSERT INTO t3 VALUES ('a-1014=w', 'a-1014=w', 'err');\n",
            "DELETE FROM t3 WHERE b IN ('c-1013=z', 'a-1014=w');\n",
            "INSERT INTO t3 VALUES ('c-1013=w', 'del-me', 'inserted');\n",
            "DELETE FROM t3 WHERE b='del-me';\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "DROP TABLE t3;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0 (a INT);\n",
            "INSERT INTO t0 VALUES (0),(1),(2),(3),(4),(5),(6),(7),(8),(9);\n",
            "CREATE TABLE t1 (a INT, b char(20), filler CHAR(200));\n",
            "UPDATE t1 SET b=REPEAT(CAST(65+a AS CHAR), 20) WHERE a < 25;\n",
            "EXPLAIN SELECT * FROM t1 WHERE a < 10 AND b = REPEAT(CAST(65+a AS CHAR), 20);\n"
        ]
    },
    {
        "sql_id": 30,
        "database_name": "BUTTERTrans_30",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT",
        "target_query": "UPDATE t1 set data=repeat('a',18*1024);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 19,
                "end_pos": 25
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data LONGBLOB);\n",
            "INSERT INTO t1 (data) VALUES ('aaa');\n"
        ],
        "target_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data BLOB);\n",
            "INSERT INTO t1 (data) VALUES (X'616161');\n"
        ]
    },
    {
        "sql_id": 31,
        "database_name": "BUTTERTrans_31",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select length(data) from t1; -- LENGTH",
        "target_query": "select octet_length(data) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data LONGBLOB);\n",
            "INSERT INTO t1 (data) VALUES ('aaa');\n",
            "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data BLOB);\n",
            "INSERT INTO t1 (data) VALUES (X'616161');\n",
            "UPDATE t1 set data=repeat('a',18*1024);\n"
        ]
    },
    {
        "sql_id": 32,
        "database_name": "BUTTERTrans_32",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT",
        "target_query": "INSERT INTO t1 (data) VALUES (repeat('a',1*1024));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 30,
                "end_pos": 36
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data LONGBLOB);\n",
            "INSERT INTO t1 (data) VALUES ('aaa');\n",
            "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT\n",
            "select length(data) from t1; -- LENGTH\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n"
        ],
        "target_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data BLOB);\n",
            "INSERT INTO t1 (data) VALUES (X'616161');\n",
            "UPDATE t1 set data=repeat('a',18*1024);\n",
            "select octet_length(data) from t1;\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n"
        ]
    },
    {
        "sql_id": 33,
        "database_name": "BUTTERTrans_33",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024)); -- REPEAT",
        "target_query": "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 30,
                "end_pos": 36
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data LONGBLOB);\n",
            "INSERT INTO t1 (data) VALUES ('aaa');\n",
            "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT\n",
            "select length(data) from t1; -- LENGTH\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data BLOB);\n",
            "INSERT INTO t1 (data) VALUES (X'616161');\n",
            "UPDATE t1 set data=repeat('a',18*1024);\n",
            "select octet_length(data) from t1;\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a',1*1024));\n"
        ]
    },
    {
        "sql_id": 34,
        "database_name": "BUTTERTrans_34",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "UPDATE t1 set data=repeat('c',17*1024); -- REPEAT",
        "target_query": "UPDATE t1 set data=repeat('c',17*1024);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 19,
                "end_pos": 25
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data LONGBLOB);\n",
            "INSERT INTO t1 (data) VALUES ('aaa');\n",
            "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT\n",
            "select length(data) from t1; -- LENGTH\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT\n",
            "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024)); -- REPEAT\n",
            "delete from t1 where left(data,1)='b';\n"
        ],
        "target_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data BLOB);\n",
            "INSERT INTO t1 (data) VALUES (X'616161');\n",
            "UPDATE t1 set data=repeat('a',18*1024);\n",
            "select octet_length(data) from t1;\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a',1*1024));\n",
            "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024));\n",
            "delete from t1 where left(data,1)='b';\n"
        ]
    },
    {
        "sql_id": 35,
        "database_name": "BUTTERTrans_35",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select length(data) from t1; -- LENGTH",
        "target_query": "select octet_length(data) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "CREATE TABLE t1 (data LONGBLOB);"
        ],
        "target_related_schemas": [
            "CREATE TABLE t1 (data BLOB);"
        ]
    },
    {
        "sql_id": 36,
        "database_name": "BUTTERTrans_36",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 set data=repeat('a',18*1024); -- REPEAT",
        "target_query": "INSERT INTO t1 (data) VALUES (repeat('a', 18*1024));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data LONGBLOB);\n",
            "INSERT INTO t1 (data) VALUES ('aaa');\n",
            "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT\n",
            "select length(data) from t1; -- LENGTH\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT\n",
            "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024)); -- REPEAT\n",
            "delete from t1 where left(data,1)='b';\n",
            "UPDATE t1 set data=repeat('c',17*1024); -- REPEAT\n",
            "delete from t1 where left(data,1)='c';\n",
            "select length(data) from t1; -- LENGTH\n"
        ],
        "target_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data BLOB);\n",
            "INSERT INTO t1 (data) VALUES (X'616161');\n",
            "UPDATE t1 set data=repeat('a',18*1024);\n",
            "select octet_length(data) from t1;\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a',1*1024));\n",
            "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024));\n",
            "delete from t1 where left(data,1)='b';\n",
            "UPDATE t1 set data=repeat('c',17*1024);\n",
            "delete from t1 where left(data,1)='c';\n",
            "select octet_length(data) from t1;\n"
        ]
    },
    {
        "sql_id": 37,
        "database_name": "BUTTERTrans_37",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select length(data) from t1; -- LENGTH",
        "target_query": "select octet_length(data) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data LONGBLOB);\n",
            "INSERT INTO t1 (data) VALUES ('aaa');\n",
            "UPDATE t1 set data=repeat('a',18*1024); -- REPEAT\n",
            "select length(data) from t1; -- LENGTH\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a',1*1024)); -- REPEAT\n",
            "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024)); -- REPEAT\n",
            "delete from t1 where left(data,1)='b';\n",
            "UPDATE t1 set data=repeat('c',17*1024); -- REPEAT\n",
            "delete from t1 where left(data,1)='c';\n",
            "select length(data) from t1; -- LENGTH\n",
            "INSERT INTO t1 set data=repeat('a',18*1024); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "drop table if exists t1;\n",
            "CREATE TABLE t1 (data BLOB);\n",
            "INSERT INTO t1 (data) VALUES (X'616161');\n",
            "UPDATE t1 set data=repeat('a',18*1024);\n",
            "select octet_length(data) from t1;\n",
            "delete from t1 where left(data,1)='a';\n",
            "truncate table t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a',1*1024));\n",
            "INSERT INTO t1 (data) VALUES (repeat('b',16*1024-1024));\n",
            "delete from t1 where left(data,1)='b';\n",
            "UPDATE t1 set data=repeat('c',17*1024);\n",
            "delete from t1 where left(data,1)='c';\n",
            "select octet_length(data) from t1;\n",
            "INSERT INTO t1 (data) VALUES (repeat('a', 18*1024));\n"
        ]
    },
    {
        "sql_id": 38,
        "database_name": "BUTTERTrans_38",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,1234567890 % 3 as part2; -- UNIX_TIMESTAMP",
        "target_query": "SELECT '2011-01-01 00:00:00' AS time_t, EXTRACT(EPOCH FROM TIMESTAMP '2011-01-01 00:00:00') % 3 AS part, 1234567890 % 3 AS part2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            },
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 55,
                "end_pos": 69
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 39,
        "database_name": "BUTTERTrans_39",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t3 (a) VALUES (NOW()); -- NOW",
        "target_query": "INSERT INTO t3 (a) VALUES (CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 27,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,1234567890 % 3 as part2; -- UNIX_TIMESTAMP\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a timestamp,b char(10));\n"
        ],
        "target_related_schemas": [
            "SELECT '2011-01-01 00:00:00' AS time_t, EXTRACT(EPOCH FROM TIMESTAMP '2011-01-01 00:00:00') % 3 AS part, 1234567890 % 3 AS part2;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a TIMESTAMP, b CHAR(10));\n"
        ]
    },
    {
        "sql_id": 40,
        "database_name": "BUTTERTrans_40",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t2 VALUES (1 + (SELECT a FROM t1),CONCAT(\"subq: \", (SELECT b FROM t1))); -- CONCAT",
        "target_query": "INSERT INTO t2 SELECT 1 + a, 'subq: ' || b FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 46,
                "end_pos": 52
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT UNIX_TIMESTAMP('2011-01-01 00:00:00') as time_t,UNIX_TIMESTAMP('2011-01-01 00:00:00') % 3 as part,1234567890 % 3 as part2; -- UNIX_TIMESTAMP\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a timestamp,b char(10));\n",
            "INSERT INTO t3 (a) VALUES (NOW()); -- NOW\n",
            "INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');\n",
            "DELETE FROM t3 WHERE a = 0;\n",
            "DROP TABLE t3;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INT, b VARCHAR(64));\n",
            "INSERT INTO t1 VALUES (1, \"test 1\");\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a INT, b VARCHAR(64));\n",
            "INSERT INTO t2 VALUES ((SELECT a FROM t1), (SELECT b FROM t1));\n"
        ],
        "target_related_schemas": [
            "SELECT '2011-01-01 00:00:00' AS time_t, EXTRACT(EPOCH FROM TIMESTAMP '2011-01-01 00:00:00') % 3 AS part, 1234567890 % 3 AS part2;\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a TIMESTAMP, b CHAR(10));\n",
            "INSERT INTO t3 (a) VALUES (CURRENT_TIMESTAMP);\n",
            "INSERT INTO t3 (a) VALUES ('2011-01-01 00:00:00');\n",
            "DELETE FROM t3 WHERE a = TIMESTAMP '1970-01-01 00:00:00';\n",
            "DROP TABLE t3;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INT, b VARCHAR(64));\n",
            "INSERT INTO t1 VALUES (1, 'test 1');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a INT, b VARCHAR(64));\n",
            "INSERT INTO t2 SELECT a, b FROM t1;\n"
        ]
    },
    {
        "sql_id": 41,
        "database_name": "BUTTERTrans_41",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a' IN 'abc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n"
        ]
    },
    {
        "sql_id": 42,
        "database_name": "BUTTERTrans_42",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('b' IN 'abc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n"
        ]
    },
    {
        "sql_id": 43,
        "database_name": "BUTTERTrans_43",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('c' IN 'abc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n"
        ]
    },
    {
        "sql_id": 44,
        "database_name": "BUTTERTrans_44",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('d' IN 'abc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n"
        ]
    },
    {
        "sql_id": 45,
        "database_name": "BUTTERTrans_45",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a' IN NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n"
        ]
    },
    {
        "sql_id": 46,
        "database_name": "BUTTERTrans_46",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION(NULL IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n"
        ]
    },
    {
        "sql_id": 47,
        "database_name": "BUTTERTrans_47",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION(NULL IN NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n"
        ]
    },
    {
        "sql_id": 48,
        "database_name": "BUTTERTrans_48",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR",
        "target_query": "SELECT 'a' || POSITION('a' IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 12,
                "end_pos": 18
            },
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 19,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            },
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n"
        ]
    },
    {
        "sql_id": 49,
        "database_name": "BUTTERTrans_49",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a' IN CAST(1 AS STRING));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n"
        ]
    },
    {
        "sql_id": 50,
        "database_name": "BUTTERTrans_50",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a' IN CAST(1.1 AS STRING));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n"
        ]
    },
    {
        "sql_id": 51,
        "database_name": "BUTTERTrans_51",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION(CAST(1 AS STRING) IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n"
        ]
    },
    {
        "sql_id": 52,
        "database_name": "BUTTERTrans_52",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n"
        ]
    },
    {
        "sql_id": 53,
        "database_name": "BUTTERTrans_53",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR",
        "target_query": "SELECT POSITION(pattern IN subject) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n"
        ]
    },
    {
        "sql_id": 54,
        "database_name": "BUTTERTrans_54",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n"
        ]
    },
    {
        "sql_id": 55,
        "database_name": "BUTTERTrans_55",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'bcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n"
        ]
    },
    {
        "sql_id": 56,
        "database_name": "BUTTERTrans_56",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('b+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n"
        ]
    },
    {
        "sql_id": 57,
        "database_name": "BUTTERTrans_57",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('b+' IN 'cabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n"
        ]
    },
    {
        "sql_id": 58,
        "database_name": "BUTTERTrans_58",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('b+' IN 'abcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n"
        ]
    },
    {
        "sql_id": 59,
        "database_name": "BUTTERTrans_59",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n"
        ]
    },
    {
        "sql_id": 60,
        "database_name": "BUTTERTrans_60",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'bcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n"
        ]
    },
    {
        "sql_id": 61,
        "database_name": "BUTTERTrans_61",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'cabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n"
        ]
    },
    {
        "sql_id": 62,
        "database_name": "BUTTERTrans_62",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n"
        ]
    },
    {
        "sql_id": 63,
        "database_name": "BUTTERTrans_63",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n"
        ]
    },
    {
        "sql_id": 64,
        "database_name": "BUTTERTrans_64",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'a');\n"
        ]
    },
    {
        "sql_id": 65,
        "database_name": "BUTTERTrans_65",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'abcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'a');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n"
        ]
    },
    {
        "sql_id": 66,
        "database_name": "BUTTERTrans_66",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'a');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n"
        ]
    },
    {
        "sql_id": 67,
        "database_name": "BUTTERTrans_67",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'a');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'aaabcabcabc');\n"
        ]
    },
    {
        "sql_id": 68,
        "database_name": "BUTTERTrans_68",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'a');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n"
        ]
    },
    {
        "sql_id": 69,
        "database_name": "BUTTERTrans_69",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'a');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n"
        ]
    },
    {
        "sql_id": 70,
        "database_name": "BUTTERTrans_70",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('A+' IN 'aaabcabcabc');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'a');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n"
        ]
    },
    {
        "sql_id": 71,
        "database_name": "BUTTERTrans_71",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_instr( 'a', 'a+', 1, 1, 1, NULL ); -- REGEXP_INSTR",
        "target_query": "SELECT POSITION('a+' IN 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT regexp_instr( 'abc', 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'b' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abc', 'd' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( NULL, NULL ); -- REGEXP_INSTR\n",
            "SELECT hex( concat(regexp_instr( 'a', 'a' )) ); -- HEX, CONCAT, REGEXP_INSTR\n",
            "SELECT regexp_instr( 1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 1.1, 'a' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 1.1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( subject, pattern ) FROM t1; -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'b+', 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 3 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 4 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 4, 2 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'a', 'a+', 1, 1, NULL ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 0 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'abcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'a+', 1, 1, 1 ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'c' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'i' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'ci' ); -- REGEXP_INSTR\n",
            "SELECT regexp_instr( 'aaabcabcabc', 'A+', 1, 1, 1, 'cic' ); -- REGEXP_INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (subject char(10),pattern char(10));\n",
            "SELECT POSITION('a' IN 'abc');\n",
            "SELECT POSITION('b' IN 'abc');\n",
            "SELECT POSITION('c' IN 'abc');\n",
            "SELECT POSITION('d' IN 'abc');\n",
            "SELECT POSITION('a' IN NULL);\n",
            "SELECT POSITION(NULL IN 'a');\n",
            "SELECT POSITION(NULL IN NULL);\n",
            "SELECT 'a' || POSITION('a' IN 'a');\n",
            "SELECT POSITION('a' IN CAST(1 AS STRING));\n",
            "SELECT POSITION('a' IN CAST(1.1 AS STRING));\n",
            "SELECT POSITION(CAST(1 AS STRING) IN 'a');\n",
            "SELECT POSITION(CAST(1.1 AS STRING) IN 'a');\n",
            "SELECT POSITION(pattern IN subject) FROM t1;\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabcabc');\n",
            "SELECT POSITION('b+' IN 'cabcabc');\n",
            "SELECT POSITION('b+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'bcabcabc');\n",
            "SELECT POSITION('a+' IN 'cabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabc');\n",
            "SELECT POSITION('a+' IN 'a');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'abcabcabc');\n",
            "SELECT POSITION('a+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n",
            "SELECT POSITION('A+' IN 'aaabcabcabc');\n"
        ]
    },
    {
        "sql_id": 72,
        "database_name": "BUTTERTrans_72",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 73,
        "database_name": "BUTTERTrans_73",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'abc', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n"
        ]
    },
    {
        "sql_id": 74,
        "database_name": "BUTTERTrans_74",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( NULL, 'a', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n"
        ]
    },
    {
        "sql_id": 75,
        "database_name": "BUTTERTrans_75",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', NULL, 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n"
        ]
    },
    {
        "sql_id": 76,
        "database_name": "BUTTERTrans_76",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', NULL );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n"
        ]
    },
    {
        "sql_id": 77,
        "database_name": "BUTTERTrans_77",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 15,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            },
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n"
        ]
    },
    {
        "sql_id": 78,
        "database_name": "BUTTERTrans_78",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n"
        ]
    },
    {
        "sql_id": 79,
        "database_name": "BUTTERTrans_79",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n"
        ]
    },
    {
        "sql_id": 80,
        "database_name": "BUTTERTrans_80",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n"
        ]
    },
    {
        "sql_id": 81,
        "database_name": "BUTTERTrans_81",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n"
        ]
    },
    {
        "sql_id": 82,
        "database_name": "BUTTERTrans_82",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n"
        ]
    },
    {
        "sql_id": 83,
        "database_name": "BUTTERTrans_83",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n"
        ]
    },
    {
        "sql_id": 84,
        "database_name": "BUTTERTrans_84",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaab', 'b', 'x' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n"
        ]
    },
    {
        "sql_id": 85,
        "database_name": "BUTTERTrans_85",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabccc', 'b', 'x' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n"
        ]
    },
    {
        "sql_id": 86,
        "database_name": "BUTTERTrans_86",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'abc', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x' );\n"
        ]
    },
    {
        "sql_id": 87,
        "database_name": "BUTTERTrans_87",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n"
        ]
    },
    {
        "sql_id": 88,
        "database_name": "BUTTERTrans_88",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'abcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n"
        ]
    },
    {
        "sql_id": 89,
        "database_name": "BUTTERTrans_89",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n"
        ]
    },
    {
        "sql_id": 90,
        "database_name": "BUTTERTrans_90",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n"
        ]
    },
    {
        "sql_id": 91,
        "database_name": "BUTTERTrans_91",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n"
        ]
    },
    {
        "sql_id": 92,
        "database_name": "BUTTERTrans_92",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', 'X', 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'X' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n"
        ]
    },
    {
        "sql_id": 93,
        "database_name": "BUTTERTrans_93",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace( 'aaa', 'a', 'XX', 2 ); -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace( 'aaa', 'a', 'XX' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( NULL, 'a', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL ); -- REGEXP_REPLACE\n",
            "SELECT concat( regexp_replace( 'aaa', 'a', 'X' ), 'x' ); -- CONCAT, REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x', 1, 0 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x', 1, 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 1 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 2 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X', 3 ); -- REGEXP_REPLACE\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X', 2 ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( NULL, 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaa', NULL, 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', NULL );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' ) || 'x';\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'X' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', '(b+)', '<$1>' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'x+', 'x' );\n",
            "SELECT regexp_replace( 'aaabbccbbddaa', 'b+', 'x' );\n",
            "SELECT regexp_replace( 'aaab', 'b', 'x' );\n",
            "SELECT regexp_replace( 'aaabccc', 'b', 'x' );\n",
            "SELECT regexp_replace( 'abc', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'abcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaabcbdb', 'b', 'X' );\n",
            "SELECT regexp_replace( 'aaa', 'a', 'X' );\n"
        ]
    },
    {
        "sql_id": 94,
        "database_name": "BUTTERTrans_94",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR",
        "target_query": "INSERT INTO t1 VALUES (CAST(POSITION('a' IN 'a') AS REAL), CAST(POSITION('a' IN 'a') AS INT), CAST(POSITION('a' IN 'a') AS CHAR(100)), CAST(POSITION('a' IN 'a') AS DECIMAL));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 24,
                "end_pos": 36
            },
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 47,
                "end_pos": 59
            },
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 70,
                "end_pos": 82
            },
            {
                "dialect_token": "REGEXP_INSTR",
                "start_pos": 93,
                "end_pos": 105
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_INSTR('hello world', 'o')",
                "description": "MySQL's REGEXP_INSTR function returns the position of the first match of a regular expression in a string.",
                "examples": [
                    "SELECT REGEXP_INSTR('hello world', 'o');",
                    "SELECT REGEXP_INSTR('hello world', 'x');",
                    "SELECT REGEXP_INSTR('openai', 'a', 1, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION('o' IN 'hello world')",
                "description": "MonetDB does not support REGEXP_INSTR, but POSITION can be used to get the position of a substring in a string.",
                "examples": [
                    "SELECT POSITION('o' IN 'hello world');",
                    "SELECT POSITION('x' IN 'hello world');",
                    "SELECT POSITION('a' IN 'openai');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);\n"
        ]
    },
    {
        "sql_id": 95,
        "database_name": "BUTTERTrans_95",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE",
        "target_query": "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 30,
                "end_pos": 44
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);\n",
            "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);\n",
            "INSERT INTO t1 VALUES (CAST(POSITION('a' IN 'a') AS REAL), CAST(POSITION('a' IN 'a') AS INT), CAST(POSITION('a' IN 'a') AS CHAR(100)), CAST(POSITION('a' IN 'a') AS DECIMAL));\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n"
        ]
    },
    {
        "sql_id": 96,
        "database_name": "BUTTERTrans_96",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT length(regexp_replace( repeat('a', 'b'), 'a', 'b' )); -- LENGTH, REGEXP_REPLACE, REPEAT",
        "target_query": "SELECT octet_length(regexp_replace( repeat('a', 1), 'a', 'b' ));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 14,
                "end_pos": 28
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 30,
                "end_pos": 36
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);\n",
            "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);\n",
            "INSERT INTO t1 VALUES (CAST(POSITION('a' IN 'a') AS REAL), CAST(POSITION('a' IN 'a') AS INT), CAST(POSITION('a' IN 'a') AS CHAR(100)), CAST(POSITION('a' IN 'a') AS DECIMAL));\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 97,
        "database_name": "BUTTERTrans_97",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) ); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);\n",
            "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT length(regexp_replace( repeat('a', 'b'), 'a', 'b' )); -- LENGTH, REGEXP_REPLACE, REPEAT\n",
            "CREATE TABLE t1 ( a TEXT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);\n",
            "INSERT INTO t1 VALUES (CAST(POSITION('a' IN 'a') AS REAL), CAST(POSITION('a' IN 'a') AS INT), CAST(POSITION('a' IN 'a') AS CHAR(100)), CAST(POSITION('a' IN 'a') AS DECIMAL));\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT octet_length(regexp_replace( repeat('a', 1), 'a', 'b' ));\n",
            "CREATE TABLE t1 ( a TEXT);\n"
        ]
    },
    {
        "sql_id": 98,
        "database_name": "BUTTERTrans_98",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1; -- CHAR_LENGTH, REGEXP_REPLACE",
        "target_query": "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CHAR_LENGTH",
                "start_pos": 7,
                "end_pos": 18
            },
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 21,
                "end_pos": 35
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            },
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "char_length(expr)",
                "description": "Returns the number of characters in a string (char_length and length are equivalent).",
                "examples": [
                    "SELECT char_length('abc');",
                    "SELECT char_length('\u4f60\u597d');",
                    "SELECT char_length('a\u4f60b\u597dc');"
                ]
            },
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);\n",
            "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT length(regexp_replace( repeat('a', 'b'), 'a', 'b' )); -- LENGTH, REGEXP_REPLACE, REPEAT\n",
            "CREATE TABLE t1 ( a TEXT);\n",
            "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) ); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);\n",
            "INSERT INTO t1 VALUES (CAST(POSITION('a' IN 'a') AS REAL), CAST(POSITION('a' IN 'a') AS INT), CAST(POSITION('a' IN 'a') AS CHAR(100)), CAST(POSITION('a' IN 'a') AS DECIMAL));\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT octet_length(regexp_replace( repeat('a', 1), 'a', 'b' ));\n",
            "CREATE TABLE t1 ( a TEXT);\n",
            "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );\n"
        ]
    },
    {
        "sql_id": 99,
        "database_name": "BUTTERTrans_99",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1; -- REGEXP_REPLACE",
        "target_query": "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);\n",
            "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT length(regexp_replace( repeat('a', 'b'), 'a', 'b' )); -- LENGTH, REGEXP_REPLACE, REPEAT\n",
            "CREATE TABLE t1 ( a TEXT);\n",
            "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) ); -- REPEAT\n",
            "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1; -- CHAR_LENGTH, REGEXP_REPLACE\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a VARCHAR(10) );\n",
            "INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);\n",
            "INSERT INTO t1 VALUES (CAST(POSITION('a' IN 'a') AS REAL), CAST(POSITION('a' IN 'a') AS INT), CAST(POSITION('a' IN 'a') AS CHAR(100)), CAST(POSITION('a' IN 'a') AS DECIMAL));\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT octet_length(regexp_replace( repeat('a', 1), 'a', 'b' ));\n",
            "CREATE TABLE t1 ( a TEXT);\n",
            "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );\n",
            "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a VARCHAR(10) );\n",
            "INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');\n"
        ]
    },
    {
        "sql_id": 100,
        "database_name": "BUTTERTrans_100",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') ); -- REGEXP_REPLACE",
        "target_query": "INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 24,
                "end_pos": 38
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "CREATE TABLE t1 ( a CHAR(3) );"
        ],
        "target_related_schemas": [
            "CREATE TABLE t1 ( a CHAR(3) );"
        ]
    },
    {
        "sql_id": 101,
        "database_name": "BUTTERTrans_101",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' ); -- REGEXP_REPLACE",
        "target_query": "UPDATE t1 SET a = regexp_replace ( 'b', 'b', 'y' );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REGEXP_REPLACE",
                "start_pos": 18,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REGEXP_REPLACE(string, pattern, replacement, position, occurrence, match_type)",
                "description": "Replaces substrings matching a regular expression with a replacement string. Supports optional position, occurrence, and match type arguments.",
                "examples": [
                    "SELECT REGEXP_REPLACE('abcabcabc', 'b', 'X', 1, 2);",
                    "SELECT REGEXP_REPLACE('xxxyyyzzz', 'y+', '-', 1, 1);",
                    "SELECT REGEXP_REPLACE('qwe123rty456', '\\\\d+', '_', 1, 1);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "regexp_replace(string, pattern, replacement)",
                "description": "Replaces all matches of the pattern in the input string with the replacement. Pattern uses POSIX regular expressions.",
                "examples": [
                    "SELECT regexp_replace('abcabcabc', 'b', 'X');",
                    "SELECT regexp_replace('xxxyyyzzz', 'y+', '-');",
                    "SELECT regexp_replace('qwe123rty456', '[0-9]+', '_');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL,b INT,c CHAR(100),d DECIMAL);\n",
            "INSERT INTO t1 VALUES ( regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a'),regexp_instr('a', 'a') ); -- REGEXP_INSTR\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') ); -- REGEXP_REPLACE\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT length(regexp_replace( repeat('a', 'b'), 'a', 'b' )); -- LENGTH, REGEXP_REPLACE, REPEAT\n",
            "CREATE TABLE t1 ( a TEXT);\n",
            "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) ); -- REPEAT\n",
            "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1; -- CHAR_LENGTH, REGEXP_REPLACE\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a VARCHAR(10) );\n",
            "INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');\n",
            "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1; -- REGEXP_REPLACE\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a CHAR(3) );\n",
            "INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') ); -- REGEXP_REPLACE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a REAL, b INT, c CHAR(100), d DECIMAL);\n",
            "INSERT INTO t1 VALUES (CAST(POSITION('a' IN 'a') AS REAL), CAST(POSITION('a' IN 'a') AS INT), CAST(POSITION('a' IN 'a') AS CHAR(100)), CAST(POSITION('a' IN 'a') AS DECIMAL));\n",
            "DELETE FROM t1;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 ( c ) VALUES ( regexp_replace('a', 'a', 'a') );\n",
            "DELETE FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT octet_length(regexp_replace( repeat('a', 1), 'a', 'b' ));\n",
            "CREATE TABLE t1 ( a TEXT);\n",
            "INSERT INTO t1 VALUES ( repeat( 'a', 16384 ) );\n",
            "SELECT char_length ( regexp_replace( a, 'a', 'b' ) ) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a VARCHAR(10) );\n",
            "INSERT INTO t1 VALUES ('a a a'), ('b b b'), ('c c c');\n",
            "SELECT regexp_replace(a, '^([[:alpha:]]+)[[:space:]].*$', '$1') FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a CHAR(3) );\n",
            "INSERT INTO t1 VALUES ( regexp_replace ('a', 'a', 'x') );\n"
        ]
    },
    {
        "sql_id": 102,
        "database_name": "BUTTERTrans_102",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, concat(un,'x') from qn where n<10) select * from qn; -- CONCAT",
        "target_query": "WITH recursive qn as (select 1 as n, cast('x' as char(100)) as un union all select 1+n, un || 'x' from qn where n<10) select * from qn; -- CONCAT",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 88,
                "end_pos": 94
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS cmdata;\n",
            "CREATE TABLE cmdata(f1 text);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS cmdata;\n",
            "CREATE TABLE cmdata(f1 text);\n"
        ]
    },
    {
        "sql_id": 103,
        "database_name": "BUTTERTrans_103",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
        "target_query": "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 20,
                "end_pos": 26
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));\n"
        ]
    },
    {
        "sql_id": 104,
        "database_name": "BUTTERTrans_104",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH",
        "target_query": "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 20,
                "end_pos": 26
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));\n",
            "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH\n",
            "INSERT INTO t1 (id, gender, name) VALUES (1, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (2, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (3, NULL, NULL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));\n",
            "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;\n",
            "INSERT INTO t1 (id, gender, name) VALUES (1, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (2, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (3, NULL, NULL);\n"
        ]
    },
    {
        "sql_id": 105,
        "database_name": "BUTTERTrans_105",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT (SELECT SUM(DISTINCT LENGTH(name)) FROM t1) FROM t2; -- LENGTH",
        "target_query": "SELECT (SELECT SUM(DISTINCT octet_length(name)) FROM t1) FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 28,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));\n",
            "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH\n",
            "INSERT INTO t1 (id, gender, name) VALUES (1, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (2, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (3, NULL, NULL);\n",
            "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH\n",
            "INSERT INTO t1 (id, gender, name) VALUES (4, 'F', 'Helen'), (5, 'F', 'Anastasia'), (6, 'F', 'Katherine'), (7, 'F', 'Margo'), (8, 'F', 'Magdalene'), (9, 'F', 'Mary');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 SELECT name FROM t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));\n",
            "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;\n",
            "INSERT INTO t1 (id, gender, name) VALUES (1, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (2, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (3, NULL, NULL);\n",
            "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;\n",
            "INSERT INTO t1 (id, gender, name) VALUES (4, 'F', 'Helen'), (5, 'F', 'Anastasia'), (6, 'F', 'Katherine'), (7, 'F', 'Margo'), (8, 'F', 'Magdalene'), (9, 'F', 'Mary');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 AS SELECT name FROM t1;\n"
        ]
    },
    {
        "sql_id": 106,
        "database_name": "BUTTERTrans_106",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t2 VALUES (1,'18:19:29',NOW()); -- NOW",
        "target_query": "INSERT INTO t2 VALUES (1,'18:19:29',CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 36,
                "end_pos": 39
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));\n",
            "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH\n",
            "INSERT INTO t1 (id, gender, name) VALUES (1, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (2, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (3, NULL, NULL);\n",
            "SELECT SUM(DISTINCT LENGTH(name)) s1 FROM t1; -- LENGTH\n",
            "INSERT INTO t1 (id, gender, name) VALUES (4, 'F', 'Helen'), (5, 'F', 'Anastasia'), (6, 'F', 'Katherine'), (7, 'F', 'Margo'), (8, 'F', 'Magdalene'), (9, 'F', 'Mary');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 SELECT name FROM t1;\n",
            "SELECT (SELECT SUM(DISTINCT LENGTH(name)) FROM t1) FROM t2; -- LENGTH\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t2 (pk int(11) NOT NULL PRIMARY KEY,time_nokey time DEFAULT NULL,datetime_key time DEFAULT NULL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INTEGER NOT NULL PRIMARY KEY,gender CHAR(1),name VARCHAR(20));\n",
            "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;\n",
            "INSERT INTO t1 (id, gender, name) VALUES (1, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (2, NULL, NULL);\n",
            "INSERT INTO t1 (id, gender, name) VALUES (3, NULL, NULL);\n",
            "SELECT SUM(DISTINCT octet_length(name)) s1 FROM t1;\n",
            "INSERT INTO t1 (id, gender, name) VALUES (4, 'F', 'Helen'), (5, 'F', 'Anastasia'), (6, 'F', 'Katherine'), (7, 'F', 'Margo'), (8, 'F', 'Magdalene'), (9, 'F', 'Mary');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 AS SELECT name FROM t1;\n",
            "SELECT (SELECT SUM(DISTINCT octet_length(name)) FROM t1) FROM t2;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t2 (pk int NOT NULL PRIMARY KEY,time_nokey time DEFAULT NULL,datetime_key time DEFAULT NULL);\n"
        ]
    },
    {
        "sql_id": 107,
        "database_name": "BUTTERTrans_107",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LEAST(CAST('01-01-01' AS DATETIME), '01-01:02'); -- LEAST",
        "target_query": "SELECT CASE WHEN CAST('2001-01-01 00:00:01' AS TIMESTAMP) <= CAST('2001-01-01 00:00:02' AS TIMESTAMP) THEN CAST('2001-01-01 00:00:01' AS TIMESTAMP) ELSE CAST('2001-01-01 00:00:02' AS TIMESTAMP) END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 108,
        "database_name": "BUTTERTrans_108",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LEAST(CAST('2001-12-10' AS DATE), '2001-12/11'); -- LEAST",
        "target_query": "SELECT CASE WHEN CAST('2001-12-10' AS DATE) <= CAST('2001-12-11' AS DATE) THEN CAST('2001-12-10' AS DATE) ELSE CAST('2001-12-11' AS DATE) END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LEAST(CAST('01-01-01' AS DATETIME), '01-01:02'); -- LEAST\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN CAST('2001-01-01 00:00:01' AS TIMESTAMP) <= CAST('2001-01-01 00:00:02' AS TIMESTAMP) THEN CAST('2001-01-01 00:00:01' AS TIMESTAMP) ELSE CAST('2001-01-01 00:00:02' AS TIMESTAMP) END;\n"
        ]
    },
    {
        "sql_id": 109,
        "database_name": "BUTTERTrans_109",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LEAST(CAST('10:11:12' AS TIME), '10:11:13 '); -- LEAST",
        "target_query": "SELECT CASE WHEN CAST('10:11:12' AS TIME) <= CAST('10:11:13' AS TIME) THEN CAST('10:11:12' AS TIME) ELSE CAST('10:11:13' AS TIME) END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LEAST(CAST('01-01-01' AS DATETIME), '01-01:02'); -- LEAST\n",
            "SELECT LEAST(CAST('2001-12-10' AS DATE), '2001-12/11'); -- LEAST\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN CAST('2001-01-01 00:00:01' AS TIMESTAMP) <= CAST('2001-01-01 00:00:02' AS TIMESTAMP) THEN CAST('2001-01-01 00:00:01' AS TIMESTAMP) ELSE CAST('2001-01-01 00:00:02' AS TIMESTAMP) END;\n",
            "SELECT CASE WHEN CAST('2001-12-10' AS DATE) <= CAST('2001-12-11' AS DATE) THEN CAST('2001-12-10' AS DATE) ELSE CAST('2001-12-11' AS DATE) END;\n"
        ]
    },
    {
        "sql_id": 110,
        "database_name": "BUTTERTrans_110",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 30,
                "end_pos": 44
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 111,
        "database_name": "BUTTERTrans_111",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 30,
                "end_pos": 44
            },
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 92,
                "end_pos": 106
            },
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 154,
                "end_pos": 168
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n"
        ]
    },
    {
        "sql_id": 112,
        "database_name": "BUTTERTrans_112",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 30,
                "end_pos": 44
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n"
        ]
    },
    {
        "sql_id": 113,
        "database_name": "BUTTERTrans_113",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 30,
                "end_pos": 44
            },
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 92,
                "end_pos": 106
            },
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 154,
                "end_pos": 168
            },
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 216,
                "end_pos": 230
            },
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 278,
                "end_pos": 292
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n"
        ]
    },
    {
        "sql_id": 114,
        "database_name": "BUTTERTrans_114",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select from_unixtime(362793609); -- FROM_UNIXTIME",
        "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "FROM_UNIXTIME",
                "start_pos": 7,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
                "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
                "examples": [
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
                    "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 115,
        "database_name": "BUTTERTrans_115",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 (ts) values (now()); -- NOW",
        "target_query": "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 28,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 116,
        "database_name": "BUTTERTrans_116",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP",
        "target_query": "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n"
        ]
    },
    {
        "sql_id": 117,
        "database_name": "BUTTERTrans_117",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP",
        "target_query": "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 10,
                "end_pos": 24
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));"
        ],
        "target_related_schemas": [
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));"
        ]
    },
    {
        "sql_id": 118,
        "database_name": "BUTTERTrans_118",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP",
        "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 119,
        "database_name": "BUTTERTrans_119",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP",
        "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;\n"
        ]
    },
    {
        "sql_id": 120,
        "database_name": "BUTTERTrans_120",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP",
        "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), 'After the gap' AS b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;\n"
        ]
    },
    {
        "sql_id": 121,
        "database_name": "BUTTERTrans_121",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME",
        "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '0' SECOND;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "FROM_UNIXTIME",
                "start_pos": 7,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
                "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
                "examples": [
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
                    "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), 'After the gap' AS b;\n"
        ]
    },
    {
        "sql_id": 122,
        "database_name": "BUTTERTrans_122",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 15:59:59') AS BIGINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), 'After the gap' AS b;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '0' SECOND;\n"
        ]
    },
    {
        "sql_id": 123,
        "database_name": "BUTTERTrans_123",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:00\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:00') AS BIGINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), 'After the gap' AS b;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '0' SECOND;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 15:59:59') AS BIGINT);\n"
        ]
    },
    {
        "sql_id": 124,
        "database_name": "BUTTERTrans_124",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:01\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:01') AS BIGINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:00\"); -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), 'After the gap' AS b;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '0' SECOND;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 15:59:59') AS BIGINT);\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:00') AS BIGINT);\n"
        ]
    },
    {
        "sql_id": 125,
        "database_name": "BUTTERTrans_125",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP(\"1970-01-01 00:00:01\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 00:00:01') AS BIGINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:00\"); -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:01\"); -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), 'After the gap' AS b;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '0' SECOND;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 15:59:59') AS BIGINT);\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:00') AS BIGINT);\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:01') AS BIGINT);\n"
        ]
    },
    {
        "sql_id": 126,
        "database_name": "BUTTERTrans_126",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT UNIX_TIMESTAMP(\"2022-01-01 16:00:01\"); -- UNIX_TIMESTAMP",
        "target_query": "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2022-01-01 16:00:01') AS BIGINT);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNIX_TIMESTAMP",
                "start_pos": 7,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNIX_TIMESTAMP(expr)",
                "description": "Returns a Unix timestamp (seconds since '1970-01-01 00:00:00' UTC) from a given date or datetime expression.",
                "examples": [
                    "SELECT UNIX_TIMESTAMP(NOW());",
                    "SELECT UNIX_TIMESTAMP('2015-11-13 23:59:59');",
                    "SELECT UNIX_TIMESTAMP('2038-01-19 04:14:07');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp)",
                "description": "Returns the number of seconds since '1970-01-01 00:00:00' UTC by extracting the epoch from a timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM current_timestamp);",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2015-11-13 23:59:59+02:00');",
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2038-01-19 04:14:07');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, ts timestamp);\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-01 00:00:00'),'2003-03-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-03-30 01:59:59'),'2003-03-30 01:59:59'),(unix_timestamp('2003-03-30 02:30:00'),'2003-03-30 02:30:00'),(unix_timestamp('2003-03-30 03:00:00'),'2003-03-30 03:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-05-01 00:00:00'),'2003-05-01 00:00:00'); -- UNIX_TIMESTAMP\n",
            "insert into t1 (i, ts) values(unix_timestamp('2003-10-26 01:00:00'),'2003-10-26 01:00:00'),(unix_timestamp('2003-10-26 02:00:00'),'2003-10-26 02:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'),(unix_timestamp('2003-10-26 04:00:00'),'2003-10-26 04:00:00'),(unix_timestamp('2003-10-26 02:59:59'),'2003-10-26 02:59:59'); -- UNIX_TIMESTAMP\n",
            "truncate table t1;\n",
            "drop table t1;\n",
            "select from_unixtime(362793609); -- FROM_UNIXTIME\n",
            "create table t1 (ts timestamp);\n",
            "insert into t1 (ts) values (now()); -- NOW\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES('2003-03-30 01:59:59', 'Before the gap'),('2003-03-30 02:30:00', 'Inside the gap'),('2003-03-30 03:00:00',  'After the gap'); -- UNIX_TIMESTAMP\n",
            "SELECT a, UNIX_TIMESTAMP(a), b FROM t1; -- UNIX_TIMESTAMP\n",
            "DROP TABLE t1;\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 01:59:59'), 'Before the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 02:30:00'), 'Inside the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP('2003-03-30 03:00:00'), 'After the gap' AS b; -- UNIX_TIMESTAMP\n",
            "SELECT FROM_UNIXTIME(0); -- FROM_UNIXTIME\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 15:59:59\"); -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:00\"); -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP(\"1969-12-31 16:00:01\"); -- UNIX_TIMESTAMP\n",
            "SELECT UNIX_TIMESTAMP(\"1970-01-01 00:00:01\"); -- UNIX_TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i BIGINT, ts TIMESTAMP);\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-01 00:00:00') AS BIGINT), '2003-03-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), '2003-03-30 01:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), '2003-03-30 02:30:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), '2003-03-30 03:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-05-01 00:00:00') AS BIGINT), '2003-05-01 00:00:00');\n",
            "INSERT INTO t1 (i, ts) VALUES (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 01:00:00') AS BIGINT), '2003-10-26 01:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:00:00') AS BIGINT), '2003-10-26 02:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 04:00:00') AS BIGINT), '2003-10-26 04:00:00'), (CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-10-26 02:59:59') AS BIGINT), '2003-10-26 02:59:59');\n",
            "TRUNCATE TABLE t1;\n",
            "DROP TABLE t1;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '362793609' SECOND;\n",
            "CREATE TABLE t1 (ts TIMESTAMP);\n",
            "INSERT INTO t1 (ts) VALUES (CURRENT_TIMESTAMP);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP, b VARCHAR(30));\n",
            "INSERT INTO t1 VALUES ('2003-03-30 01:59:59', 'Before the gap'), ('2003-03-30 02:30:00', 'Inside the gap'), ('2003-03-30 03:00:00', 'After the gap');\n",
            "SELECT a, CAST(EXTRACT(EPOCH FROM a) AS BIGINT) AS unix_ts, b FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 01:59:59') AS BIGINT), 'Before the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 02:30:00') AS BIGINT), 'Inside the gap' AS b;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '2003-03-30 03:00:00') AS BIGINT), 'After the gap' AS b;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '0' SECOND;\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 15:59:59') AS BIGINT);\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:00') AS BIGINT);\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1969-12-31 16:00:01') AS BIGINT);\n",
            "SELECT CAST(EXTRACT(EPOCH FROM TIMESTAMP '1970-01-01 00:00:01') AS BIGINT);\n"
        ]
    },
    {
        "sql_id": 127,
        "database_name": "BUTTERTrans_127",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(a) from t1; -- HEX",
        "target_query": "SELECT a FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a bit(64));\n",
            "insert into t1 values(b'1111111111111111111111111111111111111111111111111111111111111111'),(b'1000000000000000000000000000000000000000000000000000000000000000'),(b'0000000000000000000000000000000000000000000000000000000000000001'),(b'1010101010101010101010101010101010101010101010101010101010101010'),(b'0101010101010101010101010101010101010101010101010101010101010101');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'1111111111111111111111111111111111111111111111111111111111111111'), (X'1000000000000000000000000000000000000000000000000000000000000000'), (X'0000000000000000000000000000000000000000000000000000000000000001'), (X'1010101010101010101010101010101010101010101010101010101010101010'), (X'0101010101010101010101010101010101010101010101010101010101010101');\n"
        ]
    },
    {
        "sql_id": 128,
        "database_name": "BUTTERTrans_128",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(a) from t1; -- HEX",
        "target_query": "SELECT a FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a bit(64));\n",
            "insert into t1 values(b'1111111111111111111111111111111111111111111111111111111111111111'),(b'1000000000000000000000000000000000000000000000000000000000000000'),(b'0000000000000000000000000000000000000000000000000000000000000001'),(b'1010101010101010101010101010101010101010101010101010101010101010'),(b'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit);\n",
            "insert ignore into t1 values (b'0'), (b'1'), (b'000'), (b'100'), (b'001');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'1111111111111111111111111111111111111111111111111111111111111111'), (X'1000000000000000000000000000000000000000000000000000000000000000'), (X'0000000000000000000000000000000000000000000000000000000000000001'), (X'1010101010101010101010101010101010101010101010101010101010101010'), (X'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'00'), (X'01'), (X'0000'), (X'0100'), (X'0001');\n"
        ]
    },
    {
        "sql_id": 129,
        "database_name": "BUTTERTrans_129",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(min(a)) from t1; -- HEX, MIN",
        "target_query": "SELECT MIN(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a bit(64));\n",
            "insert into t1 values(b'1111111111111111111111111111111111111111111111111111111111111111'),(b'1000000000000000000000000000000000000000000000000000000000000000'),(b'0000000000000000000000000000000000000000000000000000000000000001'),(b'1010101010101010101010101010101010101010101010101010101010101010'),(b'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit);\n",
            "insert ignore into t1 values (b'0'), (b'1'), (b'000'), (b'100'), (b'001');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit(7), b bit(9));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'1111111111111111111111111111111111111111111111111111111111111111'), (X'1000000000000000000000000000000000000000000000000000000000000000'), (X'0000000000000000000000000000000000000000000000000000000000000001'), (X'1010101010101010101010101010101010101010101010101010101010101010'), (X'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'00'), (X'01'), (X'0000'), (X'0100'), (X'0001');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob, b blob);\n"
        ]
    },
    {
        "sql_id": 130,
        "database_name": "BUTTERTrans_130",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(min(b)) from t1; -- HEX, MIN",
        "target_query": "SELECT MIN(b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a bit(64));\n",
            "insert into t1 values(b'1111111111111111111111111111111111111111111111111111111111111111'),(b'1000000000000000000000000000000000000000000000000000000000000000'),(b'0000000000000000000000000000000000000000000000000000000000000001'),(b'1010101010101010101010101010101010101010101010101010101010101010'),(b'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit);\n",
            "insert ignore into t1 values (b'0'), (b'1'), (b'000'), (b'100'), (b'001');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit(7), b bit(9));\n",
            "select hex(min(a)) from t1; -- HEX, MIN\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'1111111111111111111111111111111111111111111111111111111111111111'), (X'1000000000000000000000000000000000000000000000000000000000000000'), (X'0000000000000000000000000000000000000000000000000000000000000001'), (X'1010101010101010101010101010101010101010101010101010101010101010'), (X'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'00'), (X'01'), (X'0000'), (X'0100'), (X'0001');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob, b blob);\n",
            "SELECT MIN(a) FROM t1;\n"
        ]
    },
    {
        "sql_id": 131,
        "database_name": "BUTTERTrans_131",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(min(a)), hex(max(a)), hex(min(b)), hex(max(b)) from t1; -- HEX, MIN, MAX",
        "target_query": "SELECT MIN(a), MAX(a), MIN(b), MAX(b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "HEX",
                "start_pos": 20,
                "end_pos": 23
            },
            {
                "dialect_token": "HEX",
                "start_pos": 33,
                "end_pos": 36
            },
            {
                "dialect_token": "HEX",
                "start_pos": 46,
                "end_pos": 49
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Returns the maximum value of the expression in an aggregation context.",
                "examples": [
                    "SELECT MAX(10), MAX(5), MAX(20);",
                    "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
                    "SELECT MAX(ABS(-5)), MAX(ABS(3));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Aggregates the maximum value of the input expression.",
                "examples": [
                    "SELECT MAX(2), MAX(4), MAX(8);",
                    "SELECT MAX('lion'), MAX('tiger'), MAX('bear');",
                    "SELECT MAX(sqrt(16)), MAX(sqrt(25));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a bit(64));\n",
            "insert into t1 values(b'1111111111111111111111111111111111111111111111111111111111111111'),(b'1000000000000000000000000000000000000000000000000000000000000000'),(b'0000000000000000000000000000000000000000000000000000000000000001'),(b'1010101010101010101010101010101010101010101010101010101010101010'),(b'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit);\n",
            "insert ignore into t1 values (b'0'), (b'1'), (b'000'), (b'100'), (b'001');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit(7), b bit(9));\n",
            "select hex(min(a)) from t1; -- HEX, MIN\n",
            "select hex(min(b)) from t1; -- HEX, MIN\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'1111111111111111111111111111111111111111111111111111111111111111'), (X'1000000000000000000000000000000000000000000000000000000000000000'), (X'0000000000000000000000000000000000000000000000000000000000000001'), (X'1010101010101010101010101010101010101010101010101010101010101010'), (X'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'00'), (X'01'), (X'0000'), (X'0100'), (X'0001');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob, b blob);\n",
            "SELECT MIN(a) FROM t1;\n",
            "SELECT MIN(b) FROM t1;\n"
        ]
    },
    {
        "sql_id": 132,
        "database_name": "BUTTERTrans_132",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(min(b)) from t1 where a = 4; -- HEX, MIN",
        "target_query": "SELECT MIN(b) FROM t1 WHERE a = 4;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "MIN()",
                "description": "The MIN() function returns the smallest value in a column or expression. It is used in both SELECT queries and in the HAVING clause for aggregated queries.",
                "examples": [
                    "SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0';",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(cn) = '0') AS dt;",
                    "SELECT * FROM (SELECT COUNT(*) AS c FROM test1.t1 HAVING MIN(ci) = '0') AS dt;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a bit(64));\n",
            "insert into t1 values(b'1111111111111111111111111111111111111111111111111111111111111111'),(b'1000000000000000000000000000000000000000000000000000000000000000'),(b'0000000000000000000000000000000000000000000000000000000000000001'),(b'1010101010101010101010101010101010101010101010101010101010101010'),(b'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit);\n",
            "insert ignore into t1 values (b'0'), (b'1'), (b'000'), (b'100'), (b'001');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit(7), b bit(9));\n",
            "select hex(min(a)) from t1; -- HEX, MIN\n",
            "select hex(min(b)) from t1; -- HEX, MIN\n",
            "select hex(min(a)), hex(max(a)), hex(min(b)), hex(max(b)) from t1; -- HEX, MIN, MAX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a int not null, b bit, c bit(9));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'1111111111111111111111111111111111111111111111111111111111111111'), (X'1000000000000000000000000000000000000000000000000000000000000000'), (X'0000000000000000000000000000000000000000000000000000000000000001'), (X'1010101010101010101010101010101010101010101010101010101010101010'), (X'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'00'), (X'01'), (X'0000'), (X'0100'), (X'0001');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob, b blob);\n",
            "SELECT MIN(a) FROM t1;\n",
            "SELECT MIN(b) FROM t1;\n",
            "SELECT MIN(a), MAX(a), MIN(b), MAX(b) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a INT NOT NULL, b blob, c blob);\n"
        ]
    },
    {
        "sql_id": 133,
        "database_name": "BUTTERTrans_133",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(max(b)) from t1; -- HEX",
        "target_query": "SELECT MAX(b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a bit(64));\n",
            "insert into t1 values(b'1111111111111111111111111111111111111111111111111111111111111111'),(b'1000000000000000000000000000000000000000000000000000000000000000'),(b'0000000000000000000000000000000000000000000000000000000000000001'),(b'1010101010101010101010101010101010101010101010101010101010101010'),(b'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit);\n",
            "insert ignore into t1 values (b'0'), (b'1'), (b'000'), (b'100'), (b'001');\n",
            "select hex(a) from t1; -- HEX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a bit(7), b bit(9));\n",
            "select hex(min(a)) from t1; -- HEX, MIN\n",
            "select hex(min(b)) from t1; -- HEX, MIN\n",
            "select hex(min(a)), hex(max(a)), hex(min(b)), hex(max(b)) from t1; -- HEX, MIN, MAX\n",
            "DROP TABLE t1;\n",
            "create table t1 (a int not null, b bit, c bit(9));\n",
            "select hex(min(b)) from t1 where a = 4; -- HEX, MIN\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'1111111111111111111111111111111111111111111111111111111111111111'), (X'1000000000000000000000000000000000000000000000000000000000000000'), (X'0000000000000000000000000000000000000000000000000000000000000001'), (X'1010101010101010101010101010101010101010101010101010101010101010'), (X'0101010101010101010101010101010101010101010101010101010101010101');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob);\n",
            "INSERT INTO t1 VALUES (X'00'), (X'01'), (X'0000'), (X'0100'), (X'0001');\n",
            "SELECT a FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a blob, b blob);\n",
            "SELECT MIN(a) FROM t1;\n",
            "SELECT MIN(b) FROM t1;\n",
            "SELECT MIN(a), MAX(a), MIN(b), MAX(b) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a INT NOT NULL, b blob, c blob);\n",
            "SELECT MIN(b) FROM t1 WHERE a = 4;\n"
        ]
    },
    {
        "sql_id": 134,
        "database_name": "BUTTERTrans_134",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX",
        "target_query": "SELECT b, i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = TRUE;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(0x01,100,''), (0x00,300,''), (0x01,200,''), (0x00,100,'');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(TRUE, 100, ''), (FALSE, 300, ''), (TRUE, 200, ''), (FALSE, 100, '');\n"
        ]
    },
    {
        "sql_id": 135,
        "database_name": "BUTTERTrans_135",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX",
        "target_query": "SELECT b1, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b1 = TRUE;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(0x01,100,''), (0x00,300,''), (0x01,200,''), (0x00,100,'');\n",
            "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (0x01,0x00,100,''), (0x00,0x01,300,''),(0x01,0x00,200,''), (0x00,0x01,100,'');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(TRUE, 100, ''), (FALSE, 300, ''), (TRUE, 200, ''), (FALSE, 100, '');\n",
            "SELECT b, i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = TRUE;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BOOLEAN NOT NULL, b2 BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (TRUE, FALSE, 100, ''), (FALSE, TRUE, 300, ''), (TRUE, FALSE, 200, ''), (FALSE, TRUE, 100, '');\n"
        ]
    },
    {
        "sql_id": 136,
        "database_name": "BUTTERTrans_136",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HEX(b2), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=FALSE; -- HEX",
        "target_query": "SELECT b2, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b2 = FALSE;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(0x01,100,''), (0x00,300,''), (0x01,200,''), (0x00,100,'');\n",
            "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (0x01,0x00,100,''), (0x00,0x01,300,''),(0x01,0x00,200,''), (0x00,0x01,100,'');\n",
            "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(TRUE, 100, ''), (FALSE, 300, ''), (TRUE, 200, ''), (FALSE, 100, '');\n",
            "SELECT b, i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = TRUE;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BOOLEAN NOT NULL, b2 BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (TRUE, FALSE, 100, ''), (FALSE, TRUE, 300, ''), (TRUE, FALSE, 200, ''), (FALSE, TRUE, 100, '');\n",
            "SELECT b1, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b1 = TRUE;\n"
        ]
    },
    {
        "sql_id": 137,
        "database_name": "BUTTERTrans_137",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT",
        "target_query": "SELECT group_concat(DISTINCT b) FROM t1 GROUP BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "GROUP_CONCAT",
                "start_pos": 11,
                "end_pos": 23
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "group_concat(X) group_concat(X,Y)",
                "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
                    "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(0x01,100,''), (0x00,300,''), (0x01,200,''), (0x00,100,'');\n",
            "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (0x01,0x00,100,''), (0x00,0x01,300,''),(0x01,0x00,200,''), (0x00,0x01,100,'');\n",
            "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX\n",
            "SELECT HEX(b2), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=FALSE; -- HEX\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a INT, b BIT(2));\n",
            "INSERT INTO t1 VALUES (3, 2), (2, 3), (2, 0), (3, 2), (3, 1);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(TRUE, 100, ''), (FALSE, 300, ''), (TRUE, 200, ''), (FALSE, 100, '');\n",
            "SELECT b, i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = TRUE;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BOOLEAN NOT NULL, b2 BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (TRUE, FALSE, 100, ''), (FALSE, TRUE, 300, ''), (TRUE, FALSE, 200, ''), (FALSE, TRUE, 100, '');\n",
            "SELECT b1, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b1 = TRUE;\n",
            "SELECT b2, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b2 = FALSE;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a INT, b SMALLINT);\n",
            "INSERT INTO t1 VALUES (3, 2), (2, 3), (2, 0), (3, 2), (3, 1);\n"
        ]
    },
    {
        "sql_id": 138,
        "database_name": "BUTTERTrans_138",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HEX(t2.b) FROM t2; -- HEX",
        "target_query": "SELECT t2.b FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(0x01,100,''), (0x00,300,''), (0x01,200,''), (0x00,100,'');\n",
            "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (0x01,0x00,100,''), (0x00,0x01,300,''),(0x01,0x00,200,''), (0x00,0x01,100,'');\n",
            "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX\n",
            "SELECT HEX(b2), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=FALSE; -- HEX\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a INT, b BIT(2));\n",
            "INSERT INTO t1 VALUES (3, 2), (2, 3), (2, 0), (3, 2), (3, 1);\n",
            "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT\n",
            "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(TRUE, 100, ''), (FALSE, 300, ''), (TRUE, 200, ''), (FALSE, 100, '');\n",
            "SELECT b, i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = TRUE;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BOOLEAN NOT NULL, b2 BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (TRUE, FALSE, 100, ''), (FALSE, TRUE, 300, ''), (TRUE, FALSE, 200, ''), (FALSE, TRUE, 100, '');\n",
            "SELECT b1, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b1 = TRUE;\n",
            "SELECT b2, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b2 = FALSE;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a INT, b SMALLINT);\n",
            "INSERT INTO t1 VALUES (3, 2), (2, 3), (2, 0), (3, 2), (3, 1);\n",
            "SELECT group_concat(DISTINCT b) FROM t1 GROUP BY a;\n",
            "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;\n"
        ]
    },
    {
        "sql_id": 139,
        "database_name": "BUTTERTrans_139",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT a, HEX(b) FROM t1 ORDER BY b; -- HEX",
        "target_query": "SELECT a, b FROM t1 ORDER BY b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 10,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BIT NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(0x01,100,''), (0x00,300,''), (0x01,200,''), (0x00,100,'');\n",
            "SELECT HEX(b), i2 FROM t1 WHERE (i2>=100 AND i2<201) AND b=TRUE; -- HEX\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BIT NOT NULL, b2 BIT NOT NULL, i2 INTEGER NOT NULL,s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (0x01,0x00,100,''), (0x00,0x01,300,''),(0x01,0x00,200,''), (0x00,0x01,100,'');\n",
            "SELECT HEX(b1), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b1=TRUE; -- HEX\n",
            "SELECT HEX(b2), i2 FROM t2 WHERE (i2>=100 AND i2<201) AND b2=FALSE; -- HEX\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a INT, b BIT(2));\n",
            "INSERT INTO t1 VALUES (3, 2), (2, 3), (2, 0), (3, 2), (3, 1);\n",
            "SELECT HEX(GROUP_CONCAT(DISTINCT b)) FROM t1 GROUP BY a; -- HEX, GROUP_CONCAT\n",
            "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;\n",
            "SELECT HEX(t2.b) FROM t2; -- HEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (b BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t1 VALUES(TRUE, 100, ''), (FALSE, 300, ''), (TRUE, 200, ''), (FALSE, 100, '');\n",
            "SELECT b, i2 FROM t1 WHERE (i2 >= 100 AND i2 < 201) AND b = TRUE;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (b1 BOOLEAN NOT NULL, b2 BOOLEAN NOT NULL, i2 INTEGER NOT NULL, s VARCHAR(255) NOT NULL);\n",
            "INSERT INTO t2 VALUES (TRUE, FALSE, 100, ''), (FALSE, TRUE, 300, ''), (TRUE, FALSE, 200, ''), (FALSE, TRUE, 100, '');\n",
            "SELECT b1, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b1 = TRUE;\n",
            "SELECT b2, i2 FROM t2 WHERE (i2 >= 100 AND i2 < 201) AND b2 = FALSE;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a INT, b SMALLINT);\n",
            "INSERT INTO t1 VALUES (3, 2), (2, 3), (2, 0), (3, 2), (3, 1);\n",
            "SELECT group_concat(DISTINCT b) FROM t1 GROUP BY a;\n",
            "CREATE TABLE t2 AS SELECT DISTINCT b FROM t1;\n",
            "SELECT t2.b FROM t2;\n"
        ]
    },
    {
        "sql_id": 140,
        "database_name": "BUTTERTrans_140",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(a) from t1 order by a; -- HEX",
        "target_query": "select a from t1 order by a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n"
        ]
    },
    {
        "sql_id": 141,
        "database_name": "BUTTERTrans_141",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT",
        "target_query": "select (a || '\\\\0') as b from t1 order by (a || '\\\\0');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 11,
                "end_pos": 17
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 50,
                "end_pos": 56
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select hex(a) from t1 order by a; -- HEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select a from t1 order by a;\n"
        ]
    },
    {
        "sql_id": 142,
        "database_name": "BUTTERTrans_142",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select hex(a) from t1 order by a; -- HEX",
        "target_query": "select a from t1 order by a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select hex(a) from t1 order by a; -- HEX\n",
            "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select a from t1 order by a;\n",
            "select (a || '\\\\0') as b from t1 order by (a || '\\\\0');\n"
        ]
    },
    {
        "sql_id": 143,
        "database_name": "BUTTERTrans_143",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535)); -- REPEAT",
        "target_query": "INSERT INTO t (c) VALUES (REPEAT('3',65535));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select hex(a) from t1 order by a; -- HEX\n",
            "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT\n",
            "select hex(a) from t1 order by a; -- HEX\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t (c TEXT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select a from t1 order by a;\n",
            "select (a || '\\\\0') as b from t1 order by (a || '\\\\0');\n",
            "select a from t1 order by a;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t (c TEXT);\n"
        ]
    },
    {
        "sql_id": 144,
        "database_name": "BUTTERTrans_144",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LENGTH(c), CHAR_LENGTH(c) FROM t; -- LENGTH, CHAR_LENGTH",
        "target_query": "SELECT octet_length(c), char_length(c) FROM t;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "CHAR_LENGTH",
                "start_pos": 18,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "char_length(expr)",
                "description": "Returns the number of characters in a string (char_length and length are equivalent).",
                "examples": [
                    "SELECT char_length('abc');",
                    "SELECT char_length('\u4f60\u597d');",
                    "SELECT char_length('a\u4f60b\u597dc');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select hex(a) from t1 order by a; -- HEX\n",
            "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT\n",
            "select hex(a) from t1 order by a; -- HEX\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t (c TEXT);\n",
            "INSERT INTO t (c) VALUES (REPEAT('3',65535)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select a from t1 order by a;\n",
            "select (a || '\\\\0') as b from t1 order by (a || '\\\\0');\n",
            "select a from t1 order by a;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t (c TEXT);\n",
            "INSERT INTO t (c) VALUES (REPEAT('3',65535));\n"
        ]
    },
    {
        "sql_id": 145,
        "database_name": "BUTTERTrans_145",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LENGTH(c) FROM t2; -- LENGTH",
        "target_query": "SELECT octet_length(c) FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select hex(a) from t1 order by a; -- HEX\n",
            "select hex(concat(a,'\\\\0')) as b from t1 order by concat(a,'\\\\0'); -- HEX, CONCAT\n",
            "select hex(a) from t1 order by a; -- HEX\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t (c TEXT);\n",
            "INSERT INTO t (c) VALUES (REPEAT('3',65535)); -- REPEAT\n",
            "SELECT LENGTH(c), CHAR_LENGTH(c) FROM t; -- LENGTH, CHAR_LENGTH\n",
            "DROP TABLE t;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(id INT NOT NULL, c TEXT NOT NULL);\n",
            "INSERT INTO t2 VALUES (1, '');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE table t1 (a blob);\n",
            "select a from t1 order by a;\n",
            "select (a || '\\\\0') as b from t1 order by (a || '\\\\0');\n",
            "select a from t1 order by a;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t (c TEXT);\n",
            "INSERT INTO t (c) VALUES (REPEAT('3',65535));\n",
            "SELECT octet_length(c), char_length(c) FROM t;\n",
            "DROP TABLE t;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(id INT NOT NULL, c TEXT NOT NULL);\n",
            "INSERT INTO t2 VALUES (1, '');\n"
        ]
    },
    {
        "sql_id": 146,
        "database_name": "BUTTERTrans_146",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select least(-1.1111111111111111111111111,- group_concat(1.7976931348623157E+308)) as foo; -- LEAST, GROUP_CONCAT",
        "target_query": "SELECT CASE WHEN -1.1111111111111111111111111 <= -GROUP_CONCAT(1.7976931348623157E+308) THEN -1.1111111111111111111111111 ELSE -GROUP_CONCAT(1.7976931348623157E+308) END AS foo;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            },
            {
                "dialect_token": "GROUP_CONCAT",
                "start_pos": 44,
                "end_pos": 56
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            },
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            },
            {
                "expression": "group_concat(X) group_concat(X,Y)",
                "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
                    "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 147,
        "database_name": "BUTTERTrans_147",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values (now()); -- NOW",
        "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 23,
                "end_pos": 26
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (value TEXT NOT NULL, id VARCHAR(32) NOT NULL, stamp timestamp NOT NULL);\n",
            "INSERT INTO t1 VALUES (\"my value\", \"myKey\",\"1999-04-02 00:00:00\");\n",
            "UPDATE t1 SET value=\"my value\" WHERE id=\"myKey\";\n",
            "UPDATE t1 SET id=\"myKey\" WHERE value=\"my value\";\n",
            "drop table t1;\n",
            "create table t1 (a timestamp NOT NULL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (value TEXT NOT NULL, id VARCHAR(32) NOT NULL, stamp timestamp NOT NULL);\n",
            "INSERT INTO t1 (value, id, stamp) VALUES ('my value', 'myKey', '1999-04-02 00:00:00');\n",
            "UPDATE t1 SET value='my value' WHERE id='myKey';\n",
            "UPDATE t1 SET id='myKey' WHERE value='my value';\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a timestamp NOT NULL);\n"
        ]
    },
    {
        "sql_id": 148,
        "database_name": "BUTTERTrans_148",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select date_format(a,\"%Y %y\"),year(a),year(now()) from t1; -- DATE_FORMAT, YEAR, NOW",
        "target_query": "SELECT sys.timestamp_to_str(a, 'YYYY YY'), EXTRACT(YEAR FROM a), EXTRACT(YEAR FROM CURRENT_TIMESTAMP) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            },
            {
                "dialect_token": "YEAR",
                "start_pos": 30,
                "end_pos": 34
            },
            {
                "dialect_token": "YEAR",
                "start_pos": 38,
                "end_pos": 42
            },
            {
                "dialect_token": "NOW",
                "start_pos": 43,
                "end_pos": 46
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "YEAR(date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT YEAR('2023-04-10');",
                    "SELECT YEAR(NOW());",
                    "SELECT YEAR('2022-03-15');"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            },
            {
                "expression": "EXTRACT(YEAR FROM date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
                    "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
                    "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (value TEXT NOT NULL, id VARCHAR(32) NOT NULL, stamp timestamp NOT NULL);\n",
            "INSERT INTO t1 VALUES (\"my value\", \"myKey\",\"1999-04-02 00:00:00\");\n",
            "UPDATE t1 SET value=\"my value\" WHERE id=\"myKey\";\n",
            "UPDATE t1 SET id=\"myKey\" WHERE value=\"my value\";\n",
            "drop table t1;\n",
            "create table t1 (a timestamp NOT NULL);\n",
            "insert into t1 values (now()); -- NOW\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (value TEXT NOT NULL, id VARCHAR(32) NOT NULL, stamp timestamp NOT NULL);\n",
            "INSERT INTO t1 (value, id, stamp) VALUES ('my value', 'myKey', '1999-04-02 00:00:00');\n",
            "UPDATE t1 SET value='my value' WHERE id='myKey';\n",
            "UPDATE t1 SET id='myKey' WHERE value='my value';\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a timestamp NOT NULL);\n",
            "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 149,
        "database_name": "BUTTERTrans_149",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIMESTAMP('2000-01-27','23:13:41') - TIMESTAMP('2003-05-16','23:53:29'); -- TIMESTAMP",
        "target_query": "SELECT CAST('2000-01-27 23:13:41' AS TIMESTAMP) - CAST('2003-05-16 23:53:29' AS TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMP",
                "start_pos": 7,
                "end_pos": 16
            },
            {
                "dialect_token": "TIMESTAMP",
                "start_pos": 44,
                "end_pos": 53
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
                "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
                "examples": [
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (value TEXT NOT NULL, id VARCHAR(32) NOT NULL, stamp timestamp NOT NULL);\n",
            "INSERT INTO t1 VALUES (\"my value\", \"myKey\",\"1999-04-02 00:00:00\");\n",
            "UPDATE t1 SET value=\"my value\" WHERE id=\"myKey\";\n",
            "UPDATE t1 SET id=\"myKey\" WHERE value=\"my value\";\n",
            "drop table t1;\n",
            "create table t1 (a timestamp NOT NULL);\n",
            "insert into t1 values (now()); -- NOW\n",
            "select date_format(a,\"%Y %y\"),year(a),year(now()) from t1; -- DATE_FORMAT, YEAR, NOW\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (value TEXT NOT NULL, id VARCHAR(32) NOT NULL, stamp timestamp NOT NULL);\n",
            "INSERT INTO t1 (value, id, stamp) VALUES ('my value', 'myKey', '1999-04-02 00:00:00');\n",
            "UPDATE t1 SET value='my value' WHERE id='myKey';\n",
            "UPDATE t1 SET id='myKey' WHERE value='my value';\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a timestamp NOT NULL);\n",
            "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);\n",
            "SELECT sys.timestamp_to_str(a, 'YYYY YY'), EXTRACT(YEAR FROM a), EXTRACT(YEAR FROM CURRENT_TIMESTAMP) FROM t1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 150,
        "database_name": "BUTTERTrans_150",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT IF (COUNT(*) > 0, \"YES\", \"NO\") AS \"IMPLICIT COMMIT\" FROM trans; -- IF",
        "target_query": "SELECT CASE WHEN COUNT(*) > 0 THEN 'YES' ELSE 'NO' END AS \"IMPLICIT COMMIT\" FROM trans; -- CASE WHEN",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 7,
                "end_pos": 9
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS trans;\n",
            "CREATE TABLE trans (a INT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS trans;\n",
            "CREATE TABLE trans (a INT);\n"
        ]
    },
    {
        "sql_id": 151,
        "database_name": "BUTTERTrans_151",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select length(v),length(c),length(e),length(t) from t1; -- LENGTH",
        "target_query": "select octet_length(v),octet_length(c),octet_length(e),octet_length(t) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "LENGTH",
                "start_pos": 17,
                "end_pos": 23
            },
            {
                "dialect_token": "LENGTH",
                "start_pos": 27,
                "end_pos": 33
            },
            {
                "dialect_token": "LENGTH",
                "start_pos": 37,
                "end_pos": 43
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (v varchar(30), c char(3), e char(3), t text);\n",
            "insert into t1 values ('abc', 'de', 'ghi', 'jkl');\n",
            "insert into t1 values ('abc ', 'de ', 'ghi', 'jkl ');\n",
            "insert into t1 values ('abc    ', 'd  ', 'ghi', 'jkl    ');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (v varchar(30), c char(3), e char(3), t text);\n",
            "insert into t1 values ('abc', 'de', 'ghi', 'jkl');\n",
            "insert into t1 values ('abc ', 'de ', 'ghi', 'jkl ');\n",
            "insert into t1 values ('abc    ', 'd  ', 'ghi', 'jkl    ');\n"
        ]
    },
    {
        "sql_id": 152,
        "database_name": "BUTTERTrans_152",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES(SUBSTR(f1, 1, 3)); -- SUBSTR",
        "target_query": "INSERT INTO t1 VALUES(substring('test' from 1 for 3));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "SUBSTR",
                "start_pos": 22,
                "end_pos": 28
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "substr(X,Y,Z)substr(X,Y)substring(X,Y,Z)substring(X,Y)",
                "description": "The substr(str,pos[,len]) function returns a substring from string str starting at position pos.\nIf len is specified, returns a substring len characters long starting at position pos.\nIf pos is positive, the position is counted from the start of the string.\nIf pos is negative, the position is counted from the end of the string.\nlen must be positive. If len is omitted, returns all characters to the end of the string.\nReturns NULL if any argument is NULL.",
                "examples": [
                    "SELECT substr('Hello World', 1, 5); -- Returns 'Hello'",
                    "SELECT substr('Hello World', -5, 3); -- Returns 'Wor'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "substring(X from Y for Z)",
                "description": "MonetDB supports the standard SQL SUBSTRING syntax to extract substrings. It returns a portion of the string X starting at position Y and continuing for Z characters.\nParameters:\n- X: the input string.\n- Y: the starting position (1-based index).\n- Z: optional number of characters to extract.\nReturns: A substring of X starting from the Y-th character, up to Z characters long.",
                "examples": [
                    "SELECT substring('Hello World' from 1 for 5); -- Returns 'Hello'",
                    "SELECT substring('Hello World' from 7 for 5); -- Returns 'World'",
                    "SELECT substring('Hello World' from char_length('Hello World') - 4 for 3); -- Simulates substr with negative index: Returns 'Wor'"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (v varchar(30), c char(3), e char(3), t text);\n",
            "insert into t1 values ('abc', 'de', 'ghi', 'jkl');\n",
            "insert into t1 values ('abc ', 'de ', 'ghi', 'jkl ');\n",
            "insert into t1 values ('abc    ', 'd  ', 'ghi', 'jkl    ');\n",
            "select length(v),length(c),length(e),length(t) from t1; -- LENGTH\n",
            "drop table t1;\n",
            "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (v varchar(30), c char(3), e char(3), t text);\n",
            "insert into t1 values ('abc', 'de', 'ghi', 'jkl');\n",
            "insert into t1 values ('abc ', 'de ', 'ghi', 'jkl ');\n",
            "insert into t1 values ('abc    ', 'd  ', 'ghi', 'jkl    ');\n",
            "select octet_length(v),octet_length(c),octet_length(e),octet_length(t) from t1;\n",
            "drop table t1;\n",
            "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');\n"
        ]
    },
    {
        "sql_id": 153,
        "database_name": "BUTTERTrans_153",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT a,(a DIV 2) FROM t1 ORDER BY a; -- DIV",
        "target_query": "SELECT a,(FLOOR(CAST(a AS DOUBLE) / 2)) FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DIV",
                "start_pos": 12,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "a DIV b",
                "description": "Performs integer division between two numbers and returns the floor of the quotient.",
                "examples": [
                    "SELECT 10 DIV 3;",
                    "SELECT 5.8 DIV 2;",
                    "SELECT 9 DIV 4 + 1;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "FLOOR(a / b)",
                "description": "Evaluates division and applies FLOOR to get integer result.",
                "examples": [
                    "SELECT FLOOR(10 / 3);",
                    "SELECT FLOOR(5.8 / 2);",
                    "SELECT FLOOR(9 / 4) + 1;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (v varchar(30), c char(3), e char(3), t text);\n",
            "insert into t1 values ('abc', 'de', 'ghi', 'jkl');\n",
            "insert into t1 values ('abc ', 'de ', 'ghi', 'jkl ');\n",
            "insert into t1 values ('abc    ', 'd  ', 'ghi', 'jkl    ');\n",
            "select length(v),length(c),length(e),length(t) from t1; -- LENGTH\n",
            "drop table t1;\n",
            "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');\n",
            "INSERT INTO t1 VALUES(SUBSTR(f1, 1, 3)); -- SUBSTR\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a CHAR(2));\n",
            "INSERT INTO t1 VALUES (10), (50), (30), ('1a'), (60), ('t');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (v varchar(30), c char(3), e char(3), t text);\n",
            "insert into t1 values ('abc', 'de', 'ghi', 'jkl');\n",
            "insert into t1 values ('abc ', 'de ', 'ghi', 'jkl ');\n",
            "insert into t1 values ('abc    ', 'd  ', 'ghi', 'jkl    ');\n",
            "select octet_length(v),octet_length(c),octet_length(e),octet_length(t) from t1;\n",
            "drop table t1;\n",
            "CREATE TABLE t1(f1 VARCHAR(100) DEFAULT 'test');\n",
            "INSERT INTO t1 VALUES(substring('test' from 1 for 3));\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a CHAR(2));\n",
            "INSERT INTO t1 VALUES (10), (50), (30),  (60);\n"
        ]
    },
    {
        "sql_id": 154,
        "database_name": "BUTTERTrans_154",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values (now()); -- NOW",
        "target_query": "insert into t1 values (CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 23,
                "end_pos": 26
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y year);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y date);\n"
        ]
    },
    {
        "sql_id": 155,
        "database_name": "BUTTERTrans_155",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select if(y = now(), 1, 0) from t1; -- IF, NOW",
        "target_query": "select CASE WHEN y = CURRENT_TIMESTAMP THEN 1 ELSE 0 END from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 7,
                "end_pos": 9
            },
            {
                "dialect_token": "NOW",
                "start_pos": 14,
                "end_pos": 17
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y year);\n",
            "insert into t1 values (now()); -- NOW\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y date);\n",
            "insert into t1 values (CURRENT_TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 156,
        "database_name": "BUTTERTrans_156",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t4 WHERE yyyy = NOW(); -- NOW",
        "target_query": "SELECT * FROM t4 WHERE yyyy = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 30,
                "end_pos": 33
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y year);\n",
            "insert into t1 values (now()); -- NOW\n",
            "select if(y = now(), 1, 0) from t1; -- IF, NOW\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t4;\n",
            "CREATE TABLE t4(yyyy YEAR, c4 CHAR(4));\n",
            "INSERT INTO t4 (c4) VALUES (NULL),(1970),(1999),(2000),(2001),(2069);\n",
            "UPDATE t4 SET yyyy = c4;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y date);\n",
            "insert into t1 values (CURRENT_TIMESTAMP);\n",
            "select CASE WHEN y = CURRENT_TIMESTAMP THEN 1 ELSE 0 END from t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t4;\n",
            "CREATE TABLE t4(yyyy int, c4 CHAR(4));\n",
            "INSERT INTO t4 (c4) VALUES (NULL),(1970),(1999),(2000),(2001),(2069);\n",
            "UPDATE t4 SET yyyy = c4;\n"
        ]
    },
    {
        "sql_id": 157,
        "database_name": "BUTTERTrans_157",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LEAST(d, y) FROM t1; -- LEAST",
        "target_query": "SELECT CASE WHEN d <= y THEN d ELSE y END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y year);\n",
            "insert into t1 values (now()); -- NOW\n",
            "select if(y = now(), 1, 0) from t1; -- IF, NOW\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t4;\n",
            "CREATE TABLE t4(yyyy YEAR, c4 CHAR(4));\n",
            "INSERT INTO t4 (c4) VALUES (NULL),(1970),(1999),(2000),(2001),(2069);\n",
            "UPDATE t4 SET yyyy = c4;\n",
            "SELECT * FROM t4 WHERE yyyy = NOW(); -- NOW\n",
            "DROP TABLE t4;\n",
            "CREATE TABLE t1(y YEAR,d DATE,i INTEGER,v VARCHAR(10));\n",
            "INSERT INTO t1 VALUES(1901, DATE'1901-01-01', 1, 'one');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y date);\n",
            "insert into t1 values (CURRENT_TIMESTAMP);\n",
            "select CASE WHEN y = CURRENT_TIMESTAMP THEN 1 ELSE 0 END from t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t4;\n",
            "CREATE TABLE t4(yyyy int, c4 CHAR(4));\n",
            "INSERT INTO t4 (c4) VALUES (NULL),(1970),(1999),(2000),(2001),(2069);\n",
            "UPDATE t4 SET yyyy = c4;\n",
            "SELECT * FROM t4 WHERE yyyy = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);\n",
            "DROP TABLE t4;\n",
            "CREATE TABLE t1(y date,d DATE,i INTEGER,v VARCHAR(10));\n",
            "INSERT INTO t1 VALUES(DATE'1901-01-01', DATE'1901-01-01', 1, 'one');\n"
        ]
    },
    {
        "sql_id": 158,
        "database_name": "BUTTERTrans_158",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LEAST(y, d) FROM t1; -- LEAST",
        "target_query": "SELECT CASE WHEN y <= d THEN y ELSE d END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y year);\n",
            "insert into t1 values (now()); -- NOW\n",
            "select if(y = now(), 1, 0) from t1; -- IF, NOW\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t4;\n",
            "CREATE TABLE t4(yyyy YEAR, c4 CHAR(4));\n",
            "INSERT INTO t4 (c4) VALUES (NULL),(1970),(1999),(2000),(2001),(2069);\n",
            "UPDATE t4 SET yyyy = c4;\n",
            "SELECT * FROM t4 WHERE yyyy = NOW(); -- NOW\n",
            "DROP TABLE t4;\n",
            "CREATE TABLE t1(y YEAR,d DATE,i INTEGER,v VARCHAR(10));\n",
            "INSERT INTO t1 VALUES(1901, DATE'1901-01-01', 1, 'one');\n",
            "SELECT LEAST(d, y) FROM t1; -- LEAST\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y date);\n",
            "insert into t1 values (CURRENT_TIMESTAMP);\n",
            "select CASE WHEN y = CURRENT_TIMESTAMP THEN 1 ELSE 0 END from t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t4;\n",
            "CREATE TABLE t4(yyyy int, c4 CHAR(4));\n",
            "INSERT INTO t4 (c4) VALUES (NULL),(1970),(1999),(2000),(2001),(2069);\n",
            "UPDATE t4 SET yyyy = c4;\n",
            "SELECT * FROM t4 WHERE yyyy = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);\n",
            "DROP TABLE t4;\n",
            "CREATE TABLE t1(y date,d DATE,i INTEGER,v VARCHAR(10));\n",
            "INSERT INTO t1 VALUES(DATE'1901-01-01', DATE'1901-01-01', 1, 'one');\n",
            "SELECT CASE WHEN d <= y THEN d ELSE y END FROM t1;\n"
        ]
    },
    {
        "sql_id": 159,
        "database_name": "BUTTERTrans_159",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIMESTAMPDIFF(QUARTER, LEAST(y1, y2), dbl)FROM t1; -- TIMESTAMPDIFF, LEAST",
        "target_query": "SELECT CAST(CASE WHEN y1 <= y2 THEN y1 ELSE y2 END AS INT) - CAST(dbl AS INT) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMPDIFF",
                "start_pos": 7,
                "end_pos": 20
            },
            {
                "dialect_token": "LEAST",
                "start_pos": 30,
                "end_pos": 35
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPDIFF(unit, datetime1, datetime2)",
                "description": "Returns the difference between two datetime values in the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPDIFF(YEAR, '2001-01-01', '2005-01-01');  -- 4",
                    "SELECT TIMESTAMPDIFF(MONTH, '2020-01-01', '2020-03-01');  -- 2",
                    "SELECT TIMESTAMPDIFF(DAY, '2020-01-01', '2020-01-31');    -- 30"
                ]
            },
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(end_date AS DATE) - CAST(start_date AS DATE)",
                "description": "MonetDB calculates the difference between two dates using UNIX timestamps (seconds since '1970-01-01 00:00:00'). The result is returned in seconds. For example, the difference between '2005-01-01' and '2001-01-01' in MonetDB is calculated in seconds, and this must be converted manually into days, months, or years by further calculations.",
                "examples": [
                    "SELECT CAST(DATE '2005-01-01' AS DATE) - CAST(DATE '2001-01-01' AS DATE);  -- 126230400 seconds"
                ]
            },
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y year);\n",
            "insert into t1 values (now()); -- NOW\n",
            "select if(y = now(), 1, 0) from t1; -- IF, NOW\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t4;\n",
            "CREATE TABLE t4(yyyy YEAR, c4 CHAR(4));\n",
            "INSERT INTO t4 (c4) VALUES (NULL),(1970),(1999),(2000),(2001),(2069);\n",
            "UPDATE t4 SET yyyy = c4;\n",
            "SELECT * FROM t4 WHERE yyyy = NOW(); -- NOW\n",
            "DROP TABLE t4;\n",
            "CREATE TABLE t1(y YEAR,d DATE,i INTEGER,v VARCHAR(10));\n",
            "INSERT INTO t1 VALUES(1901, DATE'1901-01-01', 1, 'one');\n",
            "SELECT LEAST(d, y) FROM t1; -- LEAST\n",
            "SELECT LEAST(y, d) FROM t1; -- LEAST\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (d DATE DEFAULT NULL,y1 YEAR DEFAULT NULL,y2 YEAR DEFAULT NULL,dbl DOUBLE DEFAULT NULL);\n",
            "INSERT INTO t1 VALUES('1978-07-14',1957,2085,87315.633);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (y date);\n",
            "insert into t1 values (CURRENT_TIMESTAMP);\n",
            "select CASE WHEN y = CURRENT_TIMESTAMP THEN 1 ELSE 0 END from t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE IF EXISTS t4;\n",
            "CREATE TABLE t4(yyyy int, c4 CHAR(4));\n",
            "INSERT INTO t4 (c4) VALUES (NULL),(1970),(1999),(2000),(2001),(2069);\n",
            "UPDATE t4 SET yyyy = c4;\n",
            "SELECT * FROM t4 WHERE yyyy = EXTRACT(YEAR FROM CURRENT_TIMESTAMP);\n",
            "DROP TABLE t4;\n",
            "CREATE TABLE t1(y date,d DATE,i INTEGER,v VARCHAR(10));\n",
            "INSERT INTO t1 VALUES(DATE'1901-01-01', DATE'1901-01-01', 1, 'one');\n",
            "SELECT CASE WHEN d <= y THEN d ELSE y END FROM t1;\n",
            "SELECT CASE WHEN y <= d THEN y ELSE d END FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (d DATE DEFAULT NULL,y1 int DEFAULT NULL,y2 int DEFAULT NULL,dbl DOUBLE DEFAULT NULL);\n",
            "INSERT INTO t1 VALUES('1978-07-14',1957,2085,87315.633);\n"
        ]
    },
    {
        "sql_id": 160,
        "database_name": "BUTTERTrans_160",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT y, CONCAT('\"', c, '\"') FROM t1; -- CONCAT",
        "target_query": "SELECT y, '\"' || c || '\"' FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 10,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (y YEAR NOT NULL DEFAULT 0,i INT NOT NULL DEFAULT 0,c VARCHAR(20) NOT NULL DEFAULT '');\n",
            "UPDATE t1 SET i = c;\n",
            "UPDATE t1 SET y = c;\n",
            "UPDATE t1 SET y = i;\n",
            "INSERT INTO t1 (y) VALUES (0), ('00'), ('0000');\n",
            "TRUNCATE t1;\n",
            "INSERT INTO t1 (i) VALUES (-1), (1800), (2156), (2147483647);\n",
            "UPDATE IGNORE t1 SET y = i;\n",
            "TRUNCATE t1;\n",
            "INSERT INTO t1 (c) VALUES (''), (' '), ('2012qwer'), ('qwer');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (y INT NOT NULL DEFAULT 0,i INT NOT NULL DEFAULT 0,c VARCHAR(20) NOT NULL DEFAULT '');\n",
            "UPDATE t1 SET i = c;\n",
            "UPDATE t1 SET y = c;\n",
            "UPDATE t1 SET y = i;\n",
            "INSERT INTO t1 (y) VALUES (0), ('00'), ('0000');\n",
            "TRUNCATE t1;\n",
            "INSERT INTO t1 (i) VALUES (-1), (1800), (2156), (2147483647);\n",
            "UPDATE t1 SET y = i;\n",
            "TRUNCATE t1;\n",
            "INSERT INTO t1 (c) VALUES (''), (' '), ('2012qwer'), ('qwer');\n"
        ]
    },
    {
        "sql_id": 161,
        "database_name": "BUTTERTrans_161",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(\"*\",name, \"*\") from t1 order by 1; -- CONCAT",
        "target_query": "SELECT '*' || name || '*' FROM t1 ORDER BY 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (name char(20) not null, primary key (name));\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2 (name char(20) not null, primary key (name));\n",
            "insert into t1 values (\"a\");\n",
            "insert into t1 values (\"b\");\n",
            "insert into t1 values (\"o\");\n",
            "insert into t2 select * from t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (name CHAR(20) NOT NULL, PRIMARY KEY (name));\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (name CHAR(20) NOT NULL, PRIMARY KEY (name));\n",
            "INSERT INTO t1 VALUES ('a');\n",
            "INSERT INTO t1 VALUES ('b');\n",
            "INSERT INTO t1 VALUES ('o');\n",
            "INSERT INTO t2 SELECT * FROM t1;\n"
        ]
    },
    {
        "sql_id": 162,
        "database_name": "BUTTERTrans_162",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select min(name),min(concat(\"*\",name,\"*\")),max(name),max(concat(\"*\",name,\"*\")) from t1; -- CONCAT",
        "target_query": "SELECT MIN(name), MIN('*' || name || '*'), MAX(name), MAX('*' || name || '*') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 21,
                "end_pos": 27
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 57,
                "end_pos": 63
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (name char(20) not null, primary key (name));\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2 (name char(20) not null, primary key (name));\n",
            "insert into t1 values (\"a\");\n",
            "insert into t1 values (\"b\");\n",
            "insert into t1 values (\"o\");\n",
            "insert into t2 select * from t1;\n",
            "select concat(\"*\",name, \"*\") from t1 order by 1; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (name CHAR(20) NOT NULL, PRIMARY KEY (name));\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (name CHAR(20) NOT NULL, PRIMARY KEY (name));\n",
            "INSERT INTO t1 VALUES ('a');\n",
            "INSERT INTO t1 VALUES ('b');\n",
            "INSERT INTO t1 VALUES ('o');\n",
            "INSERT INTO t2 SELECT * FROM t1;\n",
            "SELECT '*' || name || '*' FROM t1 ORDER BY 1;\n"
        ]
    },
    {
        "sql_id": 163,
        "database_name": "BUTTERTrans_163",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
        "target_query": "SELECT '-' || a || '-' || b || '-' FROM t1 WHERE a = 'hello';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (name char(20) not null, primary key (name));\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2 (name char(20) not null, primary key (name));\n",
            "insert into t1 values (\"a\");\n",
            "insert into t1 values (\"b\");\n",
            "insert into t1 values (\"o\");\n",
            "insert into t2 select * from t1;\n",
            "select concat(\"*\",name, \"*\") from t1 order by 1; -- CONCAT\n",
            "select min(name),min(concat(\"*\",name,\"*\")),max(name),max(concat(\"*\",name,\"*\")) from t1; -- CONCAT\n",
            "drop table t1;\n",
            "drop table t2;\n",
            "create table t1 (a char(10) not null, b char(10) not null);\n",
            "insert into t1 values (\"hello \",\"hello \"),(\"hello2 \",\"hello2 \");\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (name CHAR(20) NOT NULL, PRIMARY KEY (name));\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (name CHAR(20) NOT NULL, PRIMARY KEY (name));\n",
            "INSERT INTO t1 VALUES ('a');\n",
            "INSERT INTO t1 VALUES ('b');\n",
            "INSERT INTO t1 VALUES ('o');\n",
            "INSERT INTO t2 SELECT * FROM t1;\n",
            "SELECT '*' || name || '*' FROM t1 ORDER BY 1;\n",
            "SELECT MIN(name), MIN('*' || name || '*'), MAX(name), MAX('*' || name || '*') FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(10) NOT NULL, b CHAR(10) NOT NULL);\n",
            "INSERT INTO t1 VALUES ('hello ', 'hello '), ('hello2 ', 'hello2 ');\n"
        ]
    },
    {
        "sql_id": 164,
        "database_name": "BUTTERTrans_164",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT",
        "target_query": "SELECT '-' || a || '-' || b || '-' FROM t1 WHERE a = 'hello';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (name char(20) not null, primary key (name));\n",
            "DROP TABLE IF EXISTS t2;\n",
            "create table t2 (name char(20) not null, primary key (name));\n",
            "insert into t1 values (\"a\");\n",
            "insert into t1 values (\"b\");\n",
            "insert into t1 values (\"o\");\n",
            "insert into t2 select * from t1;\n",
            "select concat(\"*\",name, \"*\") from t1 order by 1; -- CONCAT\n",
            "select min(name),min(concat(\"*\",name,\"*\")),max(name),max(concat(\"*\",name,\"*\")) from t1; -- CONCAT\n",
            "drop table t1;\n",
            "drop table t2;\n",
            "create table t1 (a char(10) not null, b char(10) not null);\n",
            "insert into t1 values (\"hello \",\"hello \"),(\"hello2 \",\"hello2 \");\n",
            "select concat(\"-\",a,\"-\",b,\"-\") from t1 where a=\"hello\"; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (name CHAR(20) NOT NULL, PRIMARY KEY (name));\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (name CHAR(20) NOT NULL, PRIMARY KEY (name));\n",
            "INSERT INTO t1 VALUES ('a');\n",
            "INSERT INTO t1 VALUES ('b');\n",
            "INSERT INTO t1 VALUES ('o');\n",
            "INSERT INTO t2 SELECT * FROM t1;\n",
            "SELECT '*' || name || '*' FROM t1 ORDER BY 1;\n",
            "SELECT MIN(name), MIN('*' || name || '*'), MAX(name), MAX('*' || name || '*') FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(10) NOT NULL, b CHAR(10) NOT NULL);\n",
            "INSERT INTO t1 VALUES ('hello ', 'hello '), ('hello2 ', 'hello2 ');\n",
            "SELECT '-' || a || '-' || b || '-' FROM t1 WHERE a = 'hello';\n"
        ]
    },
    {
        "sql_id": 165,
        "database_name": "BUTTERTrans_165",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX",
        "target_query": "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029087575');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a binary(20) NOT NULL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob NOT NULL);\n"
        ]
    },
    {
        "sql_id": 166,
        "database_name": "BUTTERTrans_166",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX",
        "target_query": "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029082020');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a binary(20) NOT NULL);\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob NOT NULL);\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029087575');\n"
        ]
    },
    {
        "sql_id": 167,
        "database_name": "BUTTERTrans_167",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX",
        "target_query": "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029080707');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a binary(20) NOT NULL);\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob NOT NULL);\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029087575');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029082020');\n"
        ]
    },
    {
        "sql_id": 168,
        "database_name": "BUTTERTrans_168",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT hex(a) FROM t1 order by a; -- HEX",
        "target_query": "SELECT a FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a binary(20) NOT NULL);\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob NOT NULL);\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029087575');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029082020');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029080707');\n"
        ]
    },
    {
        "sql_id": 169,
        "database_name": "BUTTERTrans_169",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT hex(a) FROM t1 order by a; -- HEX",
        "target_query": "EXPLAIN SELECT a FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 15,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a binary(20) NOT NULL);\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX\n",
            "SELECT hex(a) FROM t1 order by a; -- HEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob NOT NULL);\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029087575');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029082020');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029080707');\n",
            "SELECT a FROM t1 ORDER BY a;\n"
        ]
    },
    {
        "sql_id": 170,
        "database_name": "BUTTERTrans_170",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- HEX, UNHEX",
        "target_query": "SELECT a FROM t1 WHERE a=CAST('1F9480179366F2BF567E1C4B964C1EF029082020' AS BLOB);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "UNHEX",
                "start_pos": 30,
                "end_pos": 35
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a binary(20) NOT NULL);\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX\n",
            "SELECT hex(a) FROM t1 order by a; -- HEX\n",
            "EXPLAIN SELECT hex(a) FROM t1 order by a; -- HEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob NOT NULL);\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029087575');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029082020');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029080707');\n",
            "SELECT a FROM t1 ORDER BY a;\n",
            "EXPLAIN SELECT a FROM t1 ORDER BY a;\n"
        ]
    },
    {
        "sql_id": 171,
        "database_name": "BUTTERTrans_171",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF02908'); -- HEX, UNHEX",
        "target_query": "SELECT a FROM t1 WHERE a=CAST('1F9480179366F2BF567E1C4B964C1EF02908' AS BLOB);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "UNHEX",
                "start_pos": 30,
                "end_pos": 35
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a binary(20) NOT NULL);\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029087575'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- UNHEX\n",
            "INSERT INTO t1 SET a=unhex('1F9480179366F2BF567E1C4B964C1EF029080707'); -- UNHEX\n",
            "SELECT hex(a) FROM t1 order by a; -- HEX\n",
            "EXPLAIN SELECT hex(a) FROM t1 order by a; -- HEX\n",
            "SELECT hex(a) from t1 WHERE a=unhex('1F9480179366F2BF567E1C4B964C1EF029082020'); -- HEX, UNHEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a blob NOT NULL);\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029087575');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029082020');\n",
            "INSERT INTO t1 (a) VALUES (X'1F9480179366F2BF567E1C4B964C1EF029080707');\n",
            "SELECT a FROM t1 ORDER BY a;\n",
            "EXPLAIN SELECT a FROM t1 ORDER BY a;\n",
            "SELECT a FROM t1 WHERE a=CAST('1F9480179366F2BF567E1C4B964C1EF029082020' AS BLOB);\n"
        ]
    },
    {
        "sql_id": 172,
        "database_name": "BUTTERTrans_172",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF",
        "target_query": "SELECT CASE WHEN NULL AND 1 THEN 1 ELSE 2 END, CASE WHEN 1 AND NULL THEN 1 ELSE 2 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 7,
                "end_pos": 9
            },
            {
                "dialect_token": "IF",
                "start_pos": 29,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 173,
        "database_name": "BUTTERTrans_173",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1); -- IF",
        "target_query": "SELECT * FROM t1 WHERE CASE WHEN a AND 1 THEN 0 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 23,
                "end_pos": 25
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a int);\n",
            "insert into t1 values (0),(1),(NULL);\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN NULL AND 1 THEN 1 ELSE 2 END, CASE WHEN 1 AND NULL THEN 1 ELSE 2 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INT);\n",
            "INSERT INTO t1 VALUES (0), (1), (NULL);\n"
        ]
    },
    {
        "sql_id": 174,
        "database_name": "BUTTERTrans_174",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t1 WHERE IF(1 AND a, 0, 1); -- IF",
        "target_query": "SELECT * FROM t1 WHERE CASE WHEN 1 AND a THEN 0 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 23,
                "end_pos": 25
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a int);\n",
            "insert into t1 values (0),(1),(NULL);\n",
            "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1); -- IF\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN NULL AND 1 THEN 1 ELSE 2 END, CASE WHEN 1 AND NULL THEN 1 ELSE 2 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INT);\n",
            "INSERT INTO t1 VALUES (0), (1), (NULL);\n",
            "SELECT * FROM t1 WHERE CASE WHEN a AND 1 THEN 0 ELSE 1 END;\n"
        ]
    },
    {
        "sql_id": 175,
        "database_name": "BUTTERTrans_175",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select ifnull(A, 'N') as A, ifnull(B, 'N') as B, ifnull(not A, 'N') as nA, ifnull(not B, 'N') as nB, ifnull(A and B, 'N') as AB, ifnull(not (A and B), 'N') as `n(AB)`, ifnull((not A or not B), 'N') as nAonB, ifnull(A or B, 'N') as AoB, ifnull(not(A or B), 'N') as `n(AoB)`, ifnull(not A and not B, 'N') as nAnB from t1; -- IFNULL",
        "target_query": "SELECT COALESCE(A, 'N') AS A, COALESCE(B, 'N') AS B, COALESCE(NOT A, 'N') AS nA, COALESCE(NOT B, 'N') AS nB, COALESCE(A AND B, 'N') AS AB, COALESCE(NOT (A AND B), 'N') AS nAB, COALESCE((NOT A OR NOT B), 'N') AS nAonB, COALESCE(A OR B, 'N') AS AoB, COALESCE(NOT(A OR B), 'N') AS nAoB, COALESCE(NOT A AND NOT B, 'N') AS nAnB FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 28,
                "end_pos": 34
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 49,
                "end_pos": 55
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 75,
                "end_pos": 81
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 101,
                "end_pos": 107
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 129,
                "end_pos": 135
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 168,
                "end_pos": 174
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 208,
                "end_pos": 214
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 236,
                "end_pos": 242
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 274,
                "end_pos": 280
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a int);\n",
            "insert into t1 values (0),(1),(NULL);\n",
            "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1); -- IF\n",
            "SELECT * FROM t1 WHERE IF(1 AND a, 0, 1); -- IF\n",
            "DROP TABLE t1;\n",
            "create table t1 (a int, b int);\n",
            "insert into t1 values(null, null), (0, null), (1, null), (null, 0), (null, 1), (0, 0), (0, 1), (1, 0), (1, 1);\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN NULL AND 1 THEN 1 ELSE 2 END, CASE WHEN 1 AND NULL THEN 1 ELSE 2 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INT);\n",
            "INSERT INTO t1 VALUES (0), (1), (NULL);\n",
            "SELECT * FROM t1 WHERE CASE WHEN a AND 1 THEN 0 ELSE 1 END;\n",
            "SELECT * FROM t1 WHERE CASE WHEN 1 AND a THEN 0 ELSE 1 END;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a INT, b INT);\n",
            "INSERT INTO t1 VALUES (NULL, NULL), (0, NULL), (1, NULL), (NULL, 0), (NULL, 1), (0, 0), (0, 1), (1, 0), (1, 1);\n"
        ]
    },
    {
        "sql_id": 176,
        "database_name": "BUTTERTrans_176",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select ifnull(A=1, 'N') as A, ifnull(B=1, 'N') as B, ifnull(not (A=1), 'N') as nA, ifnull(not (B=1), 'N') as nB, ifnull((A=1) and (B=1), 'N') as AB, ifnull(not ((A=1) and (B=1)), 'N') as `n(AB)`, ifnull((not (A=1) or not (B=1)), 'N') as nAonB, ifnull((A=1) or (B=1), 'N') as AoB, ifnull(not((A=1) or (B=1)), 'N') as `n(AoB)`, ifnull(not (A=1) and not (B=1), 'N') as nAnB from t1; -- IFNULL",
        "target_query": "SELECT COALESCE(A=1, 'N') AS A, COALESCE(B=1, 'N') AS B, COALESCE(NOT (A=1), 'N') AS nA, COALESCE(NOT (B=1), 'N') AS nB, COALESCE((A=1) AND (B=1), 'N') AS AB, COALESCE(NOT ((A=1) AND (B=1)), 'N') AS nAB, COALESCE((NOT (A=1) OR NOT (B=1)), 'N') AS nAonB, COALESCE((A=1) OR (B=1), 'N') AS AoB, COALESCE(NOT((A=1) OR (B=1)), 'N') AS nAoB, COALESCE(NOT (A=1) AND NOT (B=1), 'N') AS nAnB FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 30,
                "end_pos": 36
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 53,
                "end_pos": 59
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 83,
                "end_pos": 89
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 113,
                "end_pos": 119
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 149,
                "end_pos": 155
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 196,
                "end_pos": 202
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 244,
                "end_pos": 250
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 280,
                "end_pos": 286
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 326,
                "end_pos": 332
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(NULL AND 1, 1, 2), IF(1 AND NULL, 1, 2); -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a int);\n",
            "insert into t1 values (0),(1),(NULL);\n",
            "SELECT * FROM t1 WHERE IF(a AND 1, 0, 1); -- IF\n",
            "SELECT * FROM t1 WHERE IF(1 AND a, 0, 1); -- IF\n",
            "DROP TABLE t1;\n",
            "create table t1 (a int, b int);\n",
            "insert into t1 values(null, null), (0, null), (1, null), (null, 0), (null, 1), (0, 0), (0, 1), (1, 0), (1, 1);\n",
            "select ifnull(A, 'N') as A, ifnull(B, 'N') as B, ifnull(not A, 'N') as nA, ifnull(not B, 'N') as nB, ifnull(A and B, 'N') as AB, ifnull(not (A and B), 'N') as `n(AB)`, ifnull((not A or not B), 'N') as nAonB, ifnull(A or B, 'N') as AoB, ifnull(not(A or B), 'N') as `n(AoB)`, ifnull(not A and not B, 'N') as nAnB from t1; -- IFNULL\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN NULL AND 1 THEN 1 ELSE 2 END, CASE WHEN 1 AND NULL THEN 1 ELSE 2 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INT);\n",
            "INSERT INTO t1 VALUES (0), (1), (NULL);\n",
            "SELECT * FROM t1 WHERE CASE WHEN a AND 1 THEN 0 ELSE 1 END;\n",
            "SELECT * FROM t1 WHERE CASE WHEN 1 AND a THEN 0 ELSE 1 END;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a INT, b INT);\n",
            "INSERT INTO t1 VALUES (NULL, NULL), (0, NULL), (1, NULL), (NULL, 0), (NULL, 1), (0, 0), (0, 1), (1, 0), (1, 1);\n",
            "SELECT COALESCE(A, 'N') AS A, COALESCE(B, 'N') AS B, COALESCE(NOT A, 'N') AS nA, COALESCE(NOT B, 'N') AS nB, COALESCE(A AND B, 'N') AS AB, COALESCE(NOT (A AND B), 'N') AS nAB, COALESCE((NOT A OR NOT B), 'N') AS nAonB, COALESCE(A OR B, 'N') AS AoB, COALESCE(NOT(A OR B), 'N') AS nAoB, COALESCE(NOT A AND NOT B, 'N') AS nAnB FROM t1;\n"
        ]
    },
    {
        "sql_id": 177,
        "database_name": "BUTTERTrans_177",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT",
        "target_query": "SELECT CAST('2004-01-22 21:45:33' AS DATE);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONVERT",
                "start_pos": 7,
                "end_pos": 14
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONVERT(expression USING charset)",
                "description": "Converts data types or changes the character set.",
                "examples": [
                    "SELECT CONVERT('Hello World' USING utf8);",
                    "SELECT CONVERT(1234, CHAR);",
                    "SELECT CONVERT(column_name USING latin1) FROM my_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(expression AS target_type)",
                "description": "MonetDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
                "examples": [
                    "SELECT CAST('Hello World' AS TEXT);",
                    "SELECT CAST(1234 AS VARCHAR);",
                    "SELECT CAST(column_name AS TEXT) FROM my_table;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 178,
        "database_name": "BUTTERTrans_178",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n"
        ]
    },
    {
        "sql_id": 179,
        "database_name": "BUTTERTrans_179",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n"
        ]
    },
    {
        "sql_id": 180,
        "database_name": "BUTTERTrans_180",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select cast(concat('12345','6789') as unsigned); -- CONCAT",
        "target_query": "SELECT CAST('12345' || '6789' AS INTEGER);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 12,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n"
        ]
    },
    {
        "sql_id": 181,
        "database_name": "BUTTERTrans_181",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select cast(concat('12345','6789') as signed); -- CONCAT",
        "target_query": "SELECT CAST('12345' || '6789' AS INTEGER);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 12,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n"
        ]
    },
    {
        "sql_id": 182,
        "database_name": "BUTTERTrans_182",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select cast(repeat('1',9) as unsigned); -- REPEAT",
        "target_query": "SELECT CAST(REPEAT('1', 9) AS INTEGER);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 12,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n"
        ]
    },
    {
        "sql_id": 183,
        "database_name": "BUTTERTrans_183",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select cast(repeat('1',9) as signed); -- REPEAT",
        "target_query": "SELECT CAST(REPEAT('1', 9) AS INTEGER);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 12,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n"
        ]
    },
    {
        "sql_id": 184,
        "database_name": "BUTTERTrans_184",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE",
        "target_query": "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "ISNULL",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "DATE",
                "start_pos": 14,
                "end_pos": 18
            },
            {
                "dialect_token": "ISNULL",
                "start_pos": 27,
                "end_pos": 33
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            },
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL construct for detecting NULL values.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 * NULL) IS NULL;",
                    "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
                ]
            },
            {
                "expression": "CAST()",
                "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
                "examples": [
                    "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
                    "SELECT CAST(NOW() AS DATE) AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n"
        ]
    },
    {
        "sql_id": 185,
        "database_name": "BUTTERTrans_185",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT cast(date(d1) as signed) FROM t1; -- DATE",
        "target_query": "SELECT CAST(d1 AS TIMESTAMP) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE",
                "start_pos": 12,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
                "examples": [
                    "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
                    "SELECT CAST(NOW() AS DATE) AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n",
            "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 datetime);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL),('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 TIMESTAMP);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL), ('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n"
        ]
    },
    {
        "sql_id": 186,
        "database_name": "BUTTERTrans_186",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HOUR",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "MINUTE",
                "start_pos": 16,
                "end_pos": 22
            },
            {
                "dialect_token": "SECOND",
                "start_pos": 27,
                "end_pos": 33
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Returns the hour component of a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "\"minute\"()",
                "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
                "examples": [
                    "SELECT \"minute\"(time '12:34:56');",
                    "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
                    "SELECT \"minute\"(NULL);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n",
            "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 datetime);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL),('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT cast(date(d1) as signed) FROM t1; -- DATE\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 TIMESTAMP);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL), ('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT CAST(d1 AS TIMESTAMP) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n"
        ]
    },
    {
        "sql_id": 187,
        "database_name": "BUTTERTrans_187",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS DATE)), \"minute\"(CAST('2007-07-19' AS DATE)), EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HOUR",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "MINUTE",
                "start_pos": 40,
                "end_pos": 46
            },
            {
                "dialect_token": "SECOND",
                "start_pos": 75,
                "end_pos": 81
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Returns the hour component of a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "\"minute\"()",
                "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
                "examples": [
                    "SELECT \"minute\"(time '12:34:56');",
                    "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
                    "SELECT \"minute\"(NULL);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n",
            "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 datetime);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL),('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT cast(date(d1) as signed) FROM t1; -- DATE\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 TIMESTAMP);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL), ('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT CAST(d1 AS TIMESTAMP) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 188,
        "database_name": "BUTTERTrans_188",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM CAST(NULL AS DATE)), \"minute\"(CAST(NULL AS DATE)), EXTRACT(SECOND FROM CAST(NULL AS DATE));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HOUR",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "MINUTE",
                "start_pos": 32,
                "end_pos": 38
            },
            {
                "dialect_token": "SECOND",
                "start_pos": 59,
                "end_pos": 65
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Returns the hour component of a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "\"minute\"()",
                "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
                "examples": [
                    "SELECT \"minute\"(time '12:34:56');",
                    "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
                    "SELECT \"minute\"(NULL);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n",
            "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 datetime);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL),('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT cast(date(d1) as signed) FROM t1; -- DATE\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND\n",
            "drop table t1;\n",
            "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 TIMESTAMP);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL), ('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT CAST(d1 AS TIMESTAMP) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS DATE)), \"minute\"(CAST('2007-07-19' AS DATE)), EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));\n"
        ]
    },
    {
        "sql_id": 189,
        "database_name": "BUTTERTrans_189",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT HOUR(NULL),MINUTE(NULL),SECOND(NULL); -- HOUR, MINUTE, SECOND",
        "target_query": "SELECT EXTRACT(HOUR FROM NULL), \"minute\"(NULL), EXTRACT(SECOND FROM NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HOUR",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "MINUTE",
                "start_pos": 18,
                "end_pos": 24
            },
            {
                "dialect_token": "SECOND",
                "start_pos": 31,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HOUR(expr)",
                "description": "Extracts the hour (0\u201323) from a time or datetime expression.",
                "examples": [
                    "SELECT HOUR('18:45:30');",
                    "SELECT HOUR('2023-10-01 08:15:00');",
                    "SELECT HOUR(CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "MINUTE()",
                "description": "Extracts the minute part from a time or datetime value.",
                "examples": [
                    "SELECT MINUTE('12:34:56');",
                    "SELECT MINUTE('2025-01-01 10:30:00');",
                    "SELECT MINUTE(NULL);"
                ]
            },
            {
                "expression": "SECOND(time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT SECOND('10:11:12');",
                    "SELECT SECOND(4.99999999991e0);",
                    "SELECT SECOND(CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(HOUR FROM expr)",
                "description": "Returns the hour component of a time or timestamp expression.",
                "examples": [
                    "SELECT EXTRACT(HOUR FROM TIME '18:45:30');",
                    "SELECT EXTRACT(HOUR FROM TIMESTAMP '2023-10-01 08:15:00');",
                    "SELECT EXTRACT(HOUR FROM CURRENT_TIMESTAMP);"
                ]
            },
            {
                "expression": "\"minute\"()",
                "description": "Extracts the minute part from a time or timestamp value. In MonetDB, the function is used with the input explicitly cast to either `time` or `timestamp`.",
                "examples": [
                    "SELECT \"minute\"(time '12:34:56');",
                    "SELECT \"minute\"(timestamp '2025-01-01 10:30:00');",
                    "SELECT \"minute\"(NULL);"
                ]
            },
            {
                "expression": "EXTRACT(SECOND FROM time)",
                "description": "Extracts the second part from a TIME, DATETIME, or TIMESTAMP value.",
                "examples": [
                    "SELECT EXTRACT(SECOND FROM TIME '10:11:12');",
                    "SELECT EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n",
            "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 datetime);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL),('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT cast(date(d1) as signed) FROM t1; -- DATE\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND\n",
            "drop table t1;\n",
            "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND\n",
            "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 TIMESTAMP);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL), ('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT CAST(d1 AS TIMESTAMP) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS DATE)), \"minute\"(CAST('2007-07-19' AS DATE)), EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));\n",
            "SELECT EXTRACT(HOUR FROM CAST(NULL AS DATE)), \"minute\"(CAST(NULL AS DATE)), EXTRACT(SECOND FROM CAST(NULL AS DATE));\n"
        ]
    },
    {
        "sql_id": 190,
        "database_name": "BUTTERTrans_190",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CONVERT('a', CHAR(2049)); -- CONVERT",
        "target_query": "SELECT CAST('a' AS VARCHAR(2049));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONVERT",
                "start_pos": 7,
                "end_pos": 14
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONVERT(expression USING charset)",
                "description": "Converts data types or changes the character set.",
                "examples": [
                    "SELECT CONVERT('Hello World' USING utf8);",
                    "SELECT CONVERT(1234, CHAR);",
                    "SELECT CONVERT(column_name USING latin1) FROM my_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(expression AS target_type)",
                "description": "MonetDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
                "examples": [
                    "SELECT CAST('Hello World' AS TEXT);",
                    "SELECT CAST(1234 AS VARCHAR);",
                    "SELECT CAST(column_name AS TEXT) FROM my_table;"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n",
            "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 datetime);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL),('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT cast(date(d1) as signed) FROM t1; -- DATE\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND\n",
            "drop table t1;\n",
            "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND\n",
            "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND\n",
            "SELECT HOUR(NULL),MINUTE(NULL),SECOND(NULL); -- HOUR, MINUTE, SECOND\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 TIMESTAMP);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL), ('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT CAST(d1 AS TIMESTAMP) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS DATE)), \"minute\"(CAST('2007-07-19' AS DATE)), EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));\n",
            "SELECT EXTRACT(HOUR FROM CAST(NULL AS DATE)), \"minute\"(CAST(NULL AS DATE)), EXTRACT(SECOND FROM CAST(NULL AS DATE));\n",
            "SELECT EXTRACT(HOUR FROM NULL), \"minute\"(NULL), EXTRACT(SECOND FROM NULL);\n"
        ]
    },
    {
        "sql_id": 191,
        "database_name": "BUTTERTrans_191",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CONCAT(\"value=\", CAST(\"3.4e5\" AS FLOAT)); -- CONCAT",
        "target_query": "SELECT 'value=' || CAST('3.4e5' AS FLOAT);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n",
            "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 datetime);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL),('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT cast(date(d1) as signed) FROM t1; -- DATE\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND\n",
            "drop table t1;\n",
            "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND\n",
            "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND\n",
            "SELECT HOUR(NULL),MINUTE(NULL),SECOND(NULL); -- HOUR, MINUTE, SECOND\n",
            "SELECT CONVERT('a', CHAR(2049)); -- CONVERT\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 TIMESTAMP);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL), ('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT CAST(d1 AS TIMESTAMP) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS DATE)), \"minute\"(CAST('2007-07-19' AS DATE)), EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));\n",
            "SELECT EXTRACT(HOUR FROM CAST(NULL AS DATE)), \"minute\"(CAST(NULL AS DATE)), EXTRACT(SECOND FROM CAST(NULL AS DATE));\n",
            "SELECT EXTRACT(HOUR FROM NULL), \"minute\"(NULL), EXTRACT(SECOND FROM NULL);\n",
            "SELECT CAST('a' AS VARCHAR(2049));\n"
        ]
    },
    {
        "sql_id": 192,
        "database_name": "BUTTERTrans_192",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT MAKETIME(1, 2, CAST(\"1.6\" AS FLOAT)); -- MAKETIME",
        "target_query": "SELECT TIME '01:02:01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKETIME",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIME 'HH:MI:SS'",
                "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
                "examples": [
                    "SELECT TIME '01:30:45';",
                    "SELECT TIME '12:00:00';",
                    "SELECT TIME '23:59:59';"
                ]
            }
        ],
        "source_related_schemas": [
            "select CONVERT(\"2004-01-22 21:45:33\",DATE); -- CONVERT\n",
            "select timediff(cast('2004-12-30 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select timediff(cast('1 12:00:00' as time), '12:00:00'); -- TIMEDIFF\n",
            "select cast(concat('12345','6789') as unsigned); -- CONCAT\n",
            "select cast(concat('12345','6789') as signed); -- CONCAT\n",
            "select cast(repeat('1',9) as unsigned); -- REPEAT\n",
            "select cast(repeat('1',9) as signed); -- REPEAT\n",
            "select isnull(date(NULL)), isnull(cast(NULL as DATE)); -- ISNULL, DATE\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 datetime);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL),('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT cast(date(d1) as signed) FROM t1; -- DATE\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT HOUR(f1),MINUTE(f1),SECOND(f1) FROM t1; -- HOUR, MINUTE, SECOND\n",
            "drop table t1;\n",
            "SELECT HOUR(CAST('2007-07-19' AS DATE)),MINUTE(CAST('2007-07-19' AS DATE)),SECOND(CAST('2007-07-19' AS DATE)); -- HOUR, MINUTE, SECOND\n",
            "SELECT HOUR(CAST(NULL AS DATE)),MINUTE(CAST(NULL AS DATE)),SECOND(CAST(NULL AS DATE)); -- HOUR, MINUTE, SECOND\n",
            "SELECT HOUR(NULL),MINUTE(NULL),SECOND(NULL); -- HOUR, MINUTE, SECOND\n",
            "SELECT CONVERT('a', CHAR(2049)); -- CONVERT\n",
            "SELECT CONCAT(\"value=\", CAST(\"3.4e5\" AS FLOAT)); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "SELECT CAST('2004-01-22 21:45:33' AS DATE);\n",
            "SELECT EXTRACT(EPOCH FROM CAST('2004-12-30 12:00:00' AS TIMESTAMP) - TIMESTAMP '2004-12-30 12:00:00');\n",
            "SELECT EXTRACT(EPOCH FROM CAST('12:00:00' AS TIME) - TIME '12:00:00');\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST('12345' || '6789' AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT CAST(REPEAT('1', 9) AS INTEGER);\n",
            "SELECT NULL IS NULL, CAST(NULL AS DATE) IS NULL;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d1 TIMESTAMP);\n",
            "INSERT INTO t1(d1) VALUES ('2007-07-19 08:30:00'), (NULL), ('2007-07-19 08:34:00'), (NULL), ('2007-07-19 08:36:00');\n",
            "SELECT CAST(d1 AS TIMESTAMP) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (f1 DATE);\n",
            "INSERT INTO t1 VALUES ('2007-07-19'), (NULL);\n",
            "SELECT EXTRACT(HOUR FROM f1), \"minute\"(f1), EXTRACT(SECOND FROM f1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT EXTRACT(HOUR FROM CAST('2007-07-19' AS DATE)), \"minute\"(CAST('2007-07-19' AS DATE)), EXTRACT(SECOND FROM CAST('2007-07-19' AS DATE));\n",
            "SELECT EXTRACT(HOUR FROM CAST(NULL AS DATE)), \"minute\"(CAST(NULL AS DATE)), EXTRACT(SECOND FROM CAST(NULL AS DATE));\n",
            "SELECT EXTRACT(HOUR FROM NULL), \"minute\"(NULL), EXTRACT(SECOND FROM NULL);\n",
            "SELECT CAST('a' AS VARCHAR(2049));\n",
            "SELECT 'value=' || CAST('3.4e5' AS FLOAT);\n"
        ]
    },
    {
        "sql_id": 193,
        "database_name": "BUTTERTrans_193",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT STRCMP(a, b) FROM t1; -- STRCMP",
        "target_query": "SELECT CASE WHEN CAST(a AS String) = CAST(b AS string) THEN 0 WHEN a < b THEN -1 ELSE 1 END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a YEAR, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','random_str');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a int, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','1996');\n"
        ]
    },
    {
        "sql_id": 194,
        "database_name": "BUTTERTrans_194",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT",
        "target_query": "SELECT CAST(1988 AS int), REPEAT(CAST(1988 AS int), 3) AS c2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 27,
                "end_pos": 33
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a YEAR, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','random_str');\n",
            "SELECT STRCMP(a, b) FROM t1; -- STRCMP\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a int, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','1996');\n",
            "SELECT CASE WHEN CAST(a AS String) = CAST(b AS string) THEN 0 WHEN a < b THEN -1 ELSE 1 END FROM t1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 195,
        "database_name": "BUTTERTrans_195",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT",
        "target_query": "SELECT 'x' || CAST(1988 AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a YEAR, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','random_str');\n",
            "SELECT STRCMP(a, b) FROM t1; -- STRCMP\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a int, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','1996');\n",
            "SELECT CASE WHEN CAST(a AS String) = CAST(b AS string) THEN 0 WHEN a < b THEN -1 ELSE 1 END FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS int), REPEAT(CAST(1988 AS int), 3) AS c2;\n"
        ]
    },
    {
        "sql_id": 196,
        "database_name": "BUTTERTrans_196",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIME_TO_SEC(CAST('2030' AS YEAR)); -- TIME_TO_SEC",
        "target_query": "SELECT EXTRACT(EPOCH FROM date '2030-01-01');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIME_TO_SEC",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME_TO_SEC(time)",
                "description": "Converts a time value (HH:MM:SS) to the total number of seconds.",
                "examples": [
                    "SELECT TIME_TO_SEC('15:12:22');",
                    "SELECT TIME_TO_SEC('00:01:00');",
                    "SELECT SEC_TO_TIME(TIME_TO_SEC('15:12:22') - TIME_TO_SEC('14:12:22'));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM time)",
                "description": "Converts a time value (HH:MM:SS) to the total number of seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM TIME '15:12:22');",
                    "SELECT EXTRACT(EPOCH FROM TIME '00:01:00');",
                    "SELECT EXTRACT(EPOCH FROM TIME '15:12:22') - EXTRACT(EPOCH FROM TIME '14:12:22');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a YEAR, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','random_str');\n",
            "SELECT STRCMP(a, b) FROM t1; -- STRCMP\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT\n",
            "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a int, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','1996');\n",
            "SELECT CASE WHEN CAST(a AS String) = CAST(b AS string) THEN 0 WHEN a < b THEN -1 ELSE 1 END FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS int), REPEAT(CAST(1988 AS int), 3) AS c2;\n",
            "SELECT 'x' || CAST(1988 AS STRING);\n"
        ]
    },
    {
        "sql_id": 197,
        "database_name": "BUTTERTrans_197",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIMESTAMPADD(MINUTE, 1, CAST(1988 AS YEAR)); -- TIMESTAMPADD",
        "target_query": "SELECT DATE '1988-01-01' + INTERVAL '1' MINUTE;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMPADD",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMPADD(unit, interval, datetime_expr)",
                "description": "Adds a time interval to a date or timestamp expression using the specified unit.",
                "examples": [
                    "SELECT TIMESTAMPADD(DAY, 2, '2023-01-01');",
                    "SELECT TIMESTAMPADD(MINUTE, -5, '2023-05-10 12:00:00');",
                    "SELECT TIMESTAMPADD(YEAR, 1, '2020-06-15');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime_expr + INTERVAL 'n' unit",
                "description": "Adds a time interval to a timestamp or date using SQL standard INTERVAL syntax with integer value and time unit.",
                "examples": [
                    "SELECT DATE '2023-01-01' + INTERVAL '2' DAY;",
                    "SELECT TIMESTAMP '2023-05-10 12:00:00' + INTERVAL '-5' MINUTE;",
                    "SELECT DATE '2020-06-15' + INTERVAL '1' YEAR;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a YEAR, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','random_str');\n",
            "SELECT STRCMP(a, b) FROM t1; -- STRCMP\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT\n",
            "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT\n",
            "SELECT TIME_TO_SEC(CAST('2030' AS YEAR)); -- TIME_TO_SEC\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a int, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','1996');\n",
            "SELECT CASE WHEN CAST(a AS String) = CAST(b AS string) THEN 0 WHEN a < b THEN -1 ELSE 1 END FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS int), REPEAT(CAST(1988 AS int), 3) AS c2;\n",
            "SELECT 'x' || CAST(1988 AS STRING);\n",
            "SELECT EXTRACT(EPOCH FROM date '2030-01-01');\n"
        ]
    },
    {
        "sql_id": 198,
        "database_name": "BUTTERTrans_198",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CAST(STR_TO_DATE('nope','%d-%m-%Y') AS YEAR); -- STR_TO_DATE",
        "target_query": "SELECT CAST(str_to_date('01-05-1997','%d-%m-%Y') AS date);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STR_TO_DATE",
                "start_pos": 12,
                "end_pos": 23
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
                "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
                "examples": [
                    "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
                    "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
                    "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a YEAR, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','random_str');\n",
            "SELECT STRCMP(a, b) FROM t1; -- STRCMP\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT\n",
            "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT\n",
            "SELECT TIME_TO_SEC(CAST('2030' AS YEAR)); -- TIME_TO_SEC\n",
            "SELECT TIMESTAMPADD(MINUTE, 1, CAST(1988 AS YEAR)); -- TIMESTAMPADD\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a int, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','1996');\n",
            "SELECT CASE WHEN CAST(a AS String) = CAST(b AS string) THEN 0 WHEN a < b THEN -1 ELSE 1 END FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS int), REPEAT(CAST(1988 AS int), 3) AS c2;\n",
            "SELECT 'x' || CAST(1988 AS STRING);\n",
            "SELECT EXTRACT(EPOCH FROM date '2030-01-01');\n",
            "SELECT DATE '1988-01-01' + INTERVAL '1' MINUTE;\n"
        ]
    },
    {
        "sql_id": 199,
        "database_name": "BUTTERTrans_199",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT 1 FROM t WHERE CAST(a AS UNSIGNED INTEGER) = 1 AND a = IF(TRUE, NULL, 1); -- IF",
        "target_query": "SELECT 1 FROM t WHERE CAST(a AS INTEGER) = 1 AND a = CASE WHEN TRUE THEN NULL ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 62,
                "end_pos": 64
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a YEAR, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','random_str');\n",
            "SELECT STRCMP(a, b) FROM t1; -- STRCMP\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS YEAR), REPEAT(CAST(1988 AS YEAR), 3) AS c2; -- REPEAT\n",
            "SELECT CONCAT('x', CAST(1988 AS YEAR)); -- CONCAT\n",
            "SELECT TIME_TO_SEC(CAST('2030' AS YEAR)); -- TIME_TO_SEC\n",
            "SELECT TIMESTAMPADD(MINUTE, 1, CAST(1988 AS YEAR)); -- TIMESTAMPADD\n",
            "SELECT CAST(STR_TO_DATE('nope','%d-%m-%Y') AS YEAR); -- STR_TO_DATE\n",
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t (a INT NOT NULL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a int, b VARCHAR(10));\n",
            "INSERT INTO t1 VALUES ('1997','1996');\n",
            "SELECT CASE WHEN CAST(a AS String) = CAST(b AS string) THEN 0 WHEN a < b THEN -1 ELSE 1 END FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT CAST(1988 AS int), REPEAT(CAST(1988 AS int), 3) AS c2;\n",
            "SELECT 'x' || CAST(1988 AS STRING);\n",
            "SELECT EXTRACT(EPOCH FROM date '2030-01-01');\n",
            "SELECT DATE '1988-01-01' + INTERVAL '1' MINUTE;\n",
            "SELECT CAST(str_to_date('01-05-1997','%d-%m-%Y') AS date);\n",
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t (a INT NOT NULL);\n"
        ]
    },
    {
        "sql_id": 200,
        "database_name": "BUTTERTrans_200",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TRIM",
                "start_pos": 59,
                "end_pos": 63
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = a;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = CAST(a AS VARCHAR);\n"
        ]
    },
    {
        "sql_id": 201,
        "database_name": "BUTTERTrans_201",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TRIM",
                "start_pos": 59,
                "end_pos": 63
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = a;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = CAST(a AS VARCHAR);\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;\n"
        ]
    },
    {
        "sql_id": 202,
        "database_name": "BUTTERTrans_202",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(CAST(a AS VARCHAR)) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TRIM",
                "start_pos": 59,
                "end_pos": 63
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = a;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = CAST(a AS VARCHAR);\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;\n"
        ]
    },
    {
        "sql_id": 203,
        "database_name": "BUTTERTrans_203",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM",
        "target_query": "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(CAST(a AS VARCHAR)) = b;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TRIM",
                "start_pos": 41,
                "end_pos": 45
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = a;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = CAST(a AS VARCHAR);\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(CAST(a AS VARCHAR)) = b;\n"
        ]
    },
    {
        "sql_id": 204,
        "database_name": "BUTTERTrans_204",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a) BETWEEN 0 and 0.9; -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(a, NULL) BETWEEN 0 AND 0.9;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 23,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = a;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a BIGINT);\n",
            "INSERT INTO t1 VALUES (1);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = CAST(a AS VARCHAR);\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a BIGINT);\n",
            "INSERT INTO t1 VALUES (1);\n"
        ]
    },
    {
        "sql_id": 205,
        "database_name": "BUTTERTrans_205",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a)=0.9; -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(a, NULL) = 0.9;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 23,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = a;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a BIGINT);\n",
            "INSERT INTO t1 VALUES (1);\n",
            "SELECT * FROM t1 WHERE coalesce(a) BETWEEN 0 and 0.9; -- COALESCE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = CAST(a AS VARCHAR);\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a BIGINT);\n",
            "INSERT INTO t1 VALUES (1);\n",
            "SELECT * FROM t1 WHERE COALESCE(a, NULL) BETWEEN 0 AND 0.9;\n"
        ]
    },
    {
        "sql_id": 206,
        "database_name": "BUTTERTrans_206",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t1 WHERE coalesce(a) in (0.8,0.9); -- COALESCE",
        "target_query": "SELECT * FROM t1 WHERE COALESCE(a, NULL) IN (0.8, 0.9);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 23,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT AUTO_INCREMENT PRIMARY KEY,a BIGINT(20) UNSIGNED,b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = a;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(a) = b; -- TRIM\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(a) = b; -- TRIM\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a BIGINT);\n",
            "INSERT INTO t1 VALUES (1);\n",
            "SELECT * FROM t1 WHERE coalesce(a) BETWEEN 0 and 0.9; -- COALESCE\n",
            "SELECT * FROM t1 WHERE coalesce(a)=0.9; -- COALESCE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id SERIAL, a BIGINT, b VARCHAR(20));\n",
            "INSERT INTO t1 (a) VALUES (0), (9223372036854775807), (9223372036854775806), (9223372036854775805);\n",
            "UPDATE t1 SET b = CAST(a AS VARCHAR);\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775807 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775806 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 9223372036854775805 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "EXPLAIN SELECT 1 FROM t1 WHERE a = 0 AND TRIM(CAST(a AS VARCHAR)) = b;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a BIGINT);\n",
            "INSERT INTO t1 VALUES (1);\n",
            "SELECT * FROM t1 WHERE COALESCE(a, NULL) BETWEEN 0 AND 0.9;\n",
            "SELECT * FROM t1 WHERE COALESCE(a, NULL) = 0.9;\n"
        ]
    },
    {
        "sql_id": 207,
        "database_name": "BUTTERTrans_207",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP",
        "target_query": "SELECT NULL AS hex_a, CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END AS strcmp_a_a, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END AS strcmp_a_a_space FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "HEX",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 14,
                "end_pos": 20
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 29,
                "end_pos": 35
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            },
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n"
        ]
    },
    {
        "sql_id": 208,
        "database_name": "BUTTERTrans_208",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1; -- CONCAT",
        "target_query": "SELECT b || c AS concat_bc, b || c = '0101' AS concat_bc_equals_0101 FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 20,
                "end_pos": 26
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n",
            "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);\n",
            "INSERT INTO t1 (b,c) VALUES (1,2), (1,1), (2,2);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n",
            "SELECT NULL AS hex_a, CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END AS strcmp_a_a, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END AS strcmp_a_a_space FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b int, c int);\n",
            "INSERT INTO t1 (b,c) VALUES (1,2), (1,1), (2,2);\n"
        ]
    },
    {
        "sql_id": 209,
        "database_name": "BUTTERTrans_209",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
        "target_query": "EXPLAIN SELECT b, c FROM t1 WHERE b = 1 AND b || c = '0101';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 43,
                "end_pos": 49
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n",
            "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);\n",
            "INSERT INTO t1 (b,c) VALUES (1,2), (1,1), (2,2);\n",
            "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n",
            "SELECT NULL AS hex_a, CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END AS strcmp_a_a, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END AS strcmp_a_a_space FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b int, c int);\n",
            "INSERT INTO t1 (b,c) VALUES (1,2), (1,1), (2,2);\n",
            "SELECT b || c AS concat_bc, b || c = '0101' AS concat_bc_equals_0101 FROM t1;\n"
        ]
    },
    {
        "sql_id": 210,
        "database_name": "BUTTERTrans_210",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT",
        "target_query": "SELECT b, c FROM t1 WHERE b = 1 AND b || c = '0101';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 35,
                "end_pos": 41
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n",
            "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);\n",
            "INSERT INTO t1 (b,c) VALUES (1,2), (1,1), (2,2);\n",
            "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1; -- CONCAT\n",
            "EXPLAIN SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n",
            "SELECT NULL AS hex_a, CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END AS strcmp_a_a, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END AS strcmp_a_a_space FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b int, c int);\n",
            "INSERT INTO t1 (b,c) VALUES (1,2), (1,1), (2,2);\n",
            "SELECT b || c AS concat_bc, b || c = '0101' AS concat_bc_equals_0101 FROM t1;\n",
            "EXPLAIN SELECT b, c FROM t1 WHERE b = 1 AND b || c = '0101';\n"
        ]
    },
    {
        "sql_id": 211,
        "database_name": "BUTTERTrans_211",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (NOW()),(NOW()),(NOW()); -- NOW",
        "target_query": "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP),(CURRENT_TIMESTAMP),(CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 23,
                "end_pos": 26
            },
            {
                "dialect_token": "NOW",
                "start_pos": 31,
                "end_pos": 34
            },
            {
                "dialect_token": "NOW",
                "start_pos": 39,
                "end_pos": 42
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n",
            "SELECT hex(a),STRCMP(a,'a'), STRCMP(a,'a ') FROM t1; -- HEX, STRCMP\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE  t1 (b int(2) zerofill, c int(2) zerofill);\n",
            "INSERT INTO t1 (b,c) VALUES (1,2), (1,1), (2,2);\n",
            "SELECT CONCAT(b,c), CONCAT(b,c) = '0101' FROM t1; -- CONCAT\n",
            "EXPLAIN SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT\n",
            "SELECT b,c FROM t1 WHERE b = 1 AND CONCAT(b,c) = '0101'; -- CONCAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a char(10) not null);\n",
            "INSERT INTO t1 VALUES ('a'),('a\\\\0'),('a\\\\t'),('a ');\n",
            "SELECT NULL AS hex_a, CASE WHEN a = 'a' THEN 0 WHEN a < 'a' THEN -1 ELSE 1 END AS strcmp_a_a, CASE WHEN a = 'a ' THEN 0 WHEN a < 'a ' THEN -1 ELSE 1 END AS strcmp_a_a_space FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b int, c int);\n",
            "INSERT INTO t1 (b,c) VALUES (1,2), (1,1), (2,2);\n",
            "SELECT b || c AS concat_bc, b || c = '0101' AS concat_bc_equals_0101 FROM t1;\n",
            "EXPLAIN SELECT b, c FROM t1 WHERE b = 1 AND b || c = '0101';\n",
            "SELECT b, c FROM t1 WHERE b = 1 AND b || c = '0101';\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 212,
        "database_name": "BUTTERTrans_212",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select count(distinct if(f1,3,f2)) from t1; -- COUNT, IF",
        "target_query": "select count(distinct case when f1 then 3 else f2 end) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 22,
                "end_pos": 24
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            },
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (f1 int, f2 int);\n",
            "insert into t1 values (0,1),(1,2);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (f1 int, f2 int);\n",
            "insert into t1 values (0,1),(1,2);\n"
        ]
    },
    {
        "sql_id": 213,
        "database_name": "BUTTERTrans_213",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(name,space(level)), concat(name, repeat(' ',level)) from t1; -- CONCAT, SPACE, REPEAT",
        "target_query": "SELECT name || REPEAT(' ', level), name || REPEAT(' ', level) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "SPACE",
                "start_pos": 19,
                "end_pos": 24
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 34,
                "end_pos": 40
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 47,
                "end_pos": 53
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "SPACE(n)",
                "description": "Returns a string consisting of n space characters.",
                "examples": [
                    "SELECT LENGTH(SPACE(5));",
                    "SELECT CONCAT('A', SPACE(3), 'B');",
                    "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            },
            {
                "expression": "REPEAT(' ', n)",
                "description": "Returns a string consisting of n space characters by repeating a space character. String concatenation is performed using the '||' operator.",
                "examples": [
                    "SELECT LENGTH(REPEAT(' ', 5));",
                    "SELECT 'A' || REPEAT(' ', 3) || 'B';",
                    "SELECT REPEAT('-', 2) || REPEAT(' ', 4) || '!';"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (name varchar(10),level smallint);\n",
            "insert into t1 values ('string',1);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (name VARCHAR(10), level SMALLINT);\n",
            "INSERT INTO t1 VALUES ('string', 1);\n"
        ]
    },
    {
        "sql_id": 214,
        "database_name": "BUTTERTrans_214",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "create table t1 select repeat('a',4000) a; -- REPEAT",
        "target_query": "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (name varchar(10),level smallint);\n",
            "insert into t1 values ('string',1);\n",
            "select concat(name,space(level)), concat(name, repeat(' ',level)) from t1; -- CONCAT, SPACE, REPEAT\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (name VARCHAR(10), level SMALLINT);\n",
            "INSERT INTO t1 VALUES ('string', 1);\n",
            "SELECT name || REPEAT(' ', level), name || REPEAT(' ', level) FROM t1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 215,
        "database_name": "BUTTERTrans_215",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 28,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (name varchar(10),level smallint);\n",
            "insert into t1 values ('string',1);\n",
            "select concat(name,space(level)), concat(name, repeat(' ',level)) from t1; -- CONCAT, SPACE, REPEAT\n",
            "drop table t1;\n",
            "create table t1 select repeat('a',4000) a; -- REPEAT\n",
            "delete from t1;\n",
            "insert into t1 values ('a'), ('a '), ('a\\\\t');\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (name VARCHAR(10), level SMALLINT);\n",
            "INSERT INTO t1 VALUES ('string', 1);\n",
            "SELECT name || REPEAT(' ', level), name || REPEAT(' ', level) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 VALUES ('a'), ('a '), ('a\\\\t');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'), ('1'), ('2'), ('3'), ('4'), ('5'), ('6'), ('7');\n",
            "INSERT INTO t1 VALUES ('8'), ('9'), ('A'), ('B'), ('C'), ('D'), ('E'), ('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n"
        ]
    },
    {
        "sql_id": 216,
        "database_name": "BUTTERTrans_216",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 28,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (name varchar(10),level smallint);\n",
            "insert into t1 values ('string',1);\n",
            "select concat(name,space(level)), concat(name, repeat(' ',level)) from t1; -- CONCAT, SPACE, REPEAT\n",
            "drop table t1;\n",
            "create table t1 select repeat('a',4000) a; -- REPEAT\n",
            "delete from t1;\n",
            "insert into t1 values ('a'), ('a '), ('a\\\\t');\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (name VARCHAR(10), level SMALLINT);\n",
            "INSERT INTO t1 VALUES ('string', 1);\n",
            "SELECT name || REPEAT(' ', level), name || REPEAT(' ', level) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;\n",
            "DELETE FROM t1;\n",
            "INSERT INTO t1 VALUES ('a'), ('a '), ('a\\\\t');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'), ('1'), ('2'), ('3'), ('4'), ('5'), ('6'), ('7');\n",
            "INSERT INTO t1 VALUES ('8'), ('9'), ('A'), ('B'), ('C'), ('D'), ('E'), ('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2;\n"
        ]
    },
    {
        "sql_id": 217,
        "database_name": "BUTTERTrans_217",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL",
        "target_query": "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GROUP_CONCAT",
                "start_pos": 7,
                "end_pos": 19
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 20,
                "end_pos": 26
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            },
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "group_concat(X) group_concat(X,Y)",
                "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
                    "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
                ]
            },
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a MEDIUMINT NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INTEGER NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n"
        ]
    },
    {
        "sql_id": 218,
        "database_name": "BUTTERTrans_218",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF",
        "target_query": "SELECT GROUP_CONCAT(CASE WHEN a IS NOT NULL THEN a ELSE '' END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GROUP_CONCAT",
                "start_pos": 7,
                "end_pos": 19
            },
            {
                "dialect_token": "IF",
                "start_pos": 20,
                "end_pos": 22
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            },
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "group_concat(X) group_concat(X,Y)",
                "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
                    "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
                ]
            },
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a MEDIUMINT NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INTEGER NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;\n"
        ]
    },
    {
        "sql_id": 219,
        "database_name": "BUTTERTrans_219",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT",
        "target_query": "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GROUP_CONCAT",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "group_concat(X) group_concat(X,Y)",
                "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
                    "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a MEDIUMINT NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL\n",
            "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INTEGER NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a IS NOT NULL THEN a ELSE '' END) FROM t1;\n"
        ]
    },
    {
        "sql_id": 220,
        "database_name": "BUTTERTrans_220",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT COALESCE(a,'') FROM t1 GROUP BY 1; -- COALESCE",
        "target_query": "SELECT COALESCE(a,'') FROM t1 GROUP BY 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a MEDIUMINT NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL\n",
            "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF\n",
            "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INTEGER NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a IS NOT NULL THEN a ELSE '' END) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1;\n"
        ]
    },
    {
        "sql_id": 221,
        "database_name": "BUTTERTrans_221",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE",
        "target_query": "CREATE TABLE t2 AS SELECT lower(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LCASE",
                "start_pos": 26,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LCASE(str)",
                "description": "Converts all characters in a string to lowercase. Equivalent to LOWER(str).",
                "examples": [
                    "SELECT LCASE('TeSt');",
                    "SELECT LCASE(CONCAT('A', 'B', 'C'));",
                    "SELECT LCASE(456);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lower(str)",
                "description": "Converts a string to lowercase letters.",
                "examples": [
                    "SELECT lower('TeSt');",
                    "SELECT lower('ABC');",
                    "SELECT lower(CAST(456 AS VARCHAR));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a MEDIUMINT NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL\n",
            "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF\n",
            "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT\n",
            "SELECT COALESCE(a,'') FROM t1 GROUP BY 1; -- COALESCE\n",
            "DROP TABLE IF EXISTS t2;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INTEGER NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a IS NOT NULL THEN a ELSE '' END) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1;\n",
            "SELECT COALESCE(a,'') FROM t1 GROUP BY 1;\n",
            "DROP TABLE IF EXISTS t2;\n"
        ]
    },
    {
        "sql_id": 222,
        "database_name": "BUTTERTrans_222",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE",
        "target_query": "CREATE TABLE t2 AS SELECT UPPER(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UCASE",
                "start_pos": 26,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UCASE(str)",
                "description": "Returns the string `str` with all characters converted to uppercase. UCASE is a synonym for UPPER.",
                "examples": [
                    "SELECT UCASE('hello world');",
                    "SELECT UCASE(CONCAT('abc', '123'));",
                    "SELECT UCASE(REPLACE('test case', 'case', 'CASE'));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "UPPER(str)",
                "description": "Returns the given string with all alphabetic characters converted to uppercase.",
                "examples": [
                    "SELECT UPPER('hello world');",
                    "SELECT UPPER(CONCAT('abc', '123'));",
                    "SELECT UPPER(REPLACE('test case', 'case', 'CASE'));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a MEDIUMINT NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL\n",
            "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF\n",
            "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT\n",
            "SELECT COALESCE(a,'') FROM t1 GROUP BY 1; -- COALESCE\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE\n",
            "DROP TABLE t2;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INTEGER NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a IS NOT NULL THEN a ELSE '' END) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1;\n",
            "SELECT COALESCE(a,'') FROM t1 GROUP BY 1;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 AS SELECT lower(a) FROM t1;\n",
            "DROP TABLE t2;\n"
        ]
    },
    {
        "sql_id": 223,
        "database_name": "BUTTERTrans_223",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1; -- REPEAT",
        "target_query": "CREATE TABLE t2 AS SELECT REPEAT(1,2) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a MEDIUMINT NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(IFNULL(a,'')) FROM t1; -- GROUP_CONCAT, IFNULL\n",
            "SELECT GROUP_CONCAT(IF(a,a,'')) FROM t1; -- GROUP_CONCAT, IF\n",
            "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1; -- GROUP_CONCAT\n",
            "SELECT COALESCE(a,'') FROM t1 GROUP BY 1; -- COALESCE\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 AS SELECT LCASE(a) FROM t1; -- LCASE\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t2 AS SELECT UCASE(a) FROM t1; -- UCASE\n",
            "DROP TABLE t2;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a INTEGER NULL);\n",
            "INSERT INTO t1 VALUES (1234567);\n",
            "SELECT GROUP_CONCAT(COALESCE(a,'')) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a IS NOT NULL THEN a ELSE '' END) FROM t1;\n",
            "SELECT GROUP_CONCAT(CASE WHEN a THEN a ELSE '' END) FROM t1;\n",
            "SELECT COALESCE(a,'') FROM t1 GROUP BY 1;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 AS SELECT lower(a) FROM t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t2 AS SELECT UPPER(a) FROM t1;\n",
            "DROP TABLE t2;\n"
        ]
    },
    {
        "sql_id": 224,
        "database_name": "BUTTERTrans_224",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t1 where a=lpad('xxx',10,' '); -- LPAD",
        "target_query": "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 25,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n"
        ]
    },
    {
        "sql_id": 225,
        "database_name": "BUTTERTrans_225",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL",
        "target_query": "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 22,
                "end_pos": 28
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n",
            "select * from t1 where a=lpad('xxx',10,' '); -- LPAD\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 char(10));\n",
            "insert into t1 values ('x');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n",
            "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c1 CHAR(10));\n",
            "INSERT INTO t1 VALUES ('');\n"
        ]
    },
    {
        "sql_id": 226,
        "database_name": "BUTTERTrans_226",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select if(1,c1,''), if(0,c1,'') from t1; -- IF",
        "target_query": "SELECT CASE WHEN 1 THEN c1 ELSE '' END, CASE WHEN 0 THEN c1 ELSE '' END FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 7,
                "end_pos": 9
            },
            {
                "dialect_token": "IF",
                "start_pos": 20,
                "end_pos": 22
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n",
            "select * from t1 where a=lpad('xxx',10,' '); -- LPAD\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 char(10));\n",
            "insert into t1 values ('x');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n",
            "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c1 CHAR(10));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n"
        ]
    },
    {
        "sql_id": 227,
        "database_name": "BUTTERTrans_227",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE",
        "target_query": "SELECT COALESCE(c1,''), COALESCE(NULL,c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 7,
                "end_pos": 15
            },
            {
                "dialect_token": "COALESCE",
                "start_pos": 24,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n",
            "select * from t1 where a=lpad('xxx',10,' '); -- LPAD\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 char(10));\n",
            "insert into t1 values ('x');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "select if(1,c1,''), if(0,c1,'') from t1; -- IF\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n",
            "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c1 CHAR(10));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "SELECT CASE WHEN 1 THEN c1 ELSE '' END, CASE WHEN 0 THEN c1 ELSE '' END FROM t1;\n"
        ]
    },
    {
        "sql_id": 228,
        "database_name": "BUTTERTrans_228",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST",
        "target_query": "SELECT CASE WHEN c1 IS NULL THEN '' WHEN '' IS NULL THEN c1 WHEN c1 <= '' THEN c1 ELSE '' END, GREATEST(c1,'') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            },
            {
                "dialect_token": "GREATEST",
                "start_pos": 21,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n",
            "select * from t1 where a=lpad('xxx',10,' '); -- LPAD\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 char(10));\n",
            "insert into t1 values ('x');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "select if(1,c1,''), if(0,c1,'') from t1; -- IF\n",
            "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n",
            "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c1 CHAR(10));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "SELECT CASE WHEN 1 THEN c1 ELSE '' END, CASE WHEN 0 THEN c1 ELSE '' END FROM t1;\n",
            "SELECT COALESCE(c1,''), COALESCE(NULL,c1) FROM t1;\n"
        ]
    },
    {
        "sql_id": 229,
        "database_name": "BUTTERTrans_229",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select locate(c1,''), locate('',c1) from t1; -- LOCATE",
        "target_query": "SELECT POSITION(c1 IN ''), POSITION('' IN c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LOCATE",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "LOCATE",
                "start_pos": 22,
                "end_pos": 28
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LOCATE(substr, str[, start_position])",
                "description": "Returns the position of the first occurrence of substring 'substr' in string 'str'. If 'start_position' is provided, the search starts from that position.",
                "examples": [
                    "select locate('a', 'banana', 2);",
                    "select locate('foo', 'foobar', 2);",
                    "select locate('ab', 'abcab', 3);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POSITION(substr IN str)",
                "description": "Same as PostgreSQL. Returns the position of the first occurrence of substring 'substr' in string 'str'. MonetDB does not support 'start_position'.",
                "examples": [
                    "select position('a' IN 'banana');",
                    "select position('foo' IN 'foobar');",
                    "select position('ab' IN 'abcab');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n",
            "select * from t1 where a=lpad('xxx',10,' '); -- LPAD\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 char(10));\n",
            "insert into t1 values ('x');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "select if(1,c1,''), if(0,c1,'') from t1; -- IF\n",
            "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE\n",
            "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n",
            "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c1 CHAR(10));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "SELECT CASE WHEN 1 THEN c1 ELSE '' END, CASE WHEN 0 THEN c1 ELSE '' END FROM t1;\n",
            "SELECT COALESCE(c1,''), COALESCE(NULL,c1) FROM t1;\n",
            "SELECT CASE WHEN c1 IS NULL THEN '' WHEN '' IS NULL THEN c1 WHEN c1 <= '' THEN c1 ELSE '' END, GREATEST(c1,'') FROM t1;\n"
        ]
    },
    {
        "sql_id": 230,
        "database_name": "BUTTERTrans_230",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(c1,''), concat('',c1) from t1; -- CONCAT",
        "target_query": "SELECT c1 || '', '' || c1 FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 22,
                "end_pos": 28
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n",
            "select * from t1 where a=lpad('xxx',10,' '); -- LPAD\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 char(10));\n",
            "insert into t1 values ('x');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "select if(1,c1,''), if(0,c1,'') from t1; -- IF\n",
            "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE\n",
            "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST\n",
            "select locate(c1,''), locate('',c1) from t1; -- LOCATE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n",
            "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c1 CHAR(10));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "SELECT CASE WHEN 1 THEN c1 ELSE '' END, CASE WHEN 0 THEN c1 ELSE '' END FROM t1;\n",
            "SELECT COALESCE(c1,''), COALESCE(NULL,c1) FROM t1;\n",
            "SELECT CASE WHEN c1 IS NULL THEN '' WHEN '' IS NULL THEN c1 WHEN c1 <= '' THEN c1 ELSE '' END, GREATEST(c1,'') FROM t1;\n",
            "SELECT POSITION(c1 IN ''), POSITION('' IN c1) FROM t1;\n"
        ]
    },
    {
        "sql_id": 231,
        "database_name": "BUTTERTrans_231",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select lpad(c1,3,'x'), lpad('x',3,c1) from t1; -- LPAD",
        "target_query": "select lpad(c1,3,''), lpad('',3,c1) from t1; -- LPAD",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "LPAD",
                "start_pos": 23,
                "end_pos": 27
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n",
            "select * from t1 where a=lpad('xxx',10,' '); -- LPAD\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 char(10));\n",
            "insert into t1 values ('x');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "select if(1,c1,''), if(0,c1,'') from t1; -- IF\n",
            "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE\n",
            "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST\n",
            "select locate(c1,''), locate('',c1) from t1; -- LOCATE\n",
            "select concat(c1,''), concat('',c1) from t1; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n",
            "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c1 CHAR(10));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "SELECT CASE WHEN 1 THEN c1 ELSE '' END, CASE WHEN 0 THEN c1 ELSE '' END FROM t1;\n",
            "SELECT COALESCE(c1,''), COALESCE(NULL,c1) FROM t1;\n",
            "SELECT CASE WHEN c1 IS NULL THEN '' WHEN '' IS NULL THEN c1 WHEN c1 <= '' THEN c1 ELSE '' END, GREATEST(c1,'') FROM t1;\n",
            "SELECT POSITION(c1 IN ''), POSITION('' IN c1) FROM t1;\n",
            "SELECT c1 || '', '' || c1 FROM t1;\n"
        ]
    },
    {
        "sql_id": 232,
        "database_name": "BUTTERTrans_232",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select rpad(c1,3,'x'), rpad('x',3,c1) from t1; -- RPAD",
        "target_query": "SELECT RPAD(c1,3,''), RPAD('',3,c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "RPAD",
                "start_pos": 23,
                "end_pos": 27
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(10)) SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "create table t1 (a char(20));\n",
            "insert into t1 values ('       xxx');\n",
            "select * from t1 where a=lpad('xxx',10,' '); -- LPAD\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 char(10));\n",
            "insert into t1 values ('x');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "select if(1,c1,''), if(0,c1,'') from t1; -- IF\n",
            "select coalesce('',c1), coalesce(null,c1) from t1; -- COALESCE\n",
            "select least(c1,''), greatest(c1,'') from t1; -- LEAST, GREATEST\n",
            "select locate(c1,''), locate('',c1) from t1; -- LOCATE\n",
            "select concat(c1,''), concat('',c1) from t1; -- CONCAT\n",
            "select lpad(c1,3,'x'), lpad('x',3,c1) from t1; -- LPAD\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 as SELECT '' AS a;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a CHAR(10));\n",
            "INSERT into t2 SELECT * FROM t1;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1 (a CHAR(20));\n",
            "INSERT INTO t1 VALUES ('        xxx');\n",
            "SELECT * FROM t1 WHERE a=CONCAT(REPEAT(' ', GREATEST(0, 10 - LENGTH('xxx'))), 'xxx');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c1 CHAR(10));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "select ifnull(c1,''), ifnull(null,c1) from t1; -- IFNULL\n",
            "SELECT CASE WHEN 1 THEN c1 ELSE '' END, CASE WHEN 0 THEN c1 ELSE '' END FROM t1;\n",
            "SELECT COALESCE(c1,''), COALESCE(NULL,c1) FROM t1;\n",
            "SELECT CASE WHEN c1 IS NULL THEN '' WHEN '' IS NULL THEN c1 WHEN c1 <= '' THEN c1 ELSE '' END, GREATEST(c1,'') FROM t1;\n",
            "SELECT POSITION(c1 IN ''), POSITION('' IN c1) FROM t1;\n",
            "SELECT c1 || '', '' || c1 FROM t1;\n",
            "select lpad(c1,3,''), lpad('',3,c1) from t1; -- LPAD\n"
        ]
    },
    {
        "sql_id": 233,
        "database_name": "BUTTERTrans_233",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select date1,format1,str_to_date(date1, format1) as str_to_date from t1; -- STR_TO_DATE",
        "target_query": "SELECT date1, format1, str_to_date(date1, format1) AS str_to_date FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STR_TO_DATE",
                "start_pos": 21,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
                "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
                "examples": [
                    "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
                    "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
                    "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (date1 char(30), format1 char(30) not null);\n",
            "insert into t1 values('2003-01-02 10:11:12', '%Y-%m-%d %H:%i:%S');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (date1 CHAR(30), format1 CHAR(30) NOT NULL);\n",
            "INSERT INTO t1 VALUES('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');\n"
        ]
    },
    {
        "sql_id": 234,
        "database_name": "BUTTERTrans_234",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select date1,format1,concat('',str_to_date(date1, format1)) as con from t1; -- CONCAT, STR_TO_DATE",
        "target_query": "SELECT date1, format1, '' || str_to_date(date1, format1) AS con FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 21,
                "end_pos": 27
            },
            {
                "dialect_token": "STR_TO_DATE",
                "start_pos": 31,
                "end_pos": 42
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            },
            {
                "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
                "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
                "examples": [
                    "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
                    "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
                    "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (date1 char(30), format1 char(30) not null);\n",
            "insert into t1 values('2003-01-02 10:11:12', '%Y-%m-%d %H:%i:%S');\n",
            "select date1,format1,str_to_date(date1, format1) as str_to_date from t1; -- STR_TO_DATE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (date1 CHAR(30), format1 CHAR(30) NOT NULL);\n",
            "INSERT INTO t1 VALUES('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');\n",
            "SELECT date1, format1, str_to_date(date1, format1) AS str_to_date FROM t1;\n"
        ]
    },
    {
        "sql_id": 235,
        "database_name": "BUTTERTrans_235",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select date1,format1,DATE(str_to_date(date1, format1)) as date2 from t1; -- DATE, STR_TO_DATE",
        "target_query": "SELECT date1, format1, CAST(str_to_date(date1, format1) AS DATE) AS date2 FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE",
                "start_pos": 21,
                "end_pos": 25
            },
            {
                "dialect_token": "STR_TO_DATE",
                "start_pos": 26,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            },
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
                "examples": [
                    "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
                    "SELECT CAST(NOW() AS DATE) AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            },
            {
                "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
                "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
                "examples": [
                    "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
                    "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
                    "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (date1 char(30), format1 char(30) not null);\n",
            "insert into t1 values('2003-01-02 10:11:12', '%Y-%m-%d %H:%i:%S');\n",
            "select date1,format1,str_to_date(date1, format1) as str_to_date from t1; -- STR_TO_DATE\n",
            "select date1,format1,concat('',str_to_date(date1, format1)) as con from t1; -- CONCAT, STR_TO_DATE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (date1 CHAR(30), format1 CHAR(30) NOT NULL);\n",
            "INSERT INTO t1 VALUES('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');\n",
            "SELECT date1, format1, str_to_date(date1, format1) AS str_to_date FROM t1;\n",
            "SELECT date1, format1, '' || str_to_date(date1, format1) AS con FROM t1;\n"
        ]
    },
    {
        "sql_id": 236,
        "database_name": "BUTTERTrans_236",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select date_format(d,\"%d\") from t1 order by 1; -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(d, 'DD') FROM t1 ORDER BY 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (date1 char(30), format1 char(30) not null);\n",
            "insert into t1 values('2003-01-02 10:11:12', '%Y-%m-%d %H:%i:%S');\n",
            "select date1,format1,str_to_date(date1, format1) as str_to_date from t1; -- STR_TO_DATE\n",
            "select date1,format1,concat('',str_to_date(date1, format1)) as con from t1; -- CONCAT, STR_TO_DATE\n",
            "select date1,format1,DATE(str_to_date(date1, format1)) as date2 from t1; -- DATE, STR_TO_DATE\n",
            "drop table t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values ('2004-07-14'),('2005-07-14');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (date1 CHAR(30), format1 CHAR(30) NOT NULL);\n",
            "INSERT INTO t1 VALUES('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');\n",
            "SELECT date1, format1, str_to_date(date1, format1) AS str_to_date FROM t1;\n",
            "SELECT date1, format1, '' || str_to_date(date1, format1) AS con FROM t1;\n",
            "SELECT date1, format1, CAST(str_to_date(date1, format1) AS DATE) AS date2 FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (d DATE);\n",
            "INSERT INTO t1 VALUES ('2004-07-14'), ('2005-07-14');\n"
        ]
    },
    {
        "sql_id": 237,
        "database_name": "BUTTERTrans_237",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select date_format('2004-01-01','%W (%a), %e %M (%b) %Y'); -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2004-01-01', 'Day (DY), DD Month (MON) YYYY');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (date1 char(30), format1 char(30) not null);\n",
            "insert into t1 values('2003-01-02 10:11:12', '%Y-%m-%d %H:%i:%S');\n",
            "select date1,format1,str_to_date(date1, format1) as str_to_date from t1; -- STR_TO_DATE\n",
            "select date1,format1,concat('',str_to_date(date1, format1)) as con from t1; -- CONCAT, STR_TO_DATE\n",
            "select date1,format1,DATE(str_to_date(date1, format1)) as date2 from t1; -- DATE, STR_TO_DATE\n",
            "drop table t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values ('2004-07-14'),('2005-07-14');\n",
            "select date_format(d,\"%d\") from t1 order by 1; -- DATE_FORMAT\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (date1 CHAR(30), format1 CHAR(30) NOT NULL);\n",
            "INSERT INTO t1 VALUES('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');\n",
            "SELECT date1, format1, str_to_date(date1, format1) AS str_to_date FROM t1;\n",
            "SELECT date1, format1, '' || str_to_date(date1, format1) AS con FROM t1;\n",
            "SELECT date1, format1, CAST(str_to_date(date1, format1) AS DATE) AS date2 FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (d DATE);\n",
            "INSERT INTO t1 VALUES ('2004-07-14'), ('2005-07-14');\n",
            "SELECT sys.timestamp_to_str(d, 'DD') FROM t1 ORDER BY 1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 238,
        "database_name": "BUTTERTrans_238",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE",
        "target_query": "SELECT str_to_date('04 /30/2004', '%m /%d/%Y');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STR_TO_DATE",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
                "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
                "examples": [
                    "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
                    "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
                    "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 239,
        "database_name": "BUTTERTrans_239",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select str_to_date('04/30 /2004', '%m /%d /%Y'); -- STR_TO_DATE",
        "target_query": "SELECT str_to_date('04/30 /2004', '%m /%d /%Y');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STR_TO_DATE",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
                "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
                "examples": [
                    "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
                    "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
                    "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
                ]
            }
        ],
        "source_related_schemas": [
            "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE\n"
        ],
        "target_related_schemas": [
            "SELECT str_to_date('04 /30/2004', '%m /%d/%Y');\n"
        ]
    },
    {
        "sql_id": 240,
        "database_name": "BUTTERTrans_240",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select str_to_date('04/30/2004 ', '%m/%d/%Y '); -- STR_TO_DATE",
        "target_query": "SELECT str_to_date('04/30/2004 ', '%m/%d/%Y ');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STR_TO_DATE",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
                "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
                "examples": [
                    "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
                    "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
                    "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
                ]
            }
        ],
        "source_related_schemas": [
            "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE\n",
            "select str_to_date('04/30 /2004', '%m /%d /%Y'); -- STR_TO_DATE\n"
        ],
        "target_related_schemas": [
            "SELECT str_to_date('04 /30/2004', '%m /%d/%Y');\n",
            "SELECT str_to_date('04/30 /2004', '%m /%d /%Y');\n"
        ]
    },
    {
        "sql_id": 241,
        "database_name": "BUTTERTrans_241",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATE_FORMAT(\"0000-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '0000-01-01', 'Day DD Month YYYY') as valid_date;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE\n",
            "select str_to_date('04/30 /2004', '%m /%d /%Y'); -- STR_TO_DATE\n",
            "select str_to_date('04/30/2004 ', '%m/%d/%Y '); -- STR_TO_DATE\n"
        ],
        "target_related_schemas": [
            "SELECT str_to_date('04 /30/2004', '%m /%d/%Y');\n",
            "SELECT str_to_date('04/30 /2004', '%m /%d /%Y');\n",
            "SELECT str_to_date('04/30/2004 ', '%m/%d/%Y ');\n"
        ]
    },
    {
        "sql_id": 242,
        "database_name": "BUTTERTrans_242",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATE_FORMAT(\"0000-02-28\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '0000-02-28', 'Day DD Month YYYY') as valid_date;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE\n",
            "select str_to_date('04/30 /2004', '%m /%d /%Y'); -- STR_TO_DATE\n",
            "select str_to_date('04/30/2004 ', '%m/%d/%Y '); -- STR_TO_DATE\n",
            "SELECT DATE_FORMAT(\"0000-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT\n"
        ],
        "target_related_schemas": [
            "SELECT str_to_date('04 /30/2004', '%m /%d/%Y');\n",
            "SELECT str_to_date('04/30 /2004', '%m /%d /%Y');\n",
            "SELECT str_to_date('04/30/2004 ', '%m/%d/%Y ');\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '0000-01-01', 'Day DD Month YYYY') as valid_date;\n"
        ]
    },
    {
        "sql_id": 243,
        "database_name": "BUTTERTrans_243",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATE_FORMAT(\"2009-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2009-01-01', 'Day DD Month YYYY') as valid_date;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "select str_to_date('04 /30/2004', '%m /%d/%Y'); -- STR_TO_DATE\n",
            "select str_to_date('04/30 /2004', '%m /%d /%Y'); -- STR_TO_DATE\n",
            "select str_to_date('04/30/2004 ', '%m/%d/%Y '); -- STR_TO_DATE\n",
            "SELECT DATE_FORMAT(\"0000-01-01\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT\n",
            "SELECT DATE_FORMAT(\"0000-02-28\",'%W %d %M %Y') as valid_date; -- DATE_FORMAT\n"
        ],
        "target_related_schemas": [
            "SELECT str_to_date('04 /30/2004', '%m /%d/%Y');\n",
            "SELECT str_to_date('04/30 /2004', '%m /%d /%Y');\n",
            "SELECT str_to_date('04/30/2004 ', '%m/%d/%Y ');\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '0000-01-01', 'Day DD Month YYYY') as valid_date;\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '0000-02-28', 'Day DD Month YYYY') as valid_date;\n"
        ]
    },
    {
        "sql_id": 244,
        "database_name": "BUTTERTrans_244",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT",
        "target_query": "select '|' || text1 || '|' as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n"
        ]
    },
    {
        "sql_id": 245,
        "database_name": "BUTTERTrans_245",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
        "target_query": "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select '|' || text1 || '|' as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;\n"
        ]
    },
    {
        "sql_id": 246,
        "database_name": "BUTTERTrans_246",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select text1, length(text1) from t1 order by text1; -- LENGTH",
        "target_query": "select text1, octet_length(text1) from t1 order by text1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 14,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT\n",
            "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select '|' || text1 || '|' as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;\n",
            "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';\n"
        ]
    },
    {
        "sql_id": 247,
        "database_name": "BUTTERTrans_247",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat('|', text1, '|') from t1 order by text1; -- CONCAT",
        "target_query": "select '|' || text1 || '|' from t1 order by text1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT\n",
            "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT\n",
            "select text1, length(text1) from t1 order by text1; -- LENGTH\n",
            "insert into t1 values ('teststring ');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select '|' || text1 || '|' as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;\n",
            "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';\n",
            "select text1, octet_length(text1) from t1 order by text1;\n",
            "insert into t1 values ('teststring ');\n"
        ]
    },
    {
        "sql_id": 248,
        "database_name": "BUTTERTrans_248",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT",
        "target_query": "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT\n",
            "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT\n",
            "select text1, length(text1) from t1 order by text1; -- LENGTH\n",
            "insert into t1 values ('teststring ');\n",
            "select concat('|', text1, '|') from t1 order by text1; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select '|' || text1 || '|' as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;\n",
            "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';\n",
            "select text1, octet_length(text1) from t1 order by text1;\n",
            "insert into t1 values ('teststring ');\n",
            "select '|' || text1 || '|' from t1 order by text1;\n"
        ]
    },
    {
        "sql_id": 249,
        "database_name": "BUTTERTrans_249",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat('|', text1, '|') from t1 where text1='teststring'; -- CONCAT",
        "target_query": "select '|' || text1 || '|' from t1 where text1='teststring';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT\n",
            "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT\n",
            "select text1, length(text1) from t1 order by text1; -- LENGTH\n",
            "insert into t1 values ('teststring ');\n",
            "select concat('|', text1, '|') from t1 order by text1; -- CONCAT\n",
            "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select '|' || text1 || '|' as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;\n",
            "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';\n",
            "select text1, octet_length(text1) from t1 order by text1;\n",
            "insert into t1 values ('teststring ');\n",
            "select '|' || text1 || '|' from t1 order by text1;\n",
            "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';\n"
        ]
    },
    {
        "sql_id": 250,
        "database_name": "BUTTERTrans_250",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat('|', text1, '|') from t1 where text1='teststring '; -- CONCAT",
        "target_query": "select '|' || text1 || '|' from t1 where text1='teststring ';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select concat('|', text1, '|') as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c; -- CONCAT\n",
            "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT\n",
            "select text1, length(text1) from t1 order by text1; -- LENGTH\n",
            "insert into t1 values ('teststring ');\n",
            "select concat('|', text1, '|') from t1 order by text1; -- CONCAT\n",
            "select concat('|', text1, '|') from t1 where text1='teststring' or text1 > 'teststring\\\\t'; -- CONCAT\n",
            "select concat('|', text1, '|') from t1 where text1='teststring'; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (text1 varchar(32) not NULL);\n",
            "insert into t1 values ('teststring'), ('nothing'), ('teststring\\\\t');\n",
            "select '|' || text1 || '|' as c from t1 where text1='teststring' or text1 like 'teststring_%' order by c;\n",
            "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';\n",
            "select text1, octet_length(text1) from t1 order by text1;\n",
            "insert into t1 values ('teststring ');\n",
            "select '|' || text1 || '|' from t1 order by text1;\n",
            "select '|' || text1 || '|' from t1 where text1='teststring' or text1 > 'teststring\\\\t';\n",
            "select '|' || text1 || '|' from t1 where text1='teststring';\n"
        ]
    },
    {
        "sql_id": 251,
        "database_name": "BUTTERTrans_251",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CONCAT(\"Let's create some new events from the name of \", USER()); -- CONCAT, USER",
        "target_query": "SELECT 'Let''s create some new events from the name of ' || '';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "USER",
                "start_pos": 64,
                "end_pos": 68
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            },
            {
                "expression": "USER()",
                "description": "Returns the current MySQL user and host in the format 'username@hostname'.",
                "examples": [
                    "SELECT USER();"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            },
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 252,
        "database_name": "BUTTERTrans_252",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 27,
                "end_pos": 33
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n"
        ]
    },
    {
        "sql_id": 253,
        "database_name": "BUTTERTrans_253",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 27,
                "end_pos": 33
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n"
        ]
    },
    {
        "sql_id": 254,
        "database_name": "BUTTERTrans_254",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT",
        "target_query": "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n"
        ]
    },
    {
        "sql_id": 255,
        "database_name": "BUTTERTrans_255",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 INTEGER );\n",
            "INSERT INTO t1 VALUES (0), (1), (101);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a LONGTEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(f1 DATE);\n",
            "INSERT INTO t1 VALUES('2023-01-15 08:00:00');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n"
        ]
    },
    {
        "sql_id": 256,
        "database_name": "BUTTERTrans_256",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 INTEGER );\n",
            "INSERT INTO t1 VALUES (0), (1), (101);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a LONGTEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(f1 DATE);\n",
            "INSERT INTO t1 VALUES('2023-01-15 08:00:00');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));\n"
        ]
    },
    {
        "sql_id": 257,
        "database_name": "BUTTERTrans_257",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (3, REPEAT('x', 40003));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 INTEGER );\n",
            "INSERT INTO t1 VALUES (0), (1), (101);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a LONGTEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(f1 DATE);\n",
            "INSERT INTO t1 VALUES('2023-01-15 08:00:00');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));\n"
        ]
    },
    {
        "sql_id": 258,
        "database_name": "BUTTERTrans_258",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (4, REPEAT('x', 40005));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 INTEGER );\n",
            "INSERT INTO t1 VALUES (0), (1), (101);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a LONGTEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(f1 DATE);\n",
            "INSERT INTO t1 VALUES('2023-01-15 08:00:00');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));\n",
            "INSERT INTO t1 VALUES (3, REPEAT('x', 40003));\n"
        ]
    },
    {
        "sql_id": 259,
        "database_name": "BUTTERTrans_259",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (5, REPEAT('x', 40008));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 INTEGER );\n",
            "INSERT INTO t1 VALUES (0), (1), (101);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a LONGTEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (4, REPEAT('x', 40005)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(f1 DATE);\n",
            "INSERT INTO t1 VALUES('2023-01-15 08:00:00');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));\n",
            "INSERT INTO t1 VALUES (3, REPEAT('x', 40003));\n",
            "INSERT INTO t1 VALUES (4, REPEAT('x', 40005));\n"
        ]
    },
    {
        "sql_id": 260,
        "database_name": "BUTTERTrans_260",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (6, REPEAT('x', 40013));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 INTEGER );\n",
            "INSERT INTO t1 VALUES (0), (1), (101);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a LONGTEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (4, REPEAT('x', 40005)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (5, REPEAT('x', 40008)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(f1 DATE);\n",
            "INSERT INTO t1 VALUES('2023-01-15 08:00:00');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));\n",
            "INSERT INTO t1 VALUES (3, REPEAT('x', 40003));\n",
            "INSERT INTO t1 VALUES (4, REPEAT('x', 40005));\n",
            "INSERT INTO t1 VALUES (5, REPEAT('x', 40008));\n"
        ]
    },
    {
        "sql_id": 261,
        "database_name": "BUTTERTrans_261",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT a, LENGTH(b) FROM t1 ORDER BY a DESC; -- LENGTH",
        "target_query": "SELECT a, octet_length(b) FROM t1 ORDER BY a DESC;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 10,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 LONGBLOB);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) ); -- REPEAT\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) ); -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT CONCAT(f1, '') AS dummy FROM t1 ORDER BY dummy; -- CONCAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 INTEGER );\n",
            "INSERT INTO t1 VALUES (0), (1), (101);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a LONGTEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (3, REPEAT('x', 40003)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (4, REPEAT('x', 40005)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (5, REPEAT('x', 40008)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (6, REPEAT('x', 40013)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 INTEGER,f2 String);\n",
            "INSERT INTO t1 VALUES ( 2, REPEAT('-', 104) );\n",
            "INSERT INTO t1 VALUES ( 1, REPEAT('x', 104) );\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( f1 VARCHAR(100) );\n",
            "INSERT INTO t1 VALUES (''), (NULL), (''), (NULL);\n",
            "SELECT f1 || '' AS dummy FROM t1 ORDER BY dummy;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1(f1 DATE);\n",
            "INSERT INTO t1 VALUES('2023-01-15 08:00:00');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a TEXT);\n",
            "INSERT INTO t1 VALUES ('8');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 ( a INTEGER, b TEXT );\n",
            "INSERT INTO t1 VALUES (1, REPEAT('x', 40001));\n",
            "INSERT INTO t1 VALUES (2, REPEAT('x', 40002));\n",
            "INSERT INTO t1 VALUES (3, REPEAT('x', 40003));\n",
            "INSERT INTO t1 VALUES (4, REPEAT('x', 40005));\n",
            "INSERT INTO t1 VALUES (5, REPEAT('x', 40008));\n",
            "INSERT INTO t1 VALUES (6, REPEAT('x', 40013));\n"
        ]
    },
    {
        "sql_id": 262,
        "database_name": "BUTTERTrans_262",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3; -- LENGTH",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) > 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 31,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));\n",
            "insert into t1 values (1,1,1,1,'america', 'america'),(2,2,2,2,'england','england');\n",
            "insert into t1 select col1_idx+2,col2_idx+2,col3+2,col4+2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2,col2_idx+2*2,col3+2*2,col4+2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2,col2_idx+2*2*2,col3+2*2*2,col4+2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2,col2_idx+2*2*2*2,col3+2*2*2*2,col4+2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2,col2_idx+2*2*2*2*2,col3+2*2*2*2*2,col4+2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2*2,col2_idx+2*2*2*2*2*2,col3+2*2*2*2*2*2,col4+2*2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'america','america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'england america','england america' from t1;\n",
            "insert ignore into t1 select col1_idx,col2_idx,col3,col4,'germany england america','germany england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'norway sweden','norway sweden' from t1 limit 5;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));\n",
            "insert into t1 values (1,1,1,1,'america', 'america'),(2,2,2,2,'england','england');\n",
            "insert into t1 select col1_idx+2,col2_idx+2,col3+2,col4+2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2,col2_idx+2*2,col3+2*2,col4+2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2,col2_idx+2*2*2,col3+2*2*2,col4+2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2,col2_idx+2*2*2*2,col3+2*2*2*2,col4+2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2,col2_idx+2*2*2*2*2,col3+2*2*2*2*2,col4+2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2*2,col2_idx+2*2*2*2*2*2,col3+2*2*2*2*2*2,col4+2*2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'america','america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'england america','england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'germany england america','germany england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'norway sweden','norway sweden' from t1 limit 5;\n"
        ]
    },
    {
        "sql_id": 263,
        "database_name": "BUTTERTrans_263",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3; -- LENGTH",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) = 3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 31,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));\n",
            "insert into t1 values (1,1,1,1,'america', 'america'),(2,2,2,2,'england','england');\n",
            "insert into t1 select col1_idx+2,col2_idx+2,col3+2,col4+2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2,col2_idx+2*2,col3+2*2,col4+2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2,col2_idx+2*2*2,col3+2*2*2,col4+2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2,col2_idx+2*2*2*2,col3+2*2*2*2,col4+2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2,col2_idx+2*2*2*2*2,col3+2*2*2*2*2,col4+2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2*2,col2_idx+2*2*2*2*2*2,col3+2*2*2*2*2*2,col4+2*2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'america','america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'england america','england america' from t1;\n",
            "insert ignore into t1 select col1_idx,col2_idx,col3,col4,'germany england america','germany england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'norway sweden','norway sweden' from t1 limit 5;\n",
            "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3; -- LENGTH\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));\n",
            "insert into t1 values (1,1,1,1,'america', 'america'),(2,2,2,2,'england','england');\n",
            "insert into t1 select col1_idx+2,col2_idx+2,col3+2,col4+2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2,col2_idx+2*2,col3+2*2,col4+2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2,col2_idx+2*2*2,col3+2*2*2,col4+2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2,col2_idx+2*2*2*2,col3+2*2*2*2,col4+2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2,col2_idx+2*2*2*2*2,col3+2*2*2*2*2,col4+2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2*2,col2_idx+2*2*2*2*2*2,col3+2*2*2*2*2*2,col4+2*2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'america','america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'england america','england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'germany england america','germany england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'norway sweden','norway sweden' from t1 limit 5;\n",
            "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) > 3;\n"
        ]
    },
    {
        "sql_id": 264,
        "database_name": "BUTTERTrans_264",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NULL; -- LENGTH",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 31,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));\n",
            "insert into t1 values (1,1,1,1,'america', 'america'),(2,2,2,2,'england','england');\n",
            "insert into t1 select col1_idx+2,col2_idx+2,col3+2,col4+2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2,col2_idx+2*2,col3+2*2,col4+2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2,col2_idx+2*2*2,col3+2*2*2,col4+2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2,col2_idx+2*2*2*2,col3+2*2*2*2,col4+2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2,col2_idx+2*2*2*2*2,col3+2*2*2*2*2,col4+2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2*2,col2_idx+2*2*2*2*2*2,col3+2*2*2*2*2*2,col4+2*2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'america','america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'england america','england america' from t1;\n",
            "insert ignore into t1 select col1_idx,col2_idx,col3,col4,'germany england america','germany england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'norway sweden','norway sweden' from t1 limit 5;\n",
            "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3; -- LENGTH\n",
            "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3; -- LENGTH\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));\n",
            "insert into t1 values (1,1,1,1,'america', 'america'),(2,2,2,2,'england','england');\n",
            "insert into t1 select col1_idx+2,col2_idx+2,col3+2,col4+2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2,col2_idx+2*2,col3+2*2,col4+2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2,col2_idx+2*2*2,col3+2*2*2,col4+2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2,col2_idx+2*2*2*2,col3+2*2*2*2,col4+2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2,col2_idx+2*2*2*2*2,col3+2*2*2*2*2,col4+2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2*2,col2_idx+2*2*2*2*2*2,col3+2*2*2*2*2*2,col4+2*2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'america','america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'england america','england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'germany england america','germany england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'norway sweden','norway sweden' from t1 limit 5;\n",
            "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) > 3;\n",
            "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) = 3;\n"
        ]
    },
    {
        "sql_id": 265,
        "database_name": "BUTTERTrans_265",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NOT NULL; -- LENGTH",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 31,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));\n",
            "insert into t1 values (1,1,1,1,'america', 'america'),(2,2,2,2,'england','england');\n",
            "insert into t1 select col1_idx+2,col2_idx+2,col3+2,col4+2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2,col2_idx+2*2,col3+2*2,col4+2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2,col2_idx+2*2*2,col3+2*2*2,col4+2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2,col2_idx+2*2*2*2,col3+2*2*2*2,col4+2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2,col2_idx+2*2*2*2*2,col3+2*2*2*2*2,col4+2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2*2,col2_idx+2*2*2*2*2*2,col3+2*2*2*2*2*2,col4+2*2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'america','america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'england america','england america' from t1;\n",
            "insert ignore into t1 select col1_idx,col2_idx,col3,col4,'germany england america','germany england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'norway sweden','norway sweden' from t1 limit 5;\n",
            "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) > 3; -- LENGTH\n",
            "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) = 3; -- LENGTH\n",
            "EXPLAIN SELECT * FROM t1 WHERE length(t1.vc) IS NULL; -- LENGTH\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(col1_idx INT DEFAULT NULL,col2_idx INT DEFAULT NULL,col3 INT DEFAULT NULL,col4 INT NOT NULL,vc VARCHAR(30),vc_ft VARCHAR(30));\n",
            "insert into t1 values (1,1,1,1,'america', 'america'),(2,2,2,2,'england','england');\n",
            "insert into t1 select col1_idx+2,col2_idx+2,col3+2,col4+2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2,col2_idx+2*2,col3+2*2,col4+2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2,col2_idx+2*2*2,col3+2*2*2,col4+2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2,col2_idx+2*2*2*2,col3+2*2*2*2,col4+2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2,col2_idx+2*2*2*2*2,col3+2*2*2*2*2,col4+2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx+2*2*2*2*2*2,col2_idx+2*2*2*2*2*2,col3+2*2*2*2*2*2,col4+2*2*2*2*2*2,vc,vc_ft from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'america','america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'england america','england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'germany england america','germany england america' from t1;\n",
            "insert into t1 select col1_idx,col2_idx,col3,col4,'norway sweden','norway sweden' from t1 limit 5;\n",
            "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) > 3;\n",
            "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) = 3;\n",
            "EXPLAIN SELECT * FROM t1 WHERE octet_length(t1.vc) IS NULL;\n"
        ]
    },
    {
        "sql_id": 266,
        "database_name": "BUTTERTrans_266",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t VALUES(REPEAT(x'0a',1000)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES(REPEAT(x'0a',1000));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 21,
                "end_pos": 27
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(id int, vbin1 varbinary(32), vbin2 varbinary(32));\n",
            "INSERT INTO t VALUES(1, x'59', x'6a'),(2, x'5939', x'6ac3'),(3, x'5939a998', x'6ac35d2a'),(4, x'5939a99861154f35', x'6ac35d2a3ab34bda'),(5, x'5939a99861154f3587d5440618e9b28b', x'6ac35d2a3ab34bda8ac412ea0141852c'),(6, x'5939a99861154f3587d5440618e9b28b166181c5ca514ab1b8e9c970ae5e421a', x'6ac35d2a3ab34bda8ac412ea0141852c3c8e38bb19934a7092a40bb19db13a80'),(7, x'5939a99861154f3587d5440618e9b28b', x'8ac412ea0141852c'),(8, x'5939a99861154f35', x'6ac35d2a3ab34bda8ac412ea0141852c');\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t(b BLOB);\n",
            "INSERT INTO t VALUES(NULL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(id int,vbin1 blob,vbin2 blob);\n",
            "INSERT INTO t VALUES(1,x'59',x'6a'),(2,x'5939',x'6ac3'),(3,x'5939a998',x'6ac35d2a'),(4,x'5939a99861154f35',x'6ac35d2a3ab34bda'),(5,x'5939a99861154f3587d5440618e9b28b',x'6ac35d2a3ab34bda8ac412ea0141852c'),(6,x'5939a99861154f3587d5440618e9b28b166181c5ca514ab1b8e9c970ae5e421a',x'6ac35d2a3ab34bda8ac412ea0141852c3c8e38bb19934a7092a40bb19db13a80'),(7,x'5939a99861154f3587d5440618e9b28b',x'8ac412ea0141852c'),(8,x'5939a99861154f35',x'6ac35d2a3ab34bda8ac412ea0141852c');\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t(b BLOB);\n",
            "INSERT INTO t VALUES(NULL);\n"
        ]
    },
    {
        "sql_id": 267,
        "database_name": "BUTTERTrans_267",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t VALUES(1, REPEAT('2', 32750), REPEAT('1', 32750)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES(1,REPEAT('2',32750),REPEAT('1',32750));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 24,
                "end_pos": 30
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 44,
                "end_pos": 50
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(id int, vbin1 varbinary(32), vbin2 varbinary(32));\n",
            "INSERT INTO t VALUES(1, x'59', x'6a'),(2, x'5939', x'6ac3'),(3, x'5939a998', x'6ac35d2a'),(4, x'5939a99861154f35', x'6ac35d2a3ab34bda'),(5, x'5939a99861154f3587d5440618e9b28b', x'6ac35d2a3ab34bda8ac412ea0141852c'),(6, x'5939a99861154f3587d5440618e9b28b166181c5ca514ab1b8e9c970ae5e421a', x'6ac35d2a3ab34bda8ac412ea0141852c3c8e38bb19934a7092a40bb19db13a80'),(7, x'5939a99861154f3587d5440618e9b28b', x'8ac412ea0141852c'),(8, x'5939a99861154f35', x'6ac35d2a3ab34bda8ac412ea0141852c');\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t(b BLOB);\n",
            "INSERT INTO t VALUES(NULL);\n",
            "INSERT INTO t VALUES(REPEAT(x'0a',1000)); -- REPEAT\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t (gid int, a varbinary(514));\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t (gid int, a varbinary(511));\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t (gid int, a varbinary(65500), b blob);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(id int,vbin1 blob,vbin2 blob);\n",
            "INSERT INTO t VALUES(1,x'59',x'6a'),(2,x'5939',x'6ac3'),(3,x'5939a998',x'6ac35d2a'),(4,x'5939a99861154f35',x'6ac35d2a3ab34bda'),(5,x'5939a99861154f3587d5440618e9b28b',x'6ac35d2a3ab34bda8ac412ea0141852c'),(6,x'5939a99861154f3587d5440618e9b28b166181c5ca514ab1b8e9c970ae5e421a',x'6ac35d2a3ab34bda8ac412ea0141852c3c8e38bb19934a7092a40bb19db13a80'),(7,x'5939a99861154f3587d5440618e9b28b',x'8ac412ea0141852c'),(8,x'5939a99861154f35',x'6ac35d2a3ab34bda8ac412ea0141852c');\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t(b BLOB);\n",
            "INSERT INTO t VALUES(NULL);\n",
            "INSERT INTO t VALUES(REPEAT(x'0a',1000));\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t (gid int,a blob);\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t (gid int,a blob);\n",
            "DROP TABLE t;\n",
            "CREATE TABLE t (gid int,a blob,b blob);\n"
        ]
    },
    {
        "sql_id": 268,
        "database_name": "BUTTERTrans_268",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert t1 values (NULL), ('A\\0\\0\\0BBBBBBBB'), (SPACE(50000)), (SPACE(50000)); -- SPACE",
        "target_query": "insert into t1 values (NULL), (X'410000004242424242424242'), (CAST(REPEAT(' ', 50000) AS BLOB)), (CAST(REPEAT(' ', 50000) AS BLOB));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "SPACE",
                "start_pos": 47,
                "end_pos": 52
            },
            {
                "dialect_token": "SPACE",
                "start_pos": 63,
                "end_pos": 68
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SPACE(n)",
                "description": "Returns a string consisting of n space characters.",
                "examples": [
                    "SELECT LENGTH(SPACE(5));",
                    "SELECT CONCAT('A', SPACE(3), 'B');",
                    "SELECT CONCAT(REPEAT('-', 2), SPACE(4), '!');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(' ', n)",
                "description": "Returns a string consisting of n space characters by repeating a space character. String concatenation is performed using the '||' operator.",
                "examples": [
                    "SELECT LENGTH(REPEAT(' ', 5));",
                    "SELECT 'A' || REPEAT(' ', 3) || 'B';",
                    "SELECT REPEAT('-', 2) || REPEAT(' ', 4) || '!';"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a BLOB);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a BLOB);\n"
        ]
    },
    {
        "sql_id": 269,
        "database_name": "BUTTERTrans_269",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select length(a) from t1; -- LENGTH",
        "target_query": "select octet_length(a) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a BLOB);\n",
            "insert t1 values (NULL), ('A\\0\\0\\0BBBBBBBB'), (SPACE(50000)), (SPACE(50000)); -- SPACE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a BLOB);\n",
            "insert into t1 values (NULL), (X'410000004242424242424242'), (CAST(REPEAT(' ', 50000) AS BLOB)), (CAST(REPEAT(' ', 50000) AS BLOB));\n"
        ]
    },
    {
        "sql_id": 270,
        "database_name": "BUTTERTrans_270",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT",
        "target_query": "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n"
        ]
    },
    {
        "sql_id": 271,
        "database_name": "BUTTERTrans_271",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', -4); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 272,
        "database_name": "BUTTERTrans_272",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', -4.5); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n"
        ]
    },
    {
        "sql_id": 273,
        "database_name": "BUTTERTrans_273",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', -(4 + 1)); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n"
        ]
    },
    {
        "sql_id": 274,
        "database_name": "BUTTERTrans_274",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', 4 - 5); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n",
            "select 'a' union select concat('a', -(4 + 1)); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);\n"
        ]
    },
    {
        "sql_id": 275,
        "database_name": "BUTTERTrans_275",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', -'3'); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-3 AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n",
            "select 'a' union select concat('a', -(4 + 1)); -- CONCAT\n",
            "select 'a' union select concat('a', 4 - 5); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);\n"
        ]
    },
    {
        "sql_id": 276,
        "database_name": "BUTTERTrans_276",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', -concat('3',4)); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-('3' || CAST(4 AS STRING)) AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 37,
                "end_pos": 43
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n",
            "select 'a' union select concat('a', -(4 + 1)); -- CONCAT\n",
            "select 'a' union select concat('a', 4 - 5); -- CONCAT\n",
            "select 'a' union select concat('a', -'3'); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-3 AS STRING);\n"
        ]
    },
    {
        "sql_id": 277,
        "database_name": "BUTTERTrans_277",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', -0); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-0 AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n",
            "select 'a' union select concat('a', -(4 + 1)); -- CONCAT\n",
            "select 'a' union select concat('a', 4 - 5); -- CONCAT\n",
            "select 'a' union select concat('a', -'3'); -- CONCAT\n",
            "select 'a' union select concat('a', -concat('3',4)); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-3 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-('3' || CAST(4 AS STRING)) AS STRING);\n"
        ]
    },
    {
        "sql_id": 278,
        "database_name": "BUTTERTrans_278",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', -0.0); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-0.0 AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n",
            "select 'a' union select concat('a', -(4 + 1)); -- CONCAT\n",
            "select 'a' union select concat('a', 4 - 5); -- CONCAT\n",
            "select 'a' union select concat('a', -'3'); -- CONCAT\n",
            "select 'a' union select concat('a', -concat('3',4)); -- CONCAT\n",
            "select 'a' union select concat('a', -0); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-3 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-('3' || CAST(4 AS STRING)) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0 AS STRING);\n"
        ]
    },
    {
        "sql_id": 279,
        "database_name": "BUTTERTrans_279",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 'a' union select concat('a', -0.0000); -- CONCAT",
        "target_query": "SELECT 'a' UNION SELECT 'a' || CAST(-0.0000 AS STRING);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 24,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n",
            "select 'a' union select concat('a', -(4 + 1)); -- CONCAT\n",
            "select 'a' union select concat('a', 4 - 5); -- CONCAT\n",
            "select 'a' union select concat('a', -'3'); -- CONCAT\n",
            "select 'a' union select concat('a', -concat('3',4)); -- CONCAT\n",
            "select 'a' union select concat('a', -0); -- CONCAT\n",
            "select 'a' union select concat('a', -0.0); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-3 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-('3' || CAST(4 AS STRING)) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0.0 AS STRING);\n"
        ]
    },
    {
        "sql_id": 280,
        "database_name": "BUTTERTrans_280",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat((select x from (select 'a' as x) as t1 ),(select y from (select 'b' as y) as t2 )) from (select 1 union select 2 )as t3; -- CONCAT",
        "target_query": "SELECT (SELECT x FROM (SELECT 'a' AS x) AS t1) || (SELECT y FROM (SELECT 'b' AS y) AS t2) FROM (SELECT 1 UNION SELECT 2) AS t3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n",
            "select 'a' union select concat('a', -(4 + 1)); -- CONCAT\n",
            "select 'a' union select concat('a', 4 - 5); -- CONCAT\n",
            "select 'a' union select concat('a', -'3'); -- CONCAT\n",
            "select 'a' union select concat('a', -concat('3',4)); -- CONCAT\n",
            "select 'a' union select concat('a', -0); -- CONCAT\n",
            "select 'a' union select concat('a', -0.0); -- CONCAT\n",
            "select 'a' union select concat('a', -0.0000); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-3 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-('3' || CAST(4 AS STRING)) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0.0 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0.0000 AS STRING);\n"
        ]
    },
    {
        "sql_id": 281,
        "database_name": "BUTTERTrans_281",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat(f1, 2) a from t1 union select 'x' a from t1; -- CONCAT",
        "target_query": "SELECT f1 || CAST(2 AS STRING) AS a FROM t1 UNION SELECT 'x' AS a FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a char(4), b double, c date, d tinyint(4));\n",
            "insert into t1 values ('AAAA', 105, '2003-03-01', 1);\n",
            "select * from t1 where concat(A,C,B,D) = 'AAAA2003-03-011051'; -- CONCAT\n",
            "drop table t1;\n",
            "select 'a' union select concat('a', -4); -- CONCAT\n",
            "select 'a' union select concat('a', -4.5); -- CONCAT\n",
            "select 'a' union select concat('a', -(4 + 1)); -- CONCAT\n",
            "select 'a' union select concat('a', 4 - 5); -- CONCAT\n",
            "select 'a' union select concat('a', -'3'); -- CONCAT\n",
            "select 'a' union select concat('a', -concat('3',4)); -- CONCAT\n",
            "select 'a' union select concat('a', -0); -- CONCAT\n",
            "select 'a' union select concat('a', -0.0); -- CONCAT\n",
            "select 'a' union select concat('a', -0.0000); -- CONCAT\n",
            "select concat((select x from (select 'a' as x) as t1 ),(select y from (select 'b' as y) as t2 )) from (select 1 union select 2 )as t3; -- CONCAT\n",
            "create table t1(f1 varchar(6));\n",
            "insert into t1 values (\"123456\");\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a CHAR(4), b DOUBLE, c DATE, d TINYINT);\n",
            "INSERT INTO t1 VALUES ('AAAA', 105, '2003-03-01', 1);\n",
            "SELECT * FROM t1 WHERE a || c || CAST(b AS STRING) || CAST(d AS STRING) = 'AAAA2003-03-011051';\n",
            "DROP TABLE t1;\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-4.5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-(4 + 1) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(4 - 5 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-3 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-('3' || CAST(4 AS STRING)) AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0.0 AS STRING);\n",
            "SELECT 'a' UNION SELECT 'a' || CAST(-0.0000 AS STRING);\n",
            "SELECT (SELECT x FROM (SELECT 'a' AS x) AS t1) || (SELECT y FROM (SELECT 'b' AS y) AS t2) FROM (SELECT 1 UNION SELECT 2) AS t3;\n",
            "CREATE TABLE t1(f1 VARCHAR(6));\n",
            "INSERT INTO t1 VALUES ('123456');\n"
        ]
    },
    {
        "sql_id": 282,
        "database_name": "BUTTERTrans_282",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
        "target_query": "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
                "description": "Adds a time interval to a date or datetime value.",
                "examples": [
                    "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
                    "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
                    "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime + INTERVAL 'expr' unit",
                "description": "Adds an interval to a datetime using standard SQL interval syntax.",
                "examples": [
                    "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10' DAY;",
                    "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3' HOUR;",
                    "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1' MONTH;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n"
        ]
    },
    {
        "sql_id": 283,
        "database_name": "BUTTERTrans_283",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL NULL DAY)); -- DATE_ADD",
        "target_query": "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1' DAY);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
                "description": "Adds a time interval to a date or datetime value.",
                "examples": [
                    "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
                    "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
                    "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime + INTERVAL 'expr' unit",
                "description": "Adds an interval to a datetime using standard SQL interval syntax.",
                "examples": [
                    "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10' DAY;",
                    "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3' HOUR;",
                    "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1' MONTH;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);\n"
        ]
    },
    {
        "sql_id": 284,
        "database_name": "BUTTERTrans_284",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD",
        "target_query": "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
                "description": "Adds a time interval to a date or datetime value.",
                "examples": [
                    "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
                    "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
                    "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime + INTERVAL 'expr' unit",
                "description": "Adds an interval to a datetime using standard SQL interval syntax.",
                "examples": [
                    "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10' DAY;",
                    "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3' HOUR;",
                    "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1' MONTH;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD\n",
            "insert into t1 values (date_add('2000-01-04', INTERVAL NULL DAY)); -- DATE_ADD\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);\n",
            "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1' DAY);\n"
        ]
    },
    {
        "sql_id": 285,
        "database_name": "BUTTERTrans_285",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values (date_add('2000-01-04', INTERVAL 1 DAY)); -- DATE_ADD",
        "target_query": "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1' DAY);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_ADD(datetime_expr, INTERVAL expr unit)",
                "description": "Adds a time interval to a date or datetime value.",
                "examples": [
                    "SELECT DATE_ADD('2020-01-01', INTERVAL 10 DAY);",
                    "SELECT DATE_ADD('2020-01-01 12:00:00', INTERVAL 3 HOUR);",
                    "SELECT DATE_ADD('2020-12-31', INTERVAL 1 MONTH);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "datetime + INTERVAL 'expr' unit",
                "description": "Adds an interval to a datetime using standard SQL interval syntax.",
                "examples": [
                    "SELECT TIMESTAMP '2020-01-01' + INTERVAL '10' DAY;",
                    "SELECT TIMESTAMP '2020-01-01 12:00:00' + INTERVAL '3' HOUR;",
                    "SELECT TIMESTAMP '2020-12-31' + INTERVAL '1' MONTH;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD\n",
            "insert into t1 values (date_add('2000-01-04', INTERVAL NULL DAY)); -- DATE_ADD\n",
            "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);\n",
            "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1' DAY);\n",
            "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);\n"
        ]
    },
    {
        "sql_id": 286,
        "database_name": "BUTTERTrans_286",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATE(ts) = CURRENT_DATE + INTERVAL '1' DAY AS is_tomorrow, TIME(ts)FROM (SELECT ADDDATE(TIME'00:00:00', INTERVAL 1 DAY) AS ts) AS dt; -- DATE",
        "target_query": "SELECT CAST(ts AS DATE) = CURRENT_DATE + INTERVAL '1' DAY AS is_tomorrow,CAST(ts AS TIME) AS time_component FROM(SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1' DAY AS ts) AS dt;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE()",
                "description": "In MySQL, the DATE function extracts the date part from a DATETIME or TIMESTAMP value.",
                "examples": [
                    "SELECT DATE('2023-05-01 12:34:56') AS result;",
                    "SELECT DATE(NOW()) AS current_date_result;",
                    "SELECT DATE(CAST('2023-05-01' AS DATETIME)) AS date_from_datetime;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST()",
                "description": "MonetDB uses the CAST function to extract a DATE from a DATETIME or TIMESTAMP.",
                "examples": [
                    "SELECT CAST('2023-05-01 12:34:56' AS DATE) AS result;",
                    "SELECT CAST(NOW() AS DATE) AS current_date_result;",
                    "SELECT CAST('2023-05-01' AS DATE) AS date_from_datetime;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD\n",
            "insert into t1 values (date_add('2000-01-04', INTERVAL NULL DAY)); -- DATE_ADD\n",
            "insert into t1 values (date_add(NULL, INTERVAL 1 DAY)); -- DATE_ADD\n",
            "insert into t1 values (date_add('2000-01-04', INTERVAL 1 DAY)); -- DATE_ADD\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (d date);\n",
            "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);\n",
            "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1' DAY);\n",
            "insert into t1 values (CAST(NULL AS DATE) + INTERVAL '1' DAY);\n",
            "insert into t1 values (TIMESTAMP '2000-01-04' + INTERVAL '1' DAY);\n",
            "drop table t1;\n"
        ]
    },
    {
        "sql_id": 287,
        "database_name": "BUTTERTrans_287",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t1 where isnull(to_days(mydate)); -- ISNULL, TO_DAYS",
        "target_query": "SELECT * FROM t1 WHERE mydate IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "ISNULL",
                "start_pos": 23,
                "end_pos": 29
            },
            {
                "dialect_token": "TO_DAYS",
                "start_pos": 30,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            },
            {
                "expression": "TO_DAYS(date)",
                "description": "Returns the number of days since 0000-01-01 for a given date.",
                "examples": [
                    "SELECT TO_DAYS('2024-05-07');",
                    "SELECT TO_DAYS(CURDATE());",
                    "SELECT TO_DAYS('1999-12-31 23:59:59');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL construct for detecting NULL values.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 * NULL) IS NULL;",
                    "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
                ]
            },
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (id int primary key not null, mydate date not null);\n",
            "insert into t1 values (0,\"2002-05-01\"),(1,\"2002-05-01\"),(2,\"2002-05-01\");\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT PRIMARY KEY NOT NULL GENERATED ALWAYS AS IDENTITY, mydate DATE NOT NULL);\n",
            "INSERT INTO t1 VALUES (0, '2002-05-01'), (0, '2002-05-01'), (0, '2002-05-01');\n"
        ]
    },
    {
        "sql_id": 288,
        "database_name": "BUTTERTrans_288",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t3 left join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk); -- ISNULL",
        "target_query": "SELECT * FROM t3 LEFT JOIN (t2 outr2 JOIN t2 outr JOIN t1) ON (outr.pk = t3.pk) AND (t1.col_int_key = t3.pk) AND t1.col_date_key IS NULL AND (outr2.pk <> t3.pk);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "ISNULL",
                "start_pos": 111,
                "end_pos": 117
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL construct for detecting NULL values.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 * NULL) IS NULL;",
                    "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (id int primary key not null, mydate date not null);\n",
            "insert into t1 values (0,\"2002-05-01\"),(1,\"2002-05-01\"),(2,\"2002-05-01\");\n",
            "select * from t1 where isnull(to_days(mydate)); -- ISNULL, TO_DAYS\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (pk int PRIMARY KEY NOT NULL,col_int_key INT NOT NULL,col_date_key date NOT NULL);\n",
            "INSERT IGNORE INTO t1 VALUES (14,4,'1919-01-01'), (15,2,'2003-01-13'),(16,5,'2006-07-07'), (17,3,'1919-01-01');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (pk INT PRIMARY KEY NOT NULL);\n",
            "INSERT INTO t2 VALUES (1), (2), (3);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(pk INT NOT NULL);\n",
            "INSERT INTO t3 VALUES(1),(2),(3);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT PRIMARY KEY NOT NULL GENERATED ALWAYS AS IDENTITY, mydate DATE NOT NULL);\n",
            "INSERT INTO t1 VALUES (0, '2002-05-01'), (0, '2002-05-01'), (0, '2002-05-01');\n",
            "SELECT * FROM t1 WHERE mydate IS NULL;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (pk INT PRIMARY KEY NOT NULL, col_int_key INT NOT NULL, col_date_key DATE NOT NULL);\n",
            "INSERT INTO t1 VALUES (14, 4, '0000-00-00'), (15, 2, '2003-01-13'), (16, 5, '2006-07-07'), (17, 3, '0000-00-00');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (pk INT PRIMARY KEY NOT NULL);\n",
            "INSERT INTO t2 VALUES (1), (2), (3);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3 (pk INT NOT NULL);\n",
            "INSERT INTO t3 VALUES (1), (2), (3);\n"
        ]
    },
    {
        "sql_id": 289,
        "database_name": "BUTTERTrans_289",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t3 join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk) ; -- ISNULL",
        "target_query": "SELECT * FROM t3 JOIN (t2 outr2 JOIN t2 outr JOIN t1) ON (outr.pk = t3.pk) AND (t1.col_int_key = t3.pk) AND t1.col_date_key IS NULL AND (outr2.pk <> t3.pk);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "ISNULL",
                "start_pos": 106,
                "end_pos": 112
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL construct for detecting NULL values.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 * NULL) IS NULL;",
                    "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (id int primary key not null, mydate date not null);\n",
            "insert into t1 values (0,\"2002-05-01\"),(1,\"2002-05-01\"),(2,\"2002-05-01\");\n",
            "select * from t1 where isnull(to_days(mydate)); -- ISNULL, TO_DAYS\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (pk int PRIMARY KEY NOT NULL,col_int_key INT NOT NULL,col_date_key date NOT NULL);\n",
            "INSERT IGNORE INTO t1 VALUES (14,4,'1919-01-01'), (15,2,'2003-01-13'),(16,5,'2006-07-07'), (17,3,'1919-01-01');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (pk INT PRIMARY KEY NOT NULL);\n",
            "INSERT INTO t2 VALUES (1), (2), (3);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(pk INT NOT NULL);\n",
            "INSERT INTO t3 VALUES(1),(2),(3);\n",
            "select * from t3 left join(t2 outr2 join t2 outr join t1)on (outr.pk = t3.pk) and (t1.col_int_key = t3.pk) and isnull(t1.col_date_key)and (outr2.pk <> t3.pk); -- ISNULL\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (id INT PRIMARY KEY NOT NULL GENERATED ALWAYS AS IDENTITY, mydate DATE NOT NULL);\n",
            "INSERT INTO t1 VALUES (0, '2002-05-01'), (0, '2002-05-01'), (0, '2002-05-01');\n",
            "SELECT * FROM t1 WHERE mydate IS NULL;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (pk INT PRIMARY KEY NOT NULL, col_int_key INT NOT NULL, col_date_key DATE NOT NULL);\n",
            "INSERT INTO t1 VALUES (14, 4, '0000-00-00'), (15, 2, '2003-01-13'), (16, 5, '2006-07-07'), (17, 3, '0000-00-00');\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (pk INT PRIMARY KEY NOT NULL);\n",
            "INSERT INTO t2 VALUES (1), (2), (3);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3 (pk INT NOT NULL);\n",
            "INSERT INTO t3 VALUES (1), (2), (3);\n",
            "SELECT * FROM t3 LEFT JOIN (t2 outr2 JOIN t2 outr JOIN t1) ON (outr.pk = t3.pk) AND (t1.col_int_key = t3.pk) AND t1.col_date_key IS NULL AND (outr2.pk <> t3.pk);\n"
        ]
    },
    {
        "sql_id": 290,
        "database_name": "BUTTERTrans_290",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "explain select * from t1 where a like concat('abc','%'); -- CONCAT",
        "target_query": "explain select * from t1 where a like 'abc' || '%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 38,
                "end_pos": 44
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(10));\n",
            "insert into t1 values (\"a\"),(\"abc\"),(\"abcd\"),(\"hello\"),(\"test\");\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(10));\n",
            "INSERT INTO t1 VALUES ('a'), ('abc'), ('abcd'), ('hello'), ('test');\n"
        ]
    },
    {
        "sql_id": 291,
        "database_name": "BUTTERTrans_291",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t1 where a like concat(\"abc\",\"%\"); -- CONCAT",
        "target_query": "select * from t1 where a like 'abc' || '%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 30,
                "end_pos": 36
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(10));\n",
            "insert into t1 values (\"a\"),(\"abc\"),(\"abcd\"),(\"hello\"),(\"test\");\n",
            "explain select * from t1 where a like concat('abc','%'); -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(10));\n",
            "INSERT INTO t1 VALUES ('a'), ('abc'), ('abcd'), ('hello'), ('test');\n",
            "explain select * from t1 where a like 'abc' || '%';\n"
        ]
    },
    {
        "sql_id": 292,
        "database_name": "BUTTERTrans_292",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN",
        "target_query": "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LN",
                "start_pos": 7,
                "end_pos": 9
            },
            {
                "dialect_token": "LN",
                "start_pos": 23,
                "end_pos": 25
            },
            {
                "dialect_token": "LN",
                "start_pos": 39,
                "end_pos": 41
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LN(x)",
                "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
                "examples": [
                    "select ln(exp(10));",
                    "select exp(ln(sqrt(10)) * 2);",
                    "select ln(-1);",
                    "select ln(0);",
                    "select ln(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LN(x)",
                "description": "MonetDB's LN() function returns the natural logarithm of x. It returns NaN for negative or zero values, similar to ClickHouse.",
                "examples": [
                    "select ln(exp(10));",
                    "select exp(ln(sqrt(10)) * 2);",
                    "select ln(NULL);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 293,
        "database_name": "BUTTERTrans_293",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select log2(8),log2(15),log2(NULL); -- LOG2",
        "target_query": "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LOG2",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "LOG2",
                "start_pos": 15,
                "end_pos": 19
            },
            {
                "dialect_token": "LOG2",
                "start_pos": 24,
                "end_pos": 28
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LOG2(number)",
                "description": "Returns the logarithm of a number with base 2. Returns NULL for zero or negative numbers.",
                "examples": [
                    "SELECT LOG2(8);",
                    "SELECT LOG2(15);",
                    "SELECT LOG2(-2);",
                    "SELECT LOG2(0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "log(number) / log(2)",
                "description": "Computes the logarithm of a number with base 2 using the formula log(number) / log(2). Returns NULL for zero or negative numbers.",
                "examples": [
                    "SELECT log(8) / log(2);",
                    "SELECT log(15) / log(2);"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n"
        ]
    },
    {
        "sql_id": 294,
        "database_name": "BUTTERTrans_294",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select pow(10,log10(10)),power(2,4); -- POW, POWER",
        "target_query": "select POWER(10,log10(10)),POWER(2,4);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "POW",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "POWER",
                "start_pos": 25,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "POW(3, 3)",
                "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
                "examples": [
                    "SELECT POW(3, 3);",
                    "SELECT POW(5, 4);",
                    "SELECT POW(x, 2) FROM some_table;"
                ]
            },
            {
                "expression": "SELECT POW(10, 2), POWER(2, 3), POWER(3, 3);",
                "description": "Calculates the power of a number: POW(10, 2) returns 100, POWER(2, 3) returns 8, POWER(3, 3) returns 27.",
                "examples": [
                    "SELECT POW(5, 2);",
                    "SELECT POWER(3, 4);",
                    "SELECT POWER(10, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POWER(3, 3)",
                "description": "MonetDB supports the POWER() function to calculate x raised to the power of y, where x and y are typically INTEGER or FLOAT types.",
                "examples": [
                    "SELECT POWER(3, 3);",
                    "SELECT POWER(5, 4);",
                    "SELECT POWER(x, 2) FROM some_table;"
                ]
            },
            {
                "expression": "SELECT POWER(10, 2), POWER(2, 3), POWER(3, 3);",
                "description": "Calculates the power of a number: POWER(10, 2) returns 100, POWER(2, 3) returns 8, POWER(3, 3) returns 27.",
                "examples": [
                    "SELECT POWER(5, 2);",
                    "SELECT POWER(3, 4);",
                    "SELECT POWER(10, 0);"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n"
        ]
    },
    {
        "sql_id": 295,
        "database_name": "BUTTERTrans_295",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select ceil(0.09); -- CEIL",
        "target_query": "select ceil(0.09);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CEIL",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the smallest integer value not less than x (rounds up).",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the least integer greater than or equal to x.",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n",
            "select pow(10,log10(10)),power(2,4); -- POW, POWER\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n",
            "select POWER(10,log10(10)),POWER(2,4);\n"
        ]
    },
    {
        "sql_id": 296,
        "database_name": "BUTTERTrans_296",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select ceil(0.000000000000000009); -- CEIL",
        "target_query": "select ceil(0.000000000000000009);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CEIL",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the smallest integer value not less than x (rounds up).",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the least integer greater than or equal to x.",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n",
            "select pow(10,log10(10)),power(2,4); -- POW, POWER\n",
            "select ceil(0.09); -- CEIL\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n",
            "select POWER(10,log10(10)),POWER(2,4);\n",
            "select ceil(0.09);\n"
        ]
    },
    {
        "sql_id": 297,
        "database_name": "BUTTERTrans_297",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values ('http://www.foo.com/', now()); -- NOW",
        "target_query": "insert into t1 values ('http://www.foo.com/', CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 46,
                "end_pos": 49
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n",
            "select pow(10,log10(10)),power(2,4); -- POW, POWER\n",
            "select ceil(0.09); -- CEIL\n",
            "select ceil(0.000000000000000009); -- CEIL\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts datetime not null);\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n",
            "select POWER(10,log10(10)),POWER(2,4);\n",
            "select ceil(0.09);\n",
            "select ceil(0.000000000000000009);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts timestamp not null);\n"
        ]
    },
    {
        "sql_id": 298,
        "database_name": "BUTTERTrans_298",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF",
        "target_query": "select a from t1 where a='http://www.foo.com/' order by abs(EXTRACT(EPOCH FROM ts - timestamp '1970-01-01 00:00:00'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 60,
                "end_pos": 68
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n",
            "select pow(10,log10(10)),power(2,4); -- POW, POWER\n",
            "select ceil(0.09); -- CEIL\n",
            "select ceil(0.000000000000000009); -- CEIL\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts datetime not null);\n",
            "insert into t1 values ('http://www.foo.com/', now()); -- NOW\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n",
            "select POWER(10,log10(10)),POWER(2,4);\n",
            "select ceil(0.09);\n",
            "select ceil(0.000000000000000009);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts timestamp not null);\n",
            "insert into t1 values ('http://www.foo.com/', CURRENT_TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 299,
        "database_name": "BUTTERTrans_299",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select mod(cast(-2 as unsigned), 3), mod(18446744073709551614, 3), mod(-2, 3); -- MOD",
        "target_query": "select mod(-2, 3), mod(18446744073709551614, 3), mod(-2, 3);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MOD",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "MOD",
                "start_pos": 37,
                "end_pos": 40
            },
            {
                "dialect_token": "MOD",
                "start_pos": 67,
                "end_pos": 70
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder after integer division.",
                "examples": [
                    "SELECT MOD(7, 2);",
                    "SELECT 7 % 2;",
                    "SELECT MOD(3, 0);"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n",
            "select pow(10,log10(10)),power(2,4); -- POW, POWER\n",
            "select ceil(0.09); -- CEIL\n",
            "select ceil(0.000000000000000009); -- CEIL\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts datetime not null);\n",
            "insert into t1 values ('http://www.foo.com/', now()); -- NOW\n",
            "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n",
            "select POWER(10,log10(10)),POWER(2,4);\n",
            "select ceil(0.09);\n",
            "select ceil(0.000000000000000009);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts timestamp not null);\n",
            "insert into t1 values ('http://www.foo.com/', CURRENT_TIMESTAMP);\n",
            "select a from t1 where a='http://www.foo.com/' order by abs(EXTRACT(EPOCH FROM ts - timestamp '1970-01-01 00:00:00'));\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 300,
        "database_name": "BUTTERTrans_300",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select mod(5, cast(-2 as unsigned)), mod(5, 18446744073709551614), mod(5, -2); -- MOD",
        "target_query": "SELECT mod(5, -2), mod(5, 18446744073709551614), mod(5, -2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MOD",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "MOD",
                "start_pos": 37,
                "end_pos": 40
            },
            {
                "dialect_token": "MOD",
                "start_pos": 67,
                "end_pos": 70
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder after integer division.",
                "examples": [
                    "SELECT MOD(7, 2);",
                    "SELECT 7 % 2;",
                    "SELECT MOD(3, 0);"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n",
            "select pow(10,log10(10)),power(2,4); -- POW, POWER\n",
            "select ceil(0.09); -- CEIL\n",
            "select ceil(0.000000000000000009); -- CEIL\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts datetime not null);\n",
            "insert into t1 values ('http://www.foo.com/', now()); -- NOW\n",
            "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF\n",
            "DROP TABLE t1;\n",
            "select mod(cast(-2 as unsigned), 3), mod(18446744073709551614, 3), mod(-2, 3); -- MOD\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n",
            "select POWER(10,log10(10)),POWER(2,4);\n",
            "select ceil(0.09);\n",
            "select ceil(0.000000000000000009);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts timestamp not null);\n",
            "insert into t1 values ('http://www.foo.com/', CURRENT_TIMESTAMP);\n",
            "select a from t1 where a='http://www.foo.com/' order by abs(EXTRACT(EPOCH FROM ts - timestamp '1970-01-01 00:00:00'));\n",
            "DROP TABLE t1;\n",
            "select mod(-2, 3), mod(18446744073709551614, 3), mod(-2, 3);\n"
        ]
    },
    {
        "sql_id": 301,
        "database_name": "BUTTERTrans_301",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select pow(cast(-2 as unsigned), 5), pow(18446744073709551614, 5), pow(-2, 5); -- POW",
        "target_query": "select POWER(-2, 5), POWER(18446744073709551614, 5), POWER(-2, 5);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "POW",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "POW",
                "start_pos": 37,
                "end_pos": 40
            },
            {
                "dialect_token": "POW",
                "start_pos": 67,
                "end_pos": 70
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "POW(3, 3)",
                "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
                "examples": [
                    "SELECT POW(3, 3);",
                    "SELECT POW(5, 4);",
                    "SELECT POW(x, 2) FROM some_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POWER(3, 3)",
                "description": "MonetDB supports the POWER() function to calculate x raised to the power of y, where x and y are typically INTEGER or FLOAT types.",
                "examples": [
                    "SELECT POWER(3, 3);",
                    "SELECT POWER(5, 4);",
                    "SELECT POWER(x, 2) FROM some_table;"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n",
            "select pow(10,log10(10)),power(2,4); -- POW, POWER\n",
            "select ceil(0.09); -- CEIL\n",
            "select ceil(0.000000000000000009); -- CEIL\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts datetime not null);\n",
            "insert into t1 values ('http://www.foo.com/', now()); -- NOW\n",
            "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF\n",
            "DROP TABLE t1;\n",
            "select mod(cast(-2 as unsigned), 3), mod(18446744073709551614, 3), mod(-2, 3); -- MOD\n",
            "select mod(5, cast(-2 as unsigned)), mod(5, 18446744073709551614), mod(5, -2); -- MOD\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n",
            "select POWER(10,log10(10)),POWER(2,4);\n",
            "select ceil(0.09);\n",
            "select ceil(0.000000000000000009);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts timestamp not null);\n",
            "insert into t1 values ('http://www.foo.com/', CURRENT_TIMESTAMP);\n",
            "select a from t1 where a='http://www.foo.com/' order by abs(EXTRACT(EPOCH FROM ts - timestamp '1970-01-01 00:00:00'));\n",
            "DROP TABLE t1;\n",
            "select mod(-2, 3), mod(18446744073709551614, 3), mod(-2, 3);\n",
            "SELECT mod(5, -2), mod(5, 18446744073709551614), mod(5, -2);\n"
        ]
    },
    {
        "sql_id": 302,
        "database_name": "BUTTERTrans_302",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CASE(('')) WHEN (CONVERT(1, CHAR(1))) THEN (('' / 1)) END; -- CONVERT",
        "target_query": "SELECT CASE(('')) WHEN (CAST(1 AS CHAR(1))) THEN (('' / 1)) END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONVERT",
                "start_pos": 24,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONVERT(expression USING charset)",
                "description": "Converts data types or changes the character set.",
                "examples": [
                    "SELECT CONVERT('Hello World' USING utf8);",
                    "SELECT CONVERT(1234, CHAR);",
                    "SELECT CONVERT(column_name USING latin1) FROM my_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST(expression AS target_type)",
                "description": "MonetDB uses CAST for type conversion. No direct equivalent for CONVERT TO CHARACTER SET.",
                "examples": [
                    "SELECT CAST('Hello World' AS TEXT);",
                    "SELECT CAST(1234 AS VARCHAR);",
                    "SELECT CAST(column_name AS TEXT) FROM my_table;"
                ]
            }
        ],
        "source_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL); -- LN\n",
            "select log2(8),log2(15),log2(NULL); -- LOG2\n",
            "select pow(10,log10(10)),power(2,4); -- POW, POWER\n",
            "select ceil(0.09); -- CEIL\n",
            "select ceil(0.000000000000000009); -- CEIL\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts datetime not null);\n",
            "insert into t1 values ('http://www.foo.com/', now()); -- NOW\n",
            "select a from t1 where a='http://www.foo.com/' order by abs(timediff(ts, 0)); -- TIMEDIFF\n",
            "DROP TABLE t1;\n",
            "select mod(cast(-2 as unsigned), 3), mod(18446744073709551614, 3), mod(-2, 3); -- MOD\n",
            "select mod(5, cast(-2 as unsigned)), mod(5, 18446744073709551614), mod(5, -2); -- MOD\n",
            "select pow(cast(-2 as unsigned), 5), pow(18446744073709551614, 5), pow(-2, 5); -- POW\n",
            "CREATE TABLE t1(a LONGBLOB);\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "select ln(exp(10)),exp(ln(sqrt(10))*2),ln(NULL);\n",
            "select log(8) / log(2),log(15) / log(2),log(NULL) / log(2);\n",
            "select POWER(10,log10(10)),POWER(2,4);\n",
            "select ceil(0.09);\n",
            "select ceil(0.000000000000000009);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(90), ts timestamp not null);\n",
            "insert into t1 values ('http://www.foo.com/', CURRENT_TIMESTAMP);\n",
            "select a from t1 where a='http://www.foo.com/' order by abs(EXTRACT(EPOCH FROM ts - timestamp '1970-01-01 00:00:00'));\n",
            "DROP TABLE t1;\n",
            "select mod(-2, 3), mod(18446744073709551614, 3), mod(-2, 3);\n",
            "SELECT mod(5, -2), mod(5, 18446744073709551614), mod(5, -2);\n",
            "select POWER(-2, 5), POWER(18446744073709551614, 5), POWER(-2, 5);\n",
            "CREATE TABLE t1(a BLOB);\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 303,
        "database_name": "BUTTERTrans_303",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT",
        "target_query": "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS simple1;\n",
            "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES\n",
            "DROP TABLE IF EXISTS bigger_than_it_looks;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS simple1;\n",
            "CREATE TABLE simple1 AS SELECT * FROM generate_series(1, 200 + 1) AS id;\n",
            "DROP TABLE IF EXISTS bigger_than_it_looks;\n"
        ]
    },
    {
        "sql_id": 304,
        "database_name": "BUTTERTrans_304",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 28,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(0x3A), (0x3B), (0x3C), (0x3D), (0x3E), (0x3F), (0x40), (0x5B), (0x5C), (0x5D), (0x5E), (0x5F), (0x60), (0x7B), (0x7C), (0x7D), (0x7E);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(X'3A'), (X'3B'), (X'3C'), (X'3D'), (X'3E'), (X'3F'), (X'40'), (X'5B'), (X'5C'), (X'5D'), (X'5E'), (X'5F'), (X'60'), (X'7B'), (X'7C'), (X'7D'), (X'7E');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n"
        ]
    },
    {
        "sql_id": 305,
        "database_name": "BUTTERTrans_305",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT",
        "target_query": "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2; -- CONCAT",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 28,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(0x3A), (0x3B), (0x3C), (0x3D), (0x3E), (0x3F), (0x40), (0x5B), (0x5C), (0x5D), (0x5E), (0x5F), (0x60), (0x7B), (0x7C), (0x7D), (0x7E);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(X'3A'), (X'3B'), (X'3C'), (X'3D'), (X'3E'), (X'3F'), (X'40'), (X'5B'), (X'5C'), (X'5D'), (X'5E'), (X'5F'), (X'60'), (X'7B'), (X'7C'), (X'7D'), (X'7E');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT\n"
        ]
    },
    {
        "sql_id": 306,
        "database_name": "BUTTERTrans_306",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2; -- OCTET_LENGTH",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=2; -- OCTET_LENGTH (MonetDB uses LENGTH instead of OCTET_LENGTH)",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "OCTET_LENGTH",
                "start_pos": 40,
                "end_pos": 52
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT LENGTH('Hello World');",
                    "SELECT LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(0x3A), (0x3B), (0x3C), (0x3D), (0x3E), (0x3F), (0x40), (0x5B), (0x5C), (0x5D), (0x5E), (0x5F), (0x60), (0x7B), (0x7C), (0x7D), (0x7E);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT\n",
            "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT\n",
            "DROP TABLE head;\n",
            "DROP TABLE tail;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(X'3A'), (X'3B'), (X'3C'), (X'3D'), (X'3E'), (X'3F'), (X'40'), (X'5B'), (X'5C'), (X'5D'), (X'5E'), (X'5F'), (X'60'), (X'7B'), (X'7C'), (X'7D'), (X'7E');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT\n",
            "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2; -- CONCAT\n",
            "DROP TABLE head;\n",
            "DROP TABLE tail;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;\n"
        ]
    },
    {
        "sql_id": 307,
        "database_name": "BUTTERTrans_307",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t1 WHERE CHAR_LENGTH(a)=2; -- CHAR_LENGTH",
        "target_query": "SELECT * FROM t1 WHERE char_length(a)=2; -- CHAR_LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CHAR_LENGTH",
                "start_pos": 23,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "char_length(expr)",
                "description": "Returns the number of characters in a string (char_length and length are equivalent).",
                "examples": [
                    "SELECT char_length('abc');",
                    "SELECT char_length('\u4f60\u597d');",
                    "SELECT char_length('a\u4f60b\u597dc');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(0x3A), (0x3B), (0x3C), (0x3D), (0x3E), (0x3F), (0x40), (0x5B), (0x5C), (0x5D), (0x5E), (0x5F), (0x60), (0x7B), (0x7C), (0x7D), (0x7E);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT\n",
            "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT\n",
            "DROP TABLE head;\n",
            "DROP TABLE tail;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;\n",
            "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2; -- OCTET_LENGTH\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(X'3A'), (X'3B'), (X'3C'), (X'3D'), (X'3E'), (X'3F'), (X'40'), (X'5B'), (X'5C'), (X'5D'), (X'5E'), (X'5F'), (X'60'), (X'7B'), (X'7C'), (X'7D'), (X'7E');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT\n",
            "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2; -- CONCAT\n",
            "DROP TABLE head;\n",
            "DROP TABLE tail;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;\n",
            "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=2; -- OCTET_LENGTH (MonetDB uses LENGTH instead of OCTET_LENGTH)\n"
        ]
    },
    {
        "sql_id": 308,
        "database_name": "BUTTERTrans_308",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=3; -- OCTET_LENGTH",
        "target_query": "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=3; -- OCTET_LENGTH (MonetDB uses LENGTH instead of OCTET_LENGTH)",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "OCTET_LENGTH",
                "start_pos": 40,
                "end_pos": 52
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT LENGTH('Hello World');",
                    "SELECT LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(0x3A), (0x3B), (0x3C), (0x3D), (0x3E), (0x3F), (0x40), (0x5B), (0x5C), (0x5D), (0x5E), (0x5F), (0x60), (0x7B), (0x7C), (0x7D), (0x7E);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 SELECT repeat('a',4000) a; -- REPEAT\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT concat(b1.b, b2.b) AS head FROM t1 b1, t1 b2; -- CONCAT\n",
            "CREATE TABLE tail AS SELECT concat(b1.b, b2.b) AS tail FROM t1 b1, t1 b2; -- CONCAT\n",
            "DROP TABLE head;\n",
            "DROP TABLE tail;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;\n",
            "SELECT COUNT(*) FROM t1 WHERE a<>'' AND OCTET_LENGTH(a)=2; -- OCTET_LENGTH\n",
            "SELECT * FROM t1 WHERE CHAR_LENGTH(a)=2; -- CHAR_LENGTH\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(c1 CHAR(4));\n",
            "INSERT INTO t1 VALUES(X'3A'), (X'3B'), (X'3C'), (X'3D'), (X'3E'), (X'3F'), (X'40'), (X'5B'), (X'5C'), (X'5D'), (X'5E'), (X'5F'), (X'60'), (X'7B'), (X'7C'), (X'7D'), (X'7E');\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT REPEAT('a', 4000) AS a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (b VARCHAR(2));\n",
            "INSERT INTO t1 VALUES ('0'),('1'),('2'),('3'),('4'),('5'),('6'),('7');\n",
            "INSERT INTO t1 VALUES ('8'),('9'),('A'),('B'),('C'),('D'),('E'),('F');\n",
            "DROP TABLE IF EXISTS head;\n",
            "DROP TABLE IF EXISTS tail;\n",
            "CREATE TABLE head AS SELECT b1.b || b2.b AS head FROM t1 b1, t1 b2; -- CONCAT\n",
            "CREATE TABLE tail AS SELECT b1.b || b2.b AS tail FROM t1 b1, t1 b2; -- CONCAT\n",
            "DROP TABLE head;\n",
            "DROP TABLE tail;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 AS SELECT '111111' AS code, ' ' AS a LIMIT 1;\n",
            "SELECT COUNT(*) FROM t1 WHERE a<>'' AND LENGTH(a)=2; -- OCTET_LENGTH (MonetDB uses LENGTH instead of OCTET_LENGTH)\n",
            "SELECT * FROM t1 WHERE char_length(a)=2; -- CHAR_LENGTH\n"
        ]
    },
    {
        "sql_id": 309,
        "database_name": "BUTTERTrans_309",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV",
        "target_query": "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DIV",
                "start_pos": 24,
                "end_pos": 27
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "a DIV b",
                "description": "Performs integer division between two numbers and returns the floor of the quotient.",
                "examples": [
                    "SELECT 10 DIV 3;",
                    "SELECT 5.8 DIV 2;",
                    "SELECT 9 DIV 4 + 1;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "FLOOR(a / b)",
                "description": "Evaluates division and applies FLOOR to get integer result.",
                "examples": [
                    "SELECT FLOOR(10 / 3);",
                    "SELECT FLOOR(5.8 / 2);",
                    "SELECT FLOOR(9 / 4) + 1;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 310,
        "database_name": "BUTTERTrans_310",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (ln(1)); -- LN",
        "target_query": "INSERT INTO t1 VALUES (ln(1));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LN",
                "start_pos": 23,
                "end_pos": 25
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LN(x)",
                "description": "The LN() function returns the natural logarithm of x. If x is less than or equal to 0, it returns NULL.",
                "examples": [
                    "select ln(exp(10));",
                    "select exp(ln(sqrt(10)) * 2);",
                    "select ln(-1);",
                    "select ln(0);",
                    "select ln(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LN(x)",
                "description": "MonetDB's LN() function returns the natural logarithm of x. It returns NaN for negative or zero values, similar to ClickHouse.",
                "examples": [
                    "select ln(exp(10));",
                    "select exp(ln(sqrt(10)) * 2);",
                    "select ln(NULL);"
                ]
            }
        ],
        "source_related_schemas": [
            "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n"
        ],
        "target_related_schemas": [
            "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n"
        ]
    },
    {
        "sql_id": 311,
        "database_name": "BUTTERTrans_311",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT floor(ceil(123456789)); -- CEIL",
        "target_query": "SELECT floor(ceil(123456789));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CEIL",
                "start_pos": 13,
                "end_pos": 17
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the smallest integer value not less than x (rounds up).",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CEIL(x)",
                "description": "Returns the least integer greater than or equal to x.",
                "examples": [
                    "SELECT CEIL(1.3);",
                    "SELECT CEIL(-2.8);",
                    "SELECT CEIL(RAND() * 100);"
                ]
            }
        ],
        "source_related_schemas": [
            "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1)); -- LN\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1));\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 312,
        "database_name": "BUTTERTrans_312",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select cast(pow(2,63)-1024 as signed) as pp; -- POW",
        "target_query": "SELECT cast(POWER(2,63)-1024 as bigint) as pp;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "POW",
                "start_pos": 12,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "POW(3, 3)",
                "description": "POW(x, y) in MySQL is used to calculate x raised to the power of y. It returns the result of x^y.",
                "examples": [
                    "SELECT POW(3, 3);",
                    "SELECT POW(5, 4);",
                    "SELECT POW(x, 2) FROM some_table;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "POWER(3, 3)",
                "description": "MonetDB supports the POWER() function to calculate x raised to the power of y, where x and y are typically INTEGER or FLOAT types.",
                "examples": [
                    "SELECT POWER(3, 3);",
                    "SELECT POWER(5, 4);",
                    "SELECT POWER(x, 2) FROM some_table;"
                ]
            }
        ],
        "source_related_schemas": [
            "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1)); -- LN\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789)); -- CEIL\n"
        ],
        "target_related_schemas": [
            "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1));\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789));\n"
        ]
    },
    {
        "sql_id": 313,
        "database_name": "BUTTERTrans_313",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- COALESCE",
        "target_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 28,
                "end_pos": 36
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1)); -- LN\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789)); -- CEIL\n",
            "select cast(pow(2,63)-1024 as signed) as pp; -- POW\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0(c0 BIGINT UNSIGNED);\n",
            "INSERT INTO t0(c0) VALUES(1);\n"
        ],
        "target_related_schemas": [
            "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1));\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789));\n",
            "SELECT cast(POWER(2,63)-1024 as bigint) as pp;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0(c0 BIGINT);\n",
            "INSERT INTO t0(c0) VALUES(1);\n"
        ]
    },
    {
        "sql_id": 314,
        "database_name": "BUTTERTrans_314",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- IFNULL",
        "target_query": "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 28,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1)); -- LN\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789)); -- CEIL\n",
            "select cast(pow(2,63)-1024 as signed) as pp; -- POW\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0(c0 BIGINT UNSIGNED);\n",
            "INSERT INTO t0(c0) VALUES(1);\n",
            "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- COALESCE\n"
        ],
        "target_related_schemas": [
            "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1));\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789));\n",
            "SELECT cast(POWER(2,63)-1024 as bigint) as pp;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0(c0 BIGINT);\n",
            "INSERT INTO t0(c0) VALUES(1);\n",
            "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);\n"
        ]
    },
    {
        "sql_id": 315,
        "database_name": "BUTTERTrans_315",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) IS TRUE FROM t0; -- COALESCE",
        "target_query": "SELECT CAST(COALESCE(t0.c0, -1) AS bigint) !=0 FROM t0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 12,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1)); -- LN\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789)); -- CEIL\n",
            "select cast(pow(2,63)-1024 as signed) as pp; -- POW\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0(c0 BIGINT UNSIGNED);\n",
            "INSERT INTO t0(c0) VALUES(1);\n",
            "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- COALESCE\n",
            "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- IFNULL\n"
        ],
        "target_related_schemas": [
            "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1));\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789));\n",
            "SELECT cast(POWER(2,63)-1024 as bigint) as pp;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0(c0 BIGINT);\n",
            "INSERT INTO t0(c0) VALUES(1);\n",
            "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);\n",
            "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);\n"
        ]
    },
    {
        "sql_id": 316,
        "database_name": "BUTTERTrans_316",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) FROM t0; -- COALESCE",
        "target_query": "SELECT CAST(COALESCE(t0.c0, -1) AS bigint) FROM t0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 12,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "select (1.175494351E-37 div 1.7976931348623157E+308); -- DIV\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1)); -- LN\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789)); -- CEIL\n",
            "select cast(pow(2,63)-1024 as signed) as pp; -- POW\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0(c0 BIGINT UNSIGNED);\n",
            "INSERT INTO t0(c0) VALUES(1);\n",
            "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS UNSIGNED); -- COALESCE\n",
            "SELECT * FROM t0 WHERE CAST(IFNULL(t0.c0, -1) AS UNSIGNED); -- IFNULL\n",
            "SELECT CAST(COALESCE(t0.c0, -1) AS UNSIGNED) IS TRUE FROM t0; -- COALESCE\n"
        ],
        "target_related_schemas": [
            "SELECT FLOOR(1.175494351E-37 / 1.7976931348623157E+308);\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a DOUBLE);\n",
            "INSERT INTO t1 VALUES (ln(1));\n",
            "DROP TABLE t1;\n",
            "SELECT floor(ceil(123456789));\n",
            "SELECT cast(POWER(2,63)-1024 as bigint) as pp;\n",
            "DROP TABLE IF EXISTS t0;\n",
            "CREATE TABLE t0(c0 BIGINT);\n",
            "INSERT INTO t0(c0) VALUES(1);\n",
            "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);\n",
            "SELECT * FROM t0 WHERE CAST(COALESCE(t0.c0, -1) AS bigint);\n",
            "SELECT CAST(COALESCE(t0.c0, -1) AS bigint) !=0 FROM t0;\n"
        ]
    },
    {
        "sql_id": 317,
        "database_name": "BUTTERTrans_317",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select md5('a'), hex(md5('a')); -- MD5, HEX",
        "target_query": "SELECT MD5('a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MD5",
                "start_pos": 7,
                "end_pos": 10
            },
            {
                "dialect_token": "HEX",
                "start_pos": 17,
                "end_pos": 20
            },
            {
                "dialect_token": "MD5",
                "start_pos": 21,
                "end_pos": 24
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            },
            {
                "expression": "HEX(N)",
                "description": "Converts the given numeric or string value to a hexadecimal representation.",
                "examples": [
                    "SELECT HEX(255);",
                    "SELECT HEX('abc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            },
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 318,
        "database_name": "BUTTERTrans_318",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "create table t1 as select md5('a') as c1; -- MD5",
        "target_query": "CREATE TABLE t1 AS SELECT MD5('a') AS c1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MD5",
                "start_pos": 26,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select md5('a'), hex(md5('a')); -- MD5, HEX\n",
            "DROP TABLE IF EXISTS t1;\n"
        ],
        "target_related_schemas": [
            "SELECT MD5('a');\n",
            "DROP TABLE IF EXISTS t1;\n"
        ]
    },
    {
        "sql_id": 319,
        "database_name": "BUTTERTrans_319",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select md5('hello'); -- MD5",
        "target_query": "SELECT MD5('hello');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MD5",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select md5('a'), hex(md5('a')); -- MD5, HEX\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 as select md5('a') as c1; -- MD5\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "SELECT MD5('a');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 AS SELECT MD5('a') AS c1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 320,
        "database_name": "BUTTERTrans_320",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "explain select md5('hello'); -- MD5",
        "target_query": "EXPLAIN SELECT MD5('hello');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MD5",
                "start_pos": 15,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select md5('a'), hex(md5('a')); -- MD5, HEX\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 as select md5('a') as c1; -- MD5\n",
            "drop table t1;\n",
            "select md5('hello'); -- MD5\n"
        ],
        "target_related_schemas": [
            "SELECT MD5('a');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 AS SELECT MD5('a') AS c1;\n",
            "DROP TABLE t1;\n",
            "SELECT MD5('hello');\n"
        ]
    },
    {
        "sql_id": 321,
        "database_name": "BUTTERTrans_321",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select length(unhex(md5(\"abrakadabra\"))); -- LENGTH, UNHEX, MD5",
        "target_query": "SELECT octet_length(MD5('abrakadabra'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "UNHEX",
                "start_pos": 14,
                "end_pos": 19
            },
            {
                "dialect_token": "MD5",
                "start_pos": 20,
                "end_pos": 23
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            },
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "",
                "description": "",
                "examples": []
            },
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select md5('a'), hex(md5('a')); -- MD5, HEX\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 as select md5('a') as c1; -- MD5\n",
            "drop table t1;\n",
            "select md5('hello'); -- MD5\n",
            "explain select md5('hello'); -- MD5\n"
        ],
        "target_related_schemas": [
            "SELECT MD5('a');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 AS SELECT MD5('a') AS c1;\n",
            "DROP TABLE t1;\n",
            "SELECT MD5('hello');\n",
            "EXPLAIN SELECT MD5('hello');\n"
        ]
    },
    {
        "sql_id": 322,
        "database_name": "BUTTERTrans_322",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values ( 'test',md5('test')), ('test', md5('test')); -- MD5",
        "target_query": "INSERT INTO t1 VALUES ('test', MD5('test')), ('test', MD5('test'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MD5",
                "start_pos": 31,
                "end_pos": 34
            },
            {
                "dialect_token": "MD5",
                "start_pos": 54,
                "end_pos": 57
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select md5('a'), hex(md5('a')); -- MD5, HEX\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 as select md5('a') as c1; -- MD5\n",
            "drop table t1;\n",
            "select md5('hello'); -- MD5\n",
            "explain select md5('hello'); -- MD5\n",
            "select length(unhex(md5(\"abrakadabra\"))); -- LENGTH, UNHEX, MD5\n",
            "create table t1 (f1 varchar(4), f2 varchar(64));\n"
        ],
        "target_related_schemas": [
            "SELECT MD5('a');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 AS SELECT MD5('a') AS c1;\n",
            "DROP TABLE t1;\n",
            "SELECT MD5('hello');\n",
            "EXPLAIN SELECT MD5('hello');\n",
            "SELECT octet_length(MD5('abrakadabra'));\n",
            "CREATE TABLE t1 (f1 VARCHAR(4), f2 VARCHAR(64));\n"
        ]
    },
    {
        "sql_id": 323,
        "database_name": "BUTTERTrans_323",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t1 where f1='test' and (f2= md5(\"test\") or f2= md5(\"Test\")); -- MD5",
        "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('test') OR f2 = MD5('TEST'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MD5",
                "start_pos": 42,
                "end_pos": 45
            },
            {
                "dialect_token": "MD5",
                "start_pos": 61,
                "end_pos": 64
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select md5('a'), hex(md5('a')); -- MD5, HEX\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 as select md5('a') as c1; -- MD5\n",
            "drop table t1;\n",
            "select md5('hello'); -- MD5\n",
            "explain select md5('hello'); -- MD5\n",
            "select length(unhex(md5(\"abrakadabra\"))); -- LENGTH, UNHEX, MD5\n",
            "create table t1 (f1 varchar(4), f2 varchar(64));\n",
            "insert into t1 values ( 'test',md5('test')), ('test', md5('test')); -- MD5\n"
        ],
        "target_related_schemas": [
            "SELECT MD5('a');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 AS SELECT MD5('a') AS c1;\n",
            "DROP TABLE t1;\n",
            "SELECT MD5('hello');\n",
            "EXPLAIN SELECT MD5('hello');\n",
            "SELECT octet_length(MD5('abrakadabra'));\n",
            "CREATE TABLE t1 (f1 VARCHAR(4), f2 VARCHAR(64));\n",
            "INSERT INTO t1 VALUES ('test', MD5('test')), ('test', MD5('test'));\n"
        ]
    },
    {
        "sql_id": 324,
        "database_name": "BUTTERTrans_324",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t1 where f1='test' and (f2= md5(\"TEST\") or f2= md5(\"test\")); -- MD5",
        "target_query": "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('TEST') OR f2 = MD5('test'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MD5",
                "start_pos": 42,
                "end_pos": 45
            },
            {
                "dialect_token": "MD5",
                "start_pos": 61,
                "end_pos": 64
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MD5()",
                "description": "Returns the MD5 hash of a given string, represented as a 32-character hexadecimal number.",
                "examples": [
                    "SELECT MD5('hello') = '5d41402abc4b2a76b9719d911017c592';",
                    "SELECT MD5('hello') <> MD5('world');",
                    "SELECT CASE WHEN MD5('test') = '098f6bcd4621d373cade4e832627b4f6' THEN 'Match' ELSE 'No Match' END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select md5('a'), hex(md5('a')); -- MD5, HEX\n",
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 as select md5('a') as c1; -- MD5\n",
            "drop table t1;\n",
            "select md5('hello'); -- MD5\n",
            "explain select md5('hello'); -- MD5\n",
            "select length(unhex(md5(\"abrakadabra\"))); -- LENGTH, UNHEX, MD5\n",
            "create table t1 (f1 varchar(4), f2 varchar(64));\n",
            "insert into t1 values ( 'test',md5('test')), ('test', md5('test')); -- MD5\n",
            "select * from t1 where f1='test' and (f2= md5(\"test\") or f2= md5(\"Test\")); -- MD5\n"
        ],
        "target_related_schemas": [
            "SELECT MD5('a');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 AS SELECT MD5('a') AS c1;\n",
            "DROP TABLE t1;\n",
            "SELECT MD5('hello');\n",
            "EXPLAIN SELECT MD5('hello');\n",
            "SELECT octet_length(MD5('abrakadabra'));\n",
            "CREATE TABLE t1 (f1 VARCHAR(4), f2 VARCHAR(64));\n",
            "INSERT INTO t1 VALUES ('test', MD5('test')), ('test', MD5('test'));\n",
            "SELECT * FROM t1 WHERE f1 = 'test' AND (f2 = MD5('test') OR f2 = MD5('TEST'));\n"
        ]
    },
    {
        "sql_id": 325,
        "database_name": "BUTTERTrans_325",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select a from t1 where mid(a+0,6,3) in ( mid(20040106123400,6,3) ); -- MID",
        "target_query": "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) IN ( substring('20040106123400', 6, 3));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MID",
                "start_pos": 23,
                "end_pos": 26
            },
            {
                "dialect_token": "MID",
                "start_pos": 41,
                "end_pos": 44
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MID(str, pos, len)",
                "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
                "examples": [
                    "SELECT MID('ABCDEFGHIJKL', 5, 3);",
                    "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
                    "SELECT MID('  padded_text  ', 3, 6);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "substring(str, pos, len)",
                "description": "Standard SQL function to extract a substring starting at character `pos` for length `len`.",
                "examples": [
                    "SELECT substring('ABCDEFGHIJKL', 5, 3);",
                    "SELECT substring('hello_world', 1, 5) || substring('hello_world', 7, 5);",
                    "SELECT substring('  padded_text  ', 3, 6);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 ( a timestamp );\n",
            "insert into t1 values ( '2004-01-06 12:34' );\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 ( a timestamp );\n",
            "INSERT INTO t1 VALUES ( '2004-01-06 12:34' );\n"
        ]
    },
    {
        "sql_id": 326,
        "database_name": "BUTTERTrans_326",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select a from t1 where mid(a+0,6,3) = ( mid(20040106123400,6,3) ); -- MID",
        "target_query": "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) = substring('20040106123400', 6, 3);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MID",
                "start_pos": 23,
                "end_pos": 26
            },
            {
                "dialect_token": "MID",
                "start_pos": 40,
                "end_pos": 43
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MID(str, pos, len)",
                "description": "Extracts a substring from the string `str`, starting at position `pos`, with length `len`.",
                "examples": [
                    "SELECT MID('ABCDEFGHIJKL', 5, 3);",
                    "SELECT CONCAT(MID('hello_world', 1, 5), MID('hello_world', 7, 5));",
                    "SELECT MID('  padded_text  ', 3, 6);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "substring(str, pos, len)",
                "description": "Standard SQL function to extract a substring starting at character `pos` for length `len`.",
                "examples": [
                    "SELECT substring('ABCDEFGHIJKL', 5, 3);",
                    "SELECT substring('hello_world', 1, 5) || substring('hello_world', 7, 5);",
                    "SELECT substring('  padded_text  ', 3, 6);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 ( a timestamp );\n",
            "insert into t1 values ( '2004-01-06 12:34' );\n",
            "select a from t1 where mid(a+0,6,3) in ( mid(20040106123400,6,3) ); -- MID\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 ( a timestamp );\n",
            "INSERT INTO t1 VALUES ( '2004-01-06 12:34' );\n",
            "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) IN ( substring('20040106123400', 6, 3));\n"
        ]
    },
    {
        "sql_id": 327,
        "database_name": "BUTTERTrans_327",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DISTINCT LEAST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- LEAST",
        "target_query": "SELECT DISTINCT CASE WHEN a <= (SELECT b FROM t1 LIMIT 1) THEN a ELSE (SELECT b FROM t1 LIMIT 1) END FROM t1 UNION SELECT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 16,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 ( a timestamp );\n",
            "insert into t1 values ( '2004-01-06 12:34' );\n",
            "select a from t1 where mid(a+0,6,3) in ( mid(20040106123400,6,3) ); -- MID\n",
            "select a from t1 where mid(a+0,6,3) = ( mid(20040106123400,6,3) ); -- MID\n",
            "drop table t1;\n",
            "create table t1 (a int not null);\n",
            "insert into t1 values (-1), (-2);\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a INT, b LONGBLOB);\n",
            "INSERT INTO t1 VALUES (1, '2'), (2, '3'), (3, '2');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 ( a timestamp );\n",
            "INSERT INTO t1 VALUES ( '2004-01-06 12:34' );\n",
            "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) IN ( substring('20040106123400', 6, 3));\n",
            "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) = substring('20040106123400', 6, 3);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a int NOT NULL);\n",
            "INSERT INTO t1 VALUES (-1), (-2);\n",
            "DRoP TABLE t1;\n",
            "CREATE TABLE t1 (a INT, b VARCHAR);\n",
            "INSERT INTO t1 VALUES (1, '2'), (2, '3'), (3, '2');\n"
        ]
    },
    {
        "sql_id": 328,
        "database_name": "BUTTERTrans_328",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DISTINCT GREATEST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- GREATEST",
        "target_query": "SELECT DISTINCT GREATEST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 16,
                "end_pos": 24
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 ( a timestamp );\n",
            "insert into t1 values ( '2004-01-06 12:34' );\n",
            "select a from t1 where mid(a+0,6,3) in ( mid(20040106123400,6,3) ); -- MID\n",
            "select a from t1 where mid(a+0,6,3) = ( mid(20040106123400,6,3) ); -- MID\n",
            "drop table t1;\n",
            "create table t1 (a int not null);\n",
            "insert into t1 values (-1), (-2);\n",
            "drop table t1;\n",
            "CREATE TABLE t1 (a INT, b LONGBLOB);\n",
            "INSERT INTO t1 VALUES (1, '2'), (2, '3'), (3, '2');\n",
            "SELECT DISTINCT LEAST(a, (SELECT b FROM t1 LIMIT 1)) FROM t1 UNION SELECT 1; -- LEAST\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 ( a timestamp );\n",
            "INSERT INTO t1 VALUES ( '2004-01-06 12:34' );\n",
            "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) IN ( substring('20040106123400', 6, 3));\n",
            "SELECT a FROM t1 WHERE substring(sys.timestamp_to_str(a, '%Y%m%d%H%i%s'), 6, 3) = substring('20040106123400', 6, 3);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a int NOT NULL);\n",
            "INSERT INTO t1 VALUES (-1), (-2);\n",
            "DRoP TABLE t1;\n",
            "CREATE TABLE t1 (a INT, b VARCHAR);\n",
            "INSERT INTO t1 VALUES (1, '2'), (2, '3'), (3, '2');\n",
            "SELECT DISTINCT CASE WHEN a <= (SELECT b FROM t1 LIMIT 1) THEN a ELSE (SELECT b FROM t1 LIMIT 1) END FROM t1 UNION SELECT 1;\n"
        ]
    },
    {
        "sql_id": 329,
        "database_name": "BUTTERTrans_329",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2; -- MOD",
        "target_query": "select 1+1,1-1,1+1*2,8/5,8%5,mod(8,5),-(1+1)*-2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MOD",
                "start_pos": 29,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder of N divided by M. Returns NULL if M = 0.",
                "examples": [
                    "SELECT MOD(10, 3);",
                    "SELECT 10 % 3;",
                    "SELECT MOD(5, 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "MOD(N, M) \u6216 N % M",
                "description": "Returns the remainder after integer division.",
                "examples": [
                    "SELECT MOD(7, 2);",
                    "SELECT 7 % 2;",
                    "SELECT MOD(3, 0);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 330,
        "database_name": "BUTTERTrans_330",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 331,
        "database_name": "BUTTERTrans_331",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF",
        "target_query": "SELECT DATE '1997-12-31' - DATE '1997-12-30';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATEDIFF(date1, date2)",
                "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
                "examples": [
                    "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
                    "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
                    "SELECT DATEDIFF(NULL, '2025-01-01');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "date1 - date2",
                "description": "Subtracting one DATE from another returns the day difference as an integer.",
                "examples": [
                    "SELECT DATE '2025-12-31' - DATE '2025-12-01';",
                    "SELECT DATE '2025-01-01' - DATE '2024-12-31';"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n"
        ]
    },
    {
        "sql_id": 332,
        "database_name": "BUTTERTrans_332",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF",
        "target_query": "SELECT DATE '1997-11-30' - NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATEDIFF(date1, date2)",
                "description": "Returns the number of days between two date or datetime expressions (date1 - date2), ignoring time part.",
                "examples": [
                    "SELECT DATEDIFF('2025-12-31', '2025-12-01');",
                    "SELECT DATEDIFF('2025-01-01', '2024-12-31');",
                    "SELECT DATEDIFF(NULL, '2025-01-01');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "date1 - date2",
                "description": "Subtracting one DATE from another returns the day difference as an integer.",
                "examples": [
                    "SELECT DATE '2025-12-31' - DATE '2025-12-01';",
                    "SELECT DATE '2025-01-01' - DATE '2024-12-31';"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n"
        ]
    },
    {
        "sql_id": 333,
        "database_name": "BUTTERTrans_333",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select makedate(03,1); -- MAKEDATE",
        "target_query": "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKEDATE",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
                "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
                "examples": [
                    "SELECT DATE '2009-01-01' AS first_day_of_year;",
                    "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
                    "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n"
        ]
    },
    {
        "sql_id": 334,
        "database_name": "BUTTERTrans_334",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select makedate('0003',1); -- MAKEDATE",
        "target_query": "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKEDATE",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
                "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
                "examples": [
                    "SELECT DATE '2009-01-01' AS first_day_of_year;",
                    "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
                    "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 335,
        "database_name": "BUTTERTrans_335",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select makedate(1997,1); -- MAKEDATE",
        "target_query": "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKEDATE",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
                "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
                "examples": [
                    "SELECT DATE '2009-01-01' AS first_day_of_year;",
                    "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
                    "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n"
        ]
    },
    {
        "sql_id": 336,
        "database_name": "BUTTERTrans_336",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select makedate(1997,0); -- MAKEDATE",
        "target_query": "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKEDATE",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
                "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
                "examples": [
                    "SELECT DATE '2009-01-01' AS first_day_of_year;",
                    "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
                    "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n"
        ]
    },
    {
        "sql_id": 337,
        "database_name": "BUTTERTrans_337",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select makedate(9999,365); -- MAKEDATE",
        "target_query": "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKEDATE",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
                "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
                "examples": [
                    "SELECT DATE '2009-01-01' AS first_day_of_year;",
                    "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
                    "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n"
        ]
    },
    {
        "sql_id": 338,
        "database_name": "BUTTERTrans_338",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select makedate(9999,366); -- MAKEDATE",
        "target_query": "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKEDATE",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
                "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
                "examples": [
                    "SELECT DATE '2009-01-01' AS first_day_of_year;",
                    "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
                    "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n"
        ]
    },
    {
        "sql_id": 339,
        "database_name": "BUTTERTrans_339",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select makedate(100,1); -- MAKEDATE",
        "target_query": "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKEDATE",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKEDATE(year, day_of_year)",
                "description": "Returns a date from the given year and day of the year.",
                "examples": [
                    "SELECT MAKEDATE(2009, 1) AS first_day_of_year;",
                    "SELECT MAKEDATE(2025, 100) AS specific_date;",
                    "SELECT MAKEDATE(2020, 366) AS last_day_of_year;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "DATE 'year-01-01' + INTERVAL 'day_of_year - 1' DAY",
                "description": "Returns a date from the given year and day of the year by adding interval days to January 1st.",
                "examples": [
                    "SELECT DATE '2009-01-01' AS first_day_of_year;",
                    "SELECT DATE '2025-01-01' + INTERVAL '99' DAY AS specific_date;",
                    "SELECT DATE '2020-01-01' + INTERVAL '365' DAY AS last_day_of_year;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n"
        ]
    },
    {
        "sql_id": 340,
        "database_name": "BUTTERTrans_340",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME",
        "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "SUBTIME",
                "start_pos": 7,
                "end_pos": 14
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SUBTIME(expr1, expr2)",
                "description": "Subtracts a time/datetime interval from the given time or datetime.",
                "examples": [
                    "SELECT SUBTIME('12:00:00', '01:30:00');",
                    "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
                    "SELECT SUBTIME('05:00:00', '05:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr - INTERVAL",
                "description": "Subtracts interval using ANSI SQL syntax with HOUR TO MINUTE/SECOND.",
                "examples": [
                    "SELECT TIME '12:00:00' - INTERVAL '01:30' HOUR TO MINUTE;",
                    "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '00:00:01' HOUR TO SECOND;",
                    "SELECT TIME '05:00:00' - INTERVAL '05:00' HOUR TO MINUTE;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n"
        ]
    },
    {
        "sql_id": 341,
        "database_name": "BUTTERTrans_341",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME",
        "target_query": "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "SUBTIME",
                "start_pos": 7,
                "end_pos": 14
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SUBTIME(expr1, expr2)",
                "description": "Subtracts a time/datetime interval from the given time or datetime.",
                "examples": [
                    "SELECT SUBTIME('12:00:00', '01:30:00');",
                    "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
                    "SELECT SUBTIME('05:00:00', '05:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr - INTERVAL",
                "description": "Subtracts interval using ANSI SQL syntax with HOUR TO MINUTE/SECOND.",
                "examples": [
                    "SELECT TIME '12:00:00' - INTERVAL '01:30' HOUR TO MINUTE;",
                    "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '00:00:01' HOUR TO SECOND;",
                    "SELECT TIME '05:00:00' - INTERVAL '05:00' HOUR TO MINUTE;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n",
            "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;\n"
        ]
    },
    {
        "sql_id": 342,
        "database_name": "BUTTERTrans_342",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME",
        "target_query": "SELECT TIME '01:00:00.999999' - TIME '02:00:00.999998';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "SUBTIME",
                "start_pos": 7,
                "end_pos": 14
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SUBTIME(expr1, expr2)",
                "description": "Subtracts a time/datetime interval from the given time or datetime.",
                "examples": [
                    "SELECT SUBTIME('12:00:00', '01:30:00');",
                    "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
                    "SELECT SUBTIME('05:00:00', '05:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr - INTERVAL",
                "description": "Subtracts interval using ANSI SQL syntax with HOUR TO MINUTE/SECOND.",
                "examples": [
                    "SELECT TIME '12:00:00' - INTERVAL '01:30' HOUR TO MINUTE;",
                    "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '00:00:01' HOUR TO SECOND;",
                    "SELECT TIME '05:00:00' - INTERVAL '05:00' HOUR TO MINUTE;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n",
            "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME\n",
            "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';\n"
        ]
    },
    {
        "sql_id": 343,
        "database_name": "BUTTERTrans_343",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME",
        "target_query": "SELECT TIME '02:01:01.999999' - TIME '01:01:01.999999';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "SUBTIME",
                "start_pos": 7,
                "end_pos": 14
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SUBTIME(expr1, expr2)",
                "description": "Subtracts a time/datetime interval from the given time or datetime.",
                "examples": [
                    "SELECT SUBTIME('12:00:00', '01:30:00');",
                    "SELECT SUBTIME('2025-01-01 10:00:00', '00:00:01');",
                    "SELECT SUBTIME('05:00:00', '05:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr - INTERVAL",
                "description": "Subtracts interval using ANSI SQL syntax with HOUR TO MINUTE/SECOND.",
                "examples": [
                    "SELECT TIME '12:00:00' - INTERVAL '01:30' HOUR TO MINUTE;",
                    "SELECT TIMESTAMP '2025-01-01 10:00:00' - INTERVAL '00:00:01' HOUR TO SECOND;",
                    "SELECT TIME '05:00:00' - INTERVAL '05:00' HOUR TO MINUTE;"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n",
            "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME\n",
            "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME\n",
            "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';\n",
            "SELECT TIME '01:00:00.999999' - TIME '02:00:00.999998';\n"
        ]
    },
    {
        "sql_id": 344,
        "database_name": "BUTTERTrans_344",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-01-01 23:59:59.000001' - TIMESTAMP '1995-12-31 23:59:59.000002');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n",
            "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME\n",
            "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME\n",
            "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME\n",
            "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';\n",
            "SELECT TIME '01:00:00.999999' - TIME '02:00:00.999998';\n",
            "SELECT TIME '02:01:01.999999' - TIME '01:01:01.999999';\n"
        ]
    },
    {
        "sql_id": 345,
        "database_name": "BUTTERTrans_345",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30 01:01:01.000002\"); -- TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIMESTAMP '1997-12-30 01:01:01.000002');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n",
            "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME\n",
            "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME\n",
            "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME\n",
            "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME\n",
            "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';\n",
            "SELECT TIME '01:00:00.999999' - TIME '02:00:00.999998';\n",
            "SELECT TIME '02:01:01.999999' - TIME '01:01:01.999999';\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-01-01 23:59:59.000001' - TIMESTAMP '1995-12-31 23:59:59.000002');\n"
        ]
    },
    {
        "sql_id": 346,
        "database_name": "BUTTERTrans_346",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff(\"1997-12-31 23:59:59.000001\",\"23:59:59.000001\"); -- TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIME '23:59:59.000001');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n",
            "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME\n",
            "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME\n",
            "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME\n",
            "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME\n",
            "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF\n",
            "select timediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30 01:01:01.000002\"); -- TIMEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';\n",
            "SELECT TIME '01:00:00.999999' - TIME '02:00:00.999998';\n",
            "SELECT TIME '02:01:01.999999' - TIME '01:01:01.999999';\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-01-01 23:59:59.000001' - TIMESTAMP '1995-12-31 23:59:59.000002');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIMESTAMP '1997-12-30 01:01:01.000002');\n"
        ]
    },
    {
        "sql_id": 347,
        "database_name": "BUTTERTrans_347",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff(\"2000:01:01 00:00:00\", \"2000:01:01 00:00:00.000001\"); -- TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2000-01-01 00:00:00' - TIMESTAMP '2000-01-01 00:00:00.000001');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n",
            "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME\n",
            "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME\n",
            "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME\n",
            "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME\n",
            "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF\n",
            "select timediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30 01:01:01.000002\"); -- TIMEDIFF\n",
            "select timediff(\"1997-12-31 23:59:59.000001\",\"23:59:59.000001\"); -- TIMEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';\n",
            "SELECT TIME '01:00:00.999999' - TIME '02:00:00.999998';\n",
            "SELECT TIME '02:01:01.999999' - TIME '01:01:01.999999';\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-01-01 23:59:59.000001' - TIMESTAMP '1995-12-31 23:59:59.000002');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIMESTAMP '1997-12-30 01:01:01.000002');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIME '23:59:59.000001');\n"
        ]
    },
    {
        "sql_id": 348,
        "database_name": "BUTTERTrans_348",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff(\"2005-01-11 15:48:49.999999\", \"2005-01-11 15:48:50\"); --  TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2005-01-11 15:48:49.999999' - TIMESTAMP '2005-01-11 15:48:50');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select date_format(\"1997-12-31 23:59:59.000002\", \"%f\"); -- DATE_FORMAT\n",
            "select datediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30\"); -- DATEDIFF\n",
            "select datediff(\"1997-11-30 23:59:59.000001\",null); --  DATEDIFF\n",
            "select makedate(03,1); -- MAKEDATE\n",
            "select makedate('0003',1); -- MAKEDATE\n",
            "select makedate(1997,1); -- MAKEDATE\n",
            "select makedate(1997,0); -- MAKEDATE\n",
            "select makedate(9999,365); -- MAKEDATE\n",
            "select makedate(9999,366); -- MAKEDATE\n",
            "select makedate(100,1); -- MAKEDATE\n",
            "select subtime(\"1997-12-31 23:59:59.000001\", \"1 1:1:1.000002\"); -- SUBTIME\n",
            "select subtime(\"1997-12-31 23:59:59.999999\", \"1998-01-01 01:01:01.999999\"); -- SUBTIME\n",
            "select subtime(\"01:00:00.999999\", \"02:00:00.999998\"); -- SUBTIME\n",
            "select subtime(\"02:01:01.999999\", \"01:01:01.999999\"); -- SUBTIME\n",
            "select timediff(\"1997-01-01 23:59:59.000001\",\"1995-12-31 23:59:59.000002\"); -- TIMEDIFF\n",
            "select timediff(\"1997-12-31 23:59:59.000001\",\"1997-12-30 01:01:01.000002\"); -- TIMEDIFF\n",
            "select timediff(\"1997-12-31 23:59:59.000001\",\"23:59:59.000001\"); -- TIMEDIFF\n",
            "select timediff(\"2000:01:01 00:00:00\", \"2000:01:01 00:00:00.000001\"); -- TIMEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT sys.timestamp_to_str(TIMESTAMP '1997-12-31 23:59:59.000002', 'FF6');\n",
            "SELECT DATE '1997-12-31' - DATE '1997-12-30';\n",
            "SELECT DATE '1997-11-30' - NULL;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '0003-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '0' DAY;\n",
            "SELECT DATE '1997-01-01' + INTERVAL '-1' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '364' DAY;\n",
            "SELECT DATE '9999-01-01' + INTERVAL '365' DAY;\n",
            "SELECT DATE '0100-01-01' + INTERVAL '0' DAY;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.000001' - INTERVAL '1 01:01:01.000002' DAY TO SECOND;\n",
            "SELECT TIMESTAMP '1997-12-31 23:59:59.999999' - TIMESTAMP '1998-01-01 01:01:01.999999';\n",
            "SELECT TIME '01:00:00.999999' - TIME '02:00:00.999998';\n",
            "SELECT TIME '02:01:01.999999' - TIME '01:01:01.999999';\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-01-01 23:59:59.000001' - TIMESTAMP '1995-12-31 23:59:59.000002');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIMESTAMP '1997-12-30 01:01:01.000002');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '1997-12-31 23:59:59.000001' - TIME '23:59:59.000001');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2000-01-01 00:00:00' - TIMESTAMP '2000-01-01 00:00:00.000001');\n"
        ]
    },
    {
        "sql_id": 349,
        "database_name": "BUTTERTrans_349",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select maketime(10,11,12); -- MAKETIME",
        "target_query": "SELECT TIME '10:11:12';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKETIME",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIME 'HH:MI:SS'",
                "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
                "examples": [
                    "SELECT TIME '01:30:45';",
                    "SELECT TIME '12:00:00';",
                    "SELECT TIME '23:59:59';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 350,
        "database_name": "BUTTERTrans_350",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select maketime(20,11,12); -- MAKETIME",
        "target_query": "SELECT TIME '20:11:12';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKETIME",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIME 'HH:MI:SS'",
                "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
                "examples": [
                    "SELECT TIME '01:30:45';",
                    "SELECT TIME '12:00:00';",
                    "SELECT TIME '23:59:59';"
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n"
        ]
    },
    {
        "sql_id": 351,
        "database_name": "BUTTERTrans_351",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP",
        "target_query": "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMP",
                "start_pos": 7,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
                "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
                "examples": [
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n"
        ]
    },
    {
        "sql_id": 352,
        "database_name": "BUTTERTrans_352",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP",
        "target_query": "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMP",
                "start_pos": 7,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
                "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
                "examples": [
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 353,
        "database_name": "BUTTERTrans_353",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP",
        "target_query": "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMP",
                "start_pos": 7,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
                "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
                "examples": [
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 354,
        "database_name": "BUTTERTrans_354",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timestamp(\"2001-12-01\"); -- TIMESTAMP",
        "target_query": "SELECT CAST('2001-12-01' AS TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMESTAMP",
                "start_pos": 7,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMESTAMP('2023-06-15', '10:30:45')",
                "description": "TIMESTAMP is a function in MySQL that combines a date and a time string into a TIMESTAMP value, handling timezone-aware and non-timezone-aware date-time strings.",
                "examples": [
                    "SELECT TIMESTAMP('2023-06-15', '10:30:45');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45+02:00');",
                    "SELECT TIMESTAMP('2023-06-15 10:30:45') > TIMESTAMP('2023-06-14 10:30:45');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CAST('2023-06-15 10:30:45' AS TIMESTAMP)",
                "description": "MonetDB uses CAST to convert a date-time string to a TIMESTAMP value.",
                "examples": [
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP);",
                    "SELECT CAST('2023-06-15 10:30:45' AS TIMESTAMP) > CAST('2023-06-14 10:30:45' AS TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 355,
        "database_name": "BUTTERTrans_355",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select day(\"1997-12-31 23:59:59.000001\"); -- DAY",
        "target_query": "SELECT dayofmonth('1997-12-31 23:59:59.000001');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DAY",
                "start_pos": 7,
                "end_pos": 10
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DAY(date_expr)",
                "description": "Returns the day of the month (1-31) from a date or datetime expression.",
                "examples": [
                    "SELECT DAY('2023-10-15');",
                    "SELECT DAY(NOW());",
                    "SELECT DAY(CAST('2024-02-29 12:34:56' AS DATE));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "dayofmonth(date_expr)",
                "description": "Returns the day part of a DATE or TIMESTAMP value (1\u201331).",
                "examples": [
                    "SELECT dayofmonth(DATE '2023-10-15');",
                    "SELECT dayofmonth(CURRENT_DATE);",
                    "SELECT dayofmonth(TIMESTAMP '2024-02-29 00:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\"); -- TIMESTAMP\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01' AS TIMESTAMP);\n"
        ]
    },
    {
        "sql_id": 356,
        "database_name": "BUTTERTrans_356",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select time(\"1997-12-31 23:59:59.000001\"); -- TIME",
        "target_query": "SELECT sys.timestamp_to_str(CAST('1997-12-31 23:59:59' AS TIMESTAMP), '%H:%M:%S');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIME",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.time_to_str(time-value, format)",
                "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\"); -- TIMESTAMP\n",
            "select day(\"1997-12-31 23:59:59.000001\"); -- DAY\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01' AS TIMESTAMP);\n",
            "SELECT dayofmonth('1997-12-31 23:59:59.000001');\n"
        ]
    },
    {
        "sql_id": 357,
        "database_name": "BUTTERTrans_357",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF",
        "target_query": "SELECT EXTRACT(EPOCH FROM t1 - t4) AS ttt, EXTRACT(EPOCH FROM t2 - t3) AS qqq, EXTRACT(EPOCH FROM t3 - t2) AS eee, EXTRACT(EPOCH FROM t2 - t4) AS rrr FROM test;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            },
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 32,
                "end_pos": 40
            },
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 56,
                "end_pos": 64
            },
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 81,
                "end_pos": 89
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\"); -- TIMESTAMP\n",
            "select day(\"1997-12-31 23:59:59.000001\"); -- DAY\n",
            "select time(\"1997-12-31 23:59:59.000001\"); -- TIME\n",
            "DROP TABLE IF EXISTS test;\n",
            "create table test(t1 datetime, t2 time, t3 time, t4 datetime);\n",
            "insert into test values('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01' AS TIMESTAMP);\n",
            "SELECT dayofmonth('1997-12-31 23:59:59.000001');\n",
            "SELECT sys.timestamp_to_str(CAST('1997-12-31 23:59:59' AS TIMESTAMP), '%H:%M:%S');\n",
            "DROP TABLE IF EXISTS test;\n",
            "CREATE TABLE test(t1 TIMESTAMP, t2 TIME, t3 TIME, t4 TIMESTAMP);\n",
            "INSERT INTO test VALUES('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n"
        ]
    },
    {
        "sql_id": 358,
        "database_name": "BUTTERTrans_358",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select str_to_date(\"2003-01-02 10:11:12.0012\", \"%Y-%m-%d %H:%i:%S.%f\"); -- STR_TO_DATE",
        "target_query": "SELECT str_to_date('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STR_TO_DATE",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STR_TO_DATE('09:22', '%H:%i')",
                "description": "Convert the string '09:22' to a TIME type using the format '%H:%i'.",
                "examples": [
                    "SELECT STR_TO_DATE('12:45', '%H:%i');",
                    "SELECT STR_TO_DATE('2000-01-01', '%Y-%m-%d');",
                    "SELECT STR_TO_DATE('2023-05-06 12:34:56', '%Y-%m-%d %H:%i:%s');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str_to_date('2000-01-01', '%Y-%m-%d')",
                "description": "Converts a string to a date using the specified format, where '%Y-%m-%d' corresponds to the 'Year-Month-Day' format.",
                "examples": [
                    "SELECT str_to_date('2000-01-01', '%Y-%m-%d');",
                    "SELECT str_to_date('2023-05-06', '%Y-%m-%d');",
                    "SELECT str_to_date('1999-12-31', '%Y-%m-%d');"
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\"); -- TIMESTAMP\n",
            "select day(\"1997-12-31 23:59:59.000001\"); -- DAY\n",
            "select time(\"1997-12-31 23:59:59.000001\"); -- TIME\n",
            "DROP TABLE IF EXISTS test;\n",
            "create table test(t1 datetime, t2 time, t3 time, t4 datetime);\n",
            "insert into test values('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n",
            "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01' AS TIMESTAMP);\n",
            "SELECT dayofmonth('1997-12-31 23:59:59.000001');\n",
            "SELECT sys.timestamp_to_str(CAST('1997-12-31 23:59:59' AS TIMESTAMP), '%H:%M:%S');\n",
            "DROP TABLE IF EXISTS test;\n",
            "CREATE TABLE test(t1 TIMESTAMP, t2 TIME, t3 TIME, t4 TIMESTAMP);\n",
            "INSERT INTO test VALUES('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n",
            "SELECT EXTRACT(EPOCH FROM t1 - t4) AS ttt, EXTRACT(EPOCH FROM t2 - t3) AS qqq, EXTRACT(EPOCH FROM t3 - t2) AS eee, EXTRACT(EPOCH FROM t2 - t4) AS rrr FROM test;\n"
        ]
    },
    {
        "sql_id": 359,
        "database_name": "BUTTERTrans_359",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10'),time('00:00:00'); -- TIMEDIFF, TIME",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10'), sys.time_to_str('00:00:00', '%H:%M:%S');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            },
            {
                "dialect_token": "TIME",
                "start_pos": 61,
                "end_pos": 65
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "sys.time_to_str(time-value, format)",
                "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\"); -- TIMESTAMP\n",
            "select day(\"1997-12-31 23:59:59.000001\"); -- DAY\n",
            "select time(\"1997-12-31 23:59:59.000001\"); -- TIME\n",
            "DROP TABLE IF EXISTS test;\n",
            "create table test(t1 datetime, t2 time, t3 time, t4 datetime);\n",
            "insert into test values('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n",
            "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF\n",
            "select str_to_date(\"2003-01-02 10:11:12.0012\", \"%Y-%m-%d %H:%i:%S.%f\"); -- STR_TO_DATE\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01' AS TIMESTAMP);\n",
            "SELECT dayofmonth('1997-12-31 23:59:59.000001');\n",
            "SELECT sys.timestamp_to_str(CAST('1997-12-31 23:59:59' AS TIMESTAMP), '%H:%M:%S');\n",
            "DROP TABLE IF EXISTS test;\n",
            "CREATE TABLE test(t1 TIMESTAMP, t2 TIME, t3 TIME, t4 TIMESTAMP);\n",
            "INSERT INTO test VALUES('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n",
            "SELECT EXTRACT(EPOCH FROM t1 - t4) AS ttt, EXTRACT(EPOCH FROM t2 - t3) AS qqq, EXTRACT(EPOCH FROM t3 - t2) AS eee, EXTRACT(EPOCH FROM t2 - t4) AS rrr FROM test;\n",
            "SELECT str_to_date('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');\n"
        ]
    },
    {
        "sql_id": 360,
        "database_name": "BUTTERTrans_360",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')>time('00:00:00'); -- TIMEDIFF, TIME",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10') > 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            },
            {
                "dialect_token": "TIME",
                "start_pos": 61,
                "end_pos": 65
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "sys.time_to_str(time-value, format)",
                "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\"); -- TIMESTAMP\n",
            "select day(\"1997-12-31 23:59:59.000001\"); -- DAY\n",
            "select time(\"1997-12-31 23:59:59.000001\"); -- TIME\n",
            "DROP TABLE IF EXISTS test;\n",
            "create table test(t1 datetime, t2 time, t3 time, t4 datetime);\n",
            "insert into test values('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n",
            "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF\n",
            "select str_to_date(\"2003-01-02 10:11:12.0012\", \"%Y-%m-%d %H:%i:%S.%f\"); -- STR_TO_DATE\n",
            "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10'),time('00:00:00'); -- TIMEDIFF, TIME\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01' AS TIMESTAMP);\n",
            "SELECT dayofmonth('1997-12-31 23:59:59.000001');\n",
            "SELECT sys.timestamp_to_str(CAST('1997-12-31 23:59:59' AS TIMESTAMP), '%H:%M:%S');\n",
            "DROP TABLE IF EXISTS test;\n",
            "CREATE TABLE test(t1 TIMESTAMP, t2 TIME, t3 TIME, t4 TIMESTAMP);\n",
            "INSERT INTO test VALUES('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n",
            "SELECT EXTRACT(EPOCH FROM t1 - t4) AS ttt, EXTRACT(EPOCH FROM t2 - t3) AS qqq, EXTRACT(EPOCH FROM t3 - t2) AS eee, EXTRACT(EPOCH FROM t2 - t4) AS rrr FROM test;\n",
            "SELECT str_to_date('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10'), sys.time_to_str('00:00:00', '%H:%M:%S');\n"
        ]
    },
    {
        "sql_id": 361,
        "database_name": "BUTTERTrans_361",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')<time('00:00:00'); -- TIMEDIFF, TIME",
        "target_query": "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10') < 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIMEDIFF",
                "start_pos": 7,
                "end_pos": 15
            },
            {
                "dialect_token": "TIME",
                "start_pos": 61,
                "end_pos": 65
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIMEDIFF('12:00:00', '10:00:00')",
                "description": "TIMEDIFF is a function in MySQL that calculates the difference between two time values. The result is a TIME value that represents the time difference.",
                "examples": [
                    "SELECT TIMEDIFF('12:00:00', '10:00:00');",
                    "SELECT TIMEDIFF(NOW(), '2023-06-15 10:00:00');",
                    "SELECT TIMEDIFF('2023-06-15 12:00:00', '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00')",
                "description": "MonetDB does not have a TIMEDIFF function but supports using EXTRACT to calculate the time difference in seconds.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM NOW() - timestamp '2023-06-15 10:00:00');",
                    "SELECT EXTRACT(EPOCH FROM timestamp '2023-06-15 12:00:00' - timestamp '2023-06-15 10:00:00');"
                ]
            },
            {
                "expression": "sys.time_to_str(time-value, format)",
                "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [
            "select maketime(10,11,12); -- MAKETIME\n",
            "select maketime(20,11,12); -- MAKETIME\n",
            "select timestamp(\"2001-12-01\", \"01:01:01.999999\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-10-01\", \"01:01:01.000001\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\", \"20:01:01\"); -- TIMESTAMP\n",
            "select timestamp(\"2001-12-01\"); -- TIMESTAMP\n",
            "select day(\"1997-12-31 23:59:59.000001\"); -- DAY\n",
            "select time(\"1997-12-31 23:59:59.000001\"); -- TIME\n",
            "DROP TABLE IF EXISTS test;\n",
            "create table test(t1 datetime, t2 time, t3 time, t4 datetime);\n",
            "insert into test values('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n",
            "SELECT TIMEDIFF(t1, t4) As ttt, TIMEDIFF(t2, t3) As qqq,TIMEDIFF(t3, t2) As eee, TIMEDIFF(t2, t4) As rrr from test; -- TIMEDIFF\n",
            "select str_to_date(\"2003-01-02 10:11:12.0012\", \"%Y-%m-%d %H:%i:%S.%f\"); -- STR_TO_DATE\n",
            "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10'),time('00:00:00'); -- TIMEDIFF, TIME\n",
            "select timediff('2008-09-29 20:10:10','2008-09-30 20:10:10')>time('00:00:00'); -- TIMEDIFF, TIME\n"
        ],
        "target_related_schemas": [
            "SELECT TIME '10:11:12';\n",
            "SELECT TIME '20:11:12';\n",
            "SELECT CAST('2001-12-01 01:01:01.999999' AS TIMESTAMP);\n",
            "SELECT CAST('2001-10-01 01:01:01.000001' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01 20:01:01' AS TIMESTAMP);\n",
            "SELECT CAST('2001-12-01' AS TIMESTAMP);\n",
            "SELECT dayofmonth('1997-12-31 23:59:59.000001');\n",
            "SELECT sys.timestamp_to_str(CAST('1997-12-31 23:59:59' AS TIMESTAMP), '%H:%M:%S');\n",
            "DROP TABLE IF EXISTS test;\n",
            "CREATE TABLE test(t1 TIMESTAMP, t2 TIME, t3 TIME, t4 TIMESTAMP);\n",
            "INSERT INTO test VALUES('2001-01-01 01:01:01', '01:01:01', null, '2001-02-01 01:01:01'),('2001-01-01 01:01:01', '23:58:59', '00:00:01', '1997-12-31 23:59:59.000001'),('1997-12-31 23:59:59.000001', '00:00:01', '23:58:59', '2001-01-01 01:01:01'),(NULL, NULL, NULL, NULL);\n",
            "SELECT EXTRACT(EPOCH FROM t1 - t4) AS ttt, EXTRACT(EPOCH FROM t2 - t3) AS qqq, EXTRACT(EPOCH FROM t3 - t2) AS eee, EXTRACT(EPOCH FROM t2 - t4) AS rrr FROM test;\n",
            "SELECT str_to_date('2003-01-02 10:11:12', '%Y-%m-%d %H:%M:%S');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10'), sys.time_to_str('00:00:00', '%H:%M:%S');\n",
            "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2008-09-29 20:10:10' - TIMESTAMP '2008-09-30 20:10:10') > 0;\n"
        ]
    },
    {
        "sql_id": 362,
        "database_name": "BUTTERTrans_362",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME",
        "target_query": "SELECT LPAD(CAST(CASE WHEN 86399 / 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = sys.time_to_str(TIME '23:59:59', '%H:%M:%S');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "SEC_TO_TIME",
                "start_pos": 7,
                "end_pos": 18
            },
            {
                "dialect_token": "TIME",
                "start_pos": 26,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SEC_TO_TIME(seconds)",
                "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
                "examples": [
                    "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
                    "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
                    "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
                ]
            },
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t;",
                "description": "In MonetDB, SEC_TO_TIME is not natively supported, but we can simulate it by converting seconds into hours, minutes, and seconds. We use LPAD to ensure the time components are always two digits. Additionally, we use a CASE expression to handle the special case when 24 hours are calculated, resetting it to '00' to correctly represent the time at midnight.",
                "examples": [
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3661 AS seconds) AS t,; -- Returns '01:01:01'",
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3600 AS seconds) AS t; -- Returns '01:00:00'",
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t; -- Returns '00:00:00'"
                ]
            },
            {
                "expression": "sys.time_to_str(time-value, format)",
                "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 363,
        "database_name": "BUTTERTrans_363",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME",
        "target_query": "SELECT LPAD(CAST(CASE WHEN 86399/ 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = '23:59:59';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "SEC_TO_TIME",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "SEC_TO_TIME(seconds)",
                "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
                "examples": [
                    "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
                    "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
                    "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t;",
                "description": "In MonetDB, SEC_TO_TIME is not natively supported, but we can simulate it by converting seconds into hours, minutes, and seconds. We use LPAD to ensure the time components are always two digits. Additionally, we use a CASE expression to handle the special case when 24 hours are calculated, resetting it to '00' to correctly represent the time at midnight.",
                "examples": [
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3661 AS seconds) AS t,; -- Returns '01:01:01'",
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3600 AS seconds) AS t; -- Returns '01:00:00'",
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t; -- Returns '00:00:00'"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME\n"
        ],
        "target_related_schemas": [
            "SELECT LPAD(CAST(CASE WHEN 86399 / 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = sys.time_to_str(TIME '23:59:59', '%H:%M:%S');\n"
        ]
    },
    {
        "sql_id": 364,
        "database_name": "BUTTERTrans_364",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT time(sec_to_time(86399))=TIME('23:59:59'); -- TIME, SEC_TO_TIME",
        "target_query": "SELECT sys.time_to_str(CAST(LPAD(CAST(86399/3600 AS STRING),2,'0')||':'||LPAD(CAST((86399%3600)/60 AS STRING),2,'0')||':'||LPAD(CAST(86399%60 AS STRING),2,'0') AS TIME),'%H:%M:%S')=sys.time_to_str(TIME'23:59:59','%H:%M:%S');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIME",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "SEC_TO_TIME",
                "start_pos": 12,
                "end_pos": 23
            },
            {
                "dialect_token": "TIME",
                "start_pos": 32,
                "end_pos": 36
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            },
            {
                "expression": "SEC_TO_TIME(seconds)",
                "description": "Converts the given number of seconds into a time value in the format HH:MM:SS. Wraps around if seconds exceed 86400.",
                "examples": [
                    "SELECT SEC_TO_TIME(3661); -- Returns '01:01:01'",
                    "SELECT SEC_TO_TIME(3600); -- Returns '01:00:00'",
                    "SELECT SEC_TO_TIME(86400); -- Returns '00:00:00'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.time_to_str(time-value, format)",
                "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            },
            {
                "expression": "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t;",
                "description": "In MonetDB, SEC_TO_TIME is not natively supported, but we can simulate it by converting seconds into hours, minutes, and seconds. We use LPAD to ensure the time components are always two digits. Additionally, we use a CASE expression to handle the special case when 24 hours are calculated, resetting it to '00' to correctly represent the time at midnight.",
                "examples": [
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3661 AS seconds) AS t,; -- Returns '01:01:01'",
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 3600 AS seconds) AS t; -- Returns '01:00:00'",
                    "SELECT LPAD(CAST(CASE WHEN seconds / 3600 = 24 THEN 0 ELSE seconds / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((seconds % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(seconds % 60 AS STRING), 2, '0') FROM (SELECT 86400 AS seconds) AS t; -- Returns '00:00:00'"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME\n",
            "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME\n"
        ],
        "target_related_schemas": [
            "SELECT LPAD(CAST(CASE WHEN 86399 / 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = sys.time_to_str(TIME '23:59:59', '%H:%M:%S');\n",
            "SELECT LPAD(CAST(CASE WHEN 86399/ 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = '23:59:59';\n"
        ]
    },
    {
        "sql_id": 365,
        "database_name": "BUTTERTrans_365",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT maketime(1,0,1)='01:00:01'; -- MAKETIME",
        "target_query": "SELECT TIME '01:00:01' = '01:00:01';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKETIME",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIME 'HH:MI:SS'",
                "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
                "examples": [
                    "SELECT TIME '01:30:45';",
                    "SELECT TIME '12:00:00';",
                    "SELECT TIME '23:59:59';"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME\n",
            "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME\n",
            "SELECT time(sec_to_time(86399))=TIME('23:59:59'); -- TIME, SEC_TO_TIME\n"
        ],
        "target_related_schemas": [
            "SELECT LPAD(CAST(CASE WHEN 86399 / 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = sys.time_to_str(TIME '23:59:59', '%H:%M:%S');\n",
            "SELECT LPAD(CAST(CASE WHEN 86399/ 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = '23:59:59';\n",
            "SELECT sys.time_to_str(CAST(LPAD(CAST(86399/3600 AS STRING),2,'0')||':'||LPAD(CAST((86399%3600)/60 AS STRING),2,'0')||':'||LPAD(CAST(86399%60 AS STRING),2,'0') AS TIME),'%H:%M:%S')=sys.time_to_str(TIME'23:59:59','%H:%M:%S');\n"
        ]
    },
    {
        "sql_id": 366,
        "database_name": "BUTTERTrans_366",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TIME(maketime(1,0,1))=CAST('01:00:01' AS TIME); -- TIME, MAKETIME",
        "target_query": "SELECT sys.time_to_str(TIME '01:00:01', '%H:%M:%S') = CAST('01:00:01' AS TIME);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TIME",
                "start_pos": 7,
                "end_pos": 11
            },
            {
                "dialect_token": "MAKETIME",
                "start_pos": 12,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TIME(time-value) | TIME_FORMAT(time-value, format)",
                "description": "The TIME(time-value) function in MySQL returns the time as text formatted as 'HH:MM:SS' from a given time-value. MySQL's TIME function does not support modifiers like in SQLite. To modify the time, you can use functions like DATE_ADD (to add an interval) or TIME_FORMAT (to custom format the time, including fractional seconds).",
                "examples": [
                    "SELECT TIME(NOW()); -- Returns the current time, formatted as 'HH:MM:SS'.",
                    "SELECT TIME(DATE_ADD(NOW(), INTERVAL 1 HOUR)); -- Adds 1 hour to the time, returning '15:16:00'.",
                    "SELECT TIME_FORMAT('14:16:00.123456', '%H:%i:%s.%f'); -- Returns '14:16:00.123456' with fractional seconds."
                ]
            },
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.time_to_str(time-value, format)",
                "description": "In MonetDB, the TIME function from SQLite can be emulated using sys.time_to_str to format TIME values as strings in the format 'HH:MM:SS' or 'HH:MM:SS.SSS'. Time arithmetic can be performed using sql_add with INTERVAL expressions.",
                "examples": [
                    "SELECT sys.time_to_str(CURRENT_TIME, '%H:%M:%S'); -- Returns the current time formatted as HH:MM:SS.",
                    "SELECT sys.time_to_str(sql_add(CURRENT_TIME, interval '1' hour), '%H:%M:%S'); -- Returns the time one hour after the current time.",
                    "SELECT sys.time_to_str(time '14:16:00', '%H:%M:%S.000'); -- Returns '14:16:00.000' with milliseconds."
                ]
            },
            {
                "expression": "TIME 'HH:MI:SS'",
                "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
                "examples": [
                    "SELECT TIME '01:30:45';",
                    "SELECT TIME '12:00:00';",
                    "SELECT TIME '23:59:59';"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME\n",
            "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME\n",
            "SELECT time(sec_to_time(86399))=TIME('23:59:59'); -- TIME, SEC_TO_TIME\n",
            "SELECT maketime(1,0,1)='01:00:01'; -- MAKETIME\n"
        ],
        "target_related_schemas": [
            "SELECT LPAD(CAST(CASE WHEN 86399 / 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = sys.time_to_str(TIME '23:59:59', '%H:%M:%S');\n",
            "SELECT LPAD(CAST(CASE WHEN 86399/ 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = '23:59:59';\n",
            "SELECT sys.time_to_str(CAST(LPAD(CAST(86399/3600 AS STRING),2,'0')||':'||LPAD(CAST((86399%3600)/60 AS STRING),2,'0')||':'||LPAD(CAST(86399%60 AS STRING),2,'0') AS TIME),'%H:%M:%S')=sys.time_to_str(TIME'23:59:59','%H:%M:%S');\n",
            "SELECT TIME '01:00:01' = '01:00:01';\n"
        ]
    },
    {
        "sql_id": 367,
        "database_name": "BUTTERTrans_367",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT maketime(1,0,1)=CAST('01:00:01' AS TIME); -- MAKETIME",
        "target_query": "SELECT TIME '01:00:01' = CAST('01:00:01' AS TIME);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKETIME",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIME 'HH:MI:SS'",
                "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
                "examples": [
                    "SELECT TIME '01:30:45';",
                    "SELECT TIME '12:00:00';",
                    "SELECT TIME '23:59:59';"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT sec_to_time(86399)=TIME('23:59:59'); -- SEC_TO_TIME, TIME\n",
            "SELECT sec_to_time(86399)='23:59:59'; -- SEC_TO_TIME\n",
            "SELECT time(sec_to_time(86399))=TIME('23:59:59'); -- TIME, SEC_TO_TIME\n",
            "SELECT maketime(1,0,1)='01:00:01'; -- MAKETIME\n",
            "SELECT TIME(maketime(1,0,1))=CAST('01:00:01' AS TIME); -- TIME, MAKETIME\n"
        ],
        "target_related_schemas": [
            "SELECT LPAD(CAST(CASE WHEN 86399 / 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = sys.time_to_str(TIME '23:59:59', '%H:%M:%S');\n",
            "SELECT LPAD(CAST(CASE WHEN 86399/ 3600 = 24 THEN 0 ELSE 86399 / 3600 END AS STRING), 2, '0') || ':' || LPAD(CAST((86399 % 3600) / 60 AS STRING), 2, '0') || ':' || LPAD(CAST(86399 % 60 AS STRING), 2, '0') = '23:59:59';\n",
            "SELECT sys.time_to_str(CAST(LPAD(CAST(86399/3600 AS STRING),2,'0')||':'||LPAD(CAST((86399%3600)/60 AS STRING),2,'0')||':'||LPAD(CAST(86399%60 AS STRING),2,'0') AS TIME),'%H:%M:%S')=sys.time_to_str(TIME'23:59:59','%H:%M:%S');\n",
            "SELECT TIME '01:00:01' = '01:00:01';\n",
            "SELECT sys.time_to_str(TIME '01:00:01', '%H:%M:%S') = CAST('01:00:01' AS TIME);\n"
        ]
    },
    {
        "sql_id": 368,
        "database_name": "BUTTERTrans_368",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT maketime(1,0,1)=CAST('01:00:02' AS TIME); -- MAKETIME",
        "target_query": "SELECT TIME '01:00:01' = CAST('01:00:02' AS TIME);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "MAKETIME",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "MAKETIME(hours, minutes, seconds)",
                "description": "Creates a time value from the provided hours, minutes, and seconds.",
                "examples": [
                    "SELECT MAKETIME(1, 30, 45);",
                    "SELECT MAKETIME(12, 0, 0);",
                    "SELECT MAKETIME(23, 59, 59);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIME 'HH:MI:SS'",
                "description": "MonetDB supports creating time values by directly using the TIME keyword with the format 'HH:MI:SS'.",
                "examples": [
                    "SELECT TIME '01:30:45';",
                    "SELECT TIME '12:00:00';",
                    "SELECT TIME '23:59:59';"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 369,
        "database_name": "BUTTERTrans_369",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP",
        "target_query": "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 34,
                "end_pos": 40
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 55,
                "end_pos": 61
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 71,
                "end_pos": 77
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 370,
        "database_name": "BUTTERTrans_370",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST",
        "target_query": "SELECT GREATEST(d,d) FROM t1 WHERE k=2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES (\"abc\", 2);\n"
        ],
        "target_related_schemas": [
            "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES ('abc', 2);\n"
        ]
    },
    {
        "sql_id": 371,
        "database_name": "BUTTERTrans_371",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST",
        "target_query": "SELECT GREATEST(123456789, 234567890) AS g;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES (\"abc\", 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES ('abc', 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 372,
        "database_name": "BUTTERTrans_372",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT least   ( 123456789 , 234567890 ) as l; -- LEAST",
        "target_query": "SELECT CASE WHEN 123456789 <= 234567890 THEN 123456789 ELSE 234567890 END AS l;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES (\"abc\", 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST\n",
            "DROP TABLE t1;\n",
            "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES ('abc', 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2;\n",
            "DROP TABLE t1;\n",
            "SELECT GREATEST(123456789, 234567890) AS g;\n"
        ]
    },
    {
        "sql_id": 373,
        "database_name": "BUTTERTrans_373",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT greatest (123456789, -1, 234567890 ) as g; -- GREATEST",
        "target_query": "SELECT GREATEST(123456789, -1, 234567890) AS g;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES (\"abc\", 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST\n",
            "DROP TABLE t1;\n",
            "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST\n",
            "SELECT least   ( 123456789 , 234567890 ) as l; -- LEAST\n"
        ],
        "target_related_schemas": [
            "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES ('abc', 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2;\n",
            "DROP TABLE t1;\n",
            "SELECT GREATEST(123456789, 234567890) AS g;\n",
            "SELECT CASE WHEN 123456789 <= 234567890 THEN 123456789 ELSE 234567890 END AS l;\n"
        ]
    },
    {
        "sql_id": 374,
        "database_name": "BUTTERTrans_374",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT least    (123456789, -1, 234567890 ) as l; -- LEAST",
        "target_query": "SELECT CASE WHEN 123456789 <= -1 AND 123456789 <= 234567890 THEN 123456789 WHEN -1 <= 234567890 THEN -1 ELSE 234567890 END AS l;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES (\"abc\", 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST\n",
            "DROP TABLE t1;\n",
            "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST\n",
            "SELECT least   ( 123456789 , 234567890 ) as l; -- LEAST\n",
            "SELECT greatest (123456789, -1, 234567890 ) as g; -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES ('abc', 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2;\n",
            "DROP TABLE t1;\n",
            "SELECT GREATEST(123456789, 234567890) AS g;\n",
            "SELECT CASE WHEN 123456789 <= 234567890 THEN 123456789 ELSE 234567890 END AS l;\n",
            "SELECT GREATEST(123456789, -1, 234567890) AS g;\n"
        ]
    },
    {
        "sql_id": 375,
        "database_name": "BUTTERTrans_375",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t1 AS SELECT greatest(-1, 123456789); -- GREATEST",
        "target_query": "CREATE TABLE t1 AS SELECT GREATEST(-1, 123456789);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 26,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "select 0=0,1>0,1>=1,1<0,1<=0,1!=0,strcmp(\"abc\",\"abcd\"),strcmp(\"b\",\"a\"),strcmp(\"a\",\"a\") ; -- STRCMP\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES (\"abc\", 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2; -- GREATEST\n",
            "DROP TABLE t1;\n",
            "SELECT greatest( 123456789 , 234567890 ) as g; -- GREATEST\n",
            "SELECT least   ( 123456789 , 234567890 ) as l; -- LEAST\n",
            "SELECT greatest (123456789, -1, 234567890 ) as g; -- GREATEST\n",
            "SELECT least    (123456789, -1, 234567890 ) as l; -- LEAST\n"
        ],
        "target_related_schemas": [
            "SELECT 0=0, 1>0, 1>=1, 1<0, 1<=0, 1!=0, CASE WHEN 'abc' = 'abcd' THEN 0 WHEN 'abc' < 'abcd' THEN -1 ELSE 1 END, CASE WHEN 'b' = 'a' THEN 0 WHEN 'b' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'a' THEN 0 WHEN 'a' < 'a' THEN -1 ELSE 1 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (d varchar(6), k int);\n",
            "INSERT INTO t1 VALUES ('abc', 2);\n",
            "SELECT GREATEST(d,d) FROM t1 WHERE k=2;\n",
            "DROP TABLE t1;\n",
            "SELECT GREATEST(123456789, 234567890) AS g;\n",
            "SELECT CASE WHEN 123456789 <= 234567890 THEN 123456789 ELSE 234567890 END AS l;\n",
            "SELECT GREATEST(123456789, -1, 234567890) AS g;\n",
            "SELECT CASE WHEN 123456789 <= -1 AND 123456789 <= 234567890 THEN 123456789 WHEN -1 <= 234567890 THEN -1 ELSE 234567890 END AS l;\n"
        ]
    },
    {
        "sql_id": 376,
        "database_name": "BUTTERTrans_376",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT c1, LENGTH(c1) FROM h; -- LENGTH",
        "target_query": "SELECT c1, octet_length(c1) FROM h; -- LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 11,
                "end_pos": 17
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n"
        ]
    },
    {
        "sql_id": 377,
        "database_name": "BUTTERTrans_377",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD",
        "target_query": "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 11,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, LENGTH(c1) FROM h; -- LENGTH\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, octet_length(c1) FROM h; -- LENGTH\n"
        ]
    },
    {
        "sql_id": 378,
        "database_name": "BUTTERTrans_378",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
        "target_query": "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 11,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, LENGTH(c1) FROM h; -- LENGTH\n",
            "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, octet_length(c1) FROM h; -- LENGTH\n",
            "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;\n"
        ]
    },
    {
        "sql_id": 379,
        "database_name": "BUTTERTrans_379",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT INSTR(c1, 'h') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('h' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "INSTR",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "position(substr in str)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT position('bar' in 'foobar');   -- Returns 4",
                    "SELECT position('x' in 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, LENGTH(c1) FROM h; -- LENGTH\n",
            "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, octet_length(c1) FROM h; -- LENGTH\n",
            "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n"
        ]
    },
    {
        "sql_id": 380,
        "database_name": "BUTTERTrans_380",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT INSTR(c1, '') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "INSTR",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "position(substr in str)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT position('bar' in 'foobar');   -- Returns 4",
                    "SELECT position('x' in 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, LENGTH(c1) FROM h; -- LENGTH\n",
            "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT INSTR(c1, 'h') FROM h; -- INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, octet_length(c1) FROM h; -- LENGTH\n",
            "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT POSITION('h' in c1) FROM h; -- INSTR\n"
        ]
    },
    {
        "sql_id": 381,
        "database_name": "BUTTERTrans_381",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT INSTR(c1, '52') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('52' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "INSTR",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "position(substr in str)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT position('bar' in 'foobar');   -- Returns 4",
                    "SELECT position('x' in 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, LENGTH(c1) FROM h; -- LENGTH\n",
            "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT INSTR(c1, 'h') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '') FROM h; -- INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, octet_length(c1) FROM h; -- LENGTH\n",
            "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT POSITION('h' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('' in c1) FROM h; -- INSTR\n"
        ]
    },
    {
        "sql_id": 382,
        "database_name": "BUTTERTrans_382",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT INSTR(c1, '54') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('54' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "INSTR",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "position(substr in str)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT position('bar' in 'foobar');   -- Returns 4",
                    "SELECT position('x' in 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, LENGTH(c1) FROM h; -- LENGTH\n",
            "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT INSTR(c1, 'h') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '52') FROM h; -- INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, octet_length(c1) FROM h; -- LENGTH\n",
            "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT POSITION('h' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('52' in c1) FROM h; -- INSTR\n"
        ]
    },
    {
        "sql_id": 383,
        "database_name": "BUTTERTrans_383",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT INSTR(c1, '31') FROM h; -- INSTR",
        "target_query": "SELECT POSITION('31' in c1) FROM h; -- INSTR",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "INSTR",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "INSTR(str, substr)",
                "description": "Returns the position of the first occurrence of substr in str, starting from 1. Returns 0 if not found. If substr is an empty string, returns 1. NULL if either argument is NULL.",
                "examples": [
                    "SELECT INSTR('foobar', 'bar');  -- Returns 4",
                    "SELECT INSTR('foobar', 'baz');  -- Returns 0",
                    "SELECT INSTR('foobar', '');     -- Returns 1",
                    "SELECT INSTR(NULL, 'bar');      -- Returns NULL"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "position(substr in str)",
                "description": "Returns the position of substr in str (1-based). Returns 0 if not found.",
                "examples": [
                    "SELECT position('bar' in 'foobar');   -- Returns 4",
                    "SELECT position('x' in 'abc');        -- Returns 0"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, LENGTH(c1) FROM h; -- LENGTH\n",
            "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT INSTR(c1, 'h') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '52') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '54') FROM h; -- INSTR\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, octet_length(c1) FROM h; -- LENGTH\n",
            "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT POSITION('h' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('52' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('54' in c1) FROM h; -- INSTR\n"
        ]
    },
    {
        "sql_id": 384,
        "database_name": "BUTTERTrans_384",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
        "target_query": "SELECT c1, TRIM(c1) FROM h; -- TRIM",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TRIM",
                "start_pos": 11,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, LENGTH(c1) FROM h; -- LENGTH\n",
            "SELECT c1, LPAD(c1, 20, ' ') FROM h; -- LPAD\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT INSTR(c1, 'h') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '52') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '54') FROM h; -- INSTR\n",
            "SELECT INSTR(c1, '31') FROM h; -- INSTR\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315253');\n",
            "INSERT INTO h VALUES ('h31525352');\n",
            "INSERT INTO h VALUES ('h3152535252');\n",
            "INSERT INTO h VALUES ('h315253525252');\n",
            "INSERT INTO h VALUES ('52h315253');\n",
            "INSERT INTO h VALUES ('5252h315253');\n",
            "INSERT INTO h VALUES ('525252h315253');\n",
            "INSERT INTO h VALUES ('   h315253   ');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS h;\n",
            "CREATE TABLE h (c1 CHAR(20));\n",
            "INSERT INTO h VALUES ('12345678900987654321'), ('h\u04bc'), ('\u07f0'), ('\u02ae'), (''), ('50515253');\n",
            "INSERT INTO h VALUES ('31'), ('h31'), ('2805');\n",
            "SELECT c1, octet_length(c1) FROM h; -- LENGTH\n",
            "SELECT c1, CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH(c1))), c1) FROM h;\n",
            "SELECT c1, RPAD(c1, 20, '52') FROM h; -- RPAD\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315254');\n",
            "SELECT POSITION('h' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('52' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('54' in c1) FROM h; -- INSTR\n",
            "SELECT POSITION('31' in c1) FROM h; -- INSTR\n",
            "TRUNCATE h;\n",
            "INSERT INTO h VALUES ('h315253');\n",
            "INSERT INTO h VALUES ('h31525352');\n",
            "INSERT INTO h VALUES ('h3152535252');\n",
            "INSERT INTO h VALUES ('h315253525252');\n",
            "INSERT INTO h VALUES ('52h315253');\n",
            "INSERT INTO h VALUES ('5252h315253');\n",
            "INSERT INTO h VALUES ('525252h315253');\n",
            "INSERT INTO h VALUES ('   h315253   ');\n"
        ]
    },
    {
        "sql_id": 385,
        "database_name": "BUTTERTrans_385",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST('11', '5', '2'); -- GREATEST",
        "target_query": "SELECT GREATEST('11', '5', '2');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 386,
        "database_name": "BUTTERTrans_386",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST('11', 5, 2); -- GREATEST",
        "target_query": "SELECT GREATEST('11', 5, 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n"
        ]
    },
    {
        "sql_id": 387,
        "database_name": "BUTTERTrans_387",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST(11, 5, 2); -- GREATEST",
        "target_query": "SELECT GREATEST(11, 5, 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n"
        ]
    },
    {
        "sql_id": 388,
        "database_name": "BUTTERTrans_388",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LEAST('11', '5', '2'); -- LEAST",
        "target_query": "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n"
        ]
    },
    {
        "sql_id": 389,
        "database_name": "BUTTERTrans_389",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LEAST('11', 5, 2); -- LEAST",
        "target_query": "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n"
        ]
    },
    {
        "sql_id": 390,
        "database_name": "BUTTERTrans_390",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LEAST(11, 5, 2); -- LEAST",
        "target_query": "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n"
        ]
    },
    {
        "sql_id": 391,
        "database_name": "BUTTERTrans_391",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST",
        "target_query": "SELECT GREATEST('11', '5', '2') + 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n"
        ]
    },
    {
        "sql_id": 392,
        "database_name": "BUTTERTrans_392",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST",
        "target_query": "SELECT GREATEST('11', 5, 2) + 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n"
        ]
    },
    {
        "sql_id": 393,
        "database_name": "BUTTERTrans_393",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST",
        "target_query": "SELECT GREATEST(11, 5, 2) + 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n",
            "SELECT GREATEST('11', 5, 2) + 0;\n"
        ]
    },
    {
        "sql_id": 394,
        "database_name": "BUTTERTrans_394",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST",
        "target_query": "SELECT GREATEST('11', '5', '2') + 0.00;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n",
            "SELECT GREATEST('11', 5, 2) + 0;\n",
            "SELECT GREATEST(11, 5, 2) + 0;\n"
        ]
    },
    {
        "sql_id": 395,
        "database_name": "BUTTERTrans_395",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST",
        "target_query": "SELECT GREATEST('11', 5, 2) + 0.00;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n",
            "SELECT GREATEST('11', 5, 2) + 0;\n",
            "SELECT GREATEST(11, 5, 2) + 0;\n",
            "SELECT GREATEST('11', '5', '2') + 0.00;\n"
        ]
    },
    {
        "sql_id": 396,
        "database_name": "BUTTERTrans_396",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST",
        "target_query": "SELECT GREATEST(11, 5, 2) + 0.00;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n",
            "SELECT GREATEST('11', 5, 2) + 0;\n",
            "SELECT GREATEST(11, 5, 2) + 0;\n",
            "SELECT GREATEST('11', '5', '2') + 0.00;\n",
            "SELECT GREATEST('11', 5, 2) + 0.00;\n"
        ]
    },
    {
        "sql_id": 397,
        "database_name": "BUTTERTrans_397",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT greatest(18446744073709551615, NULL)FROM t0017; -- GREATEST",
        "target_query": "SELECT GREATEST(18446744073709551615, NULL) FROM t0017;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 7,
                "end_pos": 15
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST\n",
            "DROP TABLE IF EXISTS t0017;\n",
            "CREATE TABLE t0017 (c0002 bigint(20) NOT NULL);\n",
            "INSERT INTO t0017 (c0002)VALUES (0);\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n",
            "SELECT GREATEST('11', 5, 2) + 0;\n",
            "SELECT GREATEST(11, 5, 2) + 0;\n",
            "SELECT GREATEST('11', '5', '2') + 0.00;\n",
            "SELECT GREATEST('11', 5, 2) + 0.00;\n",
            "SELECT GREATEST(11, 5, 2) + 0.00;\n",
            "DROP TABLE IF EXISTS t0017;\n",
            "CREATE TABLE t0017 (c0002 BIGINT NOT NULL);\n",
            "INSERT INTO t0017 (c0002) VALUES (0);\n"
        ]
    },
    {
        "sql_id": 398,
        "database_name": "BUTTERTrans_398",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1); -- GREATEST",
        "target_query": "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GREATEST",
                "start_pos": 24,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST\n",
            "DROP TABLE IF EXISTS t0017;\n",
            "CREATE TABLE t0017 (c0002 bigint(20) NOT NULL);\n",
            "INSERT INTO t0017 (c0002)VALUES (0);\n",
            "SELECT greatest(18446744073709551615, NULL)FROM t0017; -- GREATEST\n",
            "DROP TABLE t0017;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 INT, c2 INT);\n",
            "INSERT INTO t1 VALUES (202, 1);\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n",
            "SELECT GREATEST('11', 5, 2) + 0;\n",
            "SELECT GREATEST(11, 5, 2) + 0;\n",
            "SELECT GREATEST('11', '5', '2') + 0.00;\n",
            "SELECT GREATEST('11', 5, 2) + 0.00;\n",
            "SELECT GREATEST(11, 5, 2) + 0.00;\n",
            "DROP TABLE IF EXISTS t0017;\n",
            "CREATE TABLE t0017 (c0002 BIGINT NOT NULL);\n",
            "INSERT INTO t0017 (c0002) VALUES (0);\n",
            "SELECT GREATEST(18446744073709551615, NULL) FROM t0017;\n",
            "DROP TABLE t0017;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 INT, c2 INT);\n",
            "INSERT INTO t1 VALUES (202, 1);\n"
        ]
    },
    {
        "sql_id": 399,
        "database_name": "BUTTERTrans_399",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT SUM(LEAST(a, b)) FROM t1; -- LEAST",
        "target_query": "SELECT SUM(CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 11,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST\n",
            "DROP TABLE IF EXISTS t0017;\n",
            "CREATE TABLE t0017 (c0002 bigint(20) NOT NULL);\n",
            "INSERT INTO t0017 (c0002)VALUES (0);\n",
            "SELECT greatest(18446744073709551615, NULL)FROM t0017; -- GREATEST\n",
            "DROP TABLE t0017;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 INT, c2 INT);\n",
            "INSERT INTO t1 VALUES (202, 1);\n",
            "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1); -- GREATEST\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DOUBLE, b DOUBLE);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a INTEGER, b INTEGER);\n",
            "INSERT INTO t1 values(1, NULL), (1, 1);\n",
            "INSERT INTO t2 values(1, NULL), (1, 1);\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n",
            "SELECT GREATEST('11', 5, 2) + 0;\n",
            "SELECT GREATEST(11, 5, 2) + 0;\n",
            "SELECT GREATEST('11', '5', '2') + 0.00;\n",
            "SELECT GREATEST('11', 5, 2) + 0.00;\n",
            "SELECT GREATEST(11, 5, 2) + 0.00;\n",
            "DROP TABLE IF EXISTS t0017;\n",
            "CREATE TABLE t0017 (c0002 BIGINT NOT NULL);\n",
            "INSERT INTO t0017 (c0002) VALUES (0);\n",
            "SELECT GREATEST(18446744073709551615, NULL) FROM t0017;\n",
            "DROP TABLE t0017;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 INT, c2 INT);\n",
            "INSERT INTO t1 VALUES (202, 1);\n",
            "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DOUBLE, b DOUBLE);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a INTEGER, b INTEGER);\n",
            "INSERT INTO t1 VALUES (1, NULL), (1, 1);\n",
            "INSERT INTO t2 VALUES (1, NULL), (1, 1);\n"
        ]
    },
    {
        "sql_id": 400,
        "database_name": "BUTTERTrans_400",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT SUM(LEAST(a, b)) FROM t2; -- LEAST",
        "target_query": "SELECT SUM(CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END) FROM t2;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LEAST",
                "start_pos": 11,
                "end_pos": 16
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT GREATEST('11', '5', '2'); -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2); -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2); -- GREATEST\n",
            "SELECT LEAST('11', '5', '2'); -- LEAST\n",
            "SELECT LEAST('11', 5, 2); -- LEAST\n",
            "SELECT LEAST(11, 5, 2); -- LEAST\n",
            "SELECT GREATEST('11', '5', '2') + 0; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0; -- GREATEST\n",
            "SELECT GREATEST('11', '5', '2') + 0.00; -- GREATEST\n",
            "SELECT GREATEST('11', 5, 2) + 0.00; -- GREATEST\n",
            "SELECT GREATEST(11, 5, 2) + 0.00; -- GREATEST\n",
            "DROP TABLE IF EXISTS t0017;\n",
            "CREATE TABLE t0017 (c0002 bigint(20) NOT NULL);\n",
            "INSERT INTO t0017 (c0002)VALUES (0);\n",
            "SELECT greatest(18446744073709551615, NULL)FROM t0017; -- GREATEST\n",
            "DROP TABLE t0017;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 INT, c2 INT);\n",
            "INSERT INTO t1 VALUES (202, 1);\n",
            "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1); -- GREATEST\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DOUBLE, b DOUBLE);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a INTEGER, b INTEGER);\n",
            "INSERT INTO t1 values(1, NULL), (1, 1);\n",
            "INSERT INTO t2 values(1, NULL), (1, 1);\n",
            "SELECT SUM(LEAST(a, b)) FROM t1; -- LEAST\n"
        ],
        "target_related_schemas": [
            "SELECT GREATEST('11', '5', '2');\n",
            "SELECT GREATEST('11', 5, 2);\n",
            "SELECT GREATEST(11, 5, 2);\n",
            "SELECT CASE WHEN '11' IS NULL THEN '5' WHEN '5' IS NULL THEN '11' WHEN '11' <= '5' AND '11' <= '2' THEN '11' WHEN '5' <= '2' THEN '5' ELSE '2' END;\n",
            "SELECT CASE WHEN '11' IS NULL THEN 5 WHEN 5 IS NULL THEN '11' WHEN '11' <= 5 AND '11' <= 2 THEN '11' WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT CASE WHEN 11 IS NULL THEN 5 WHEN 5 IS NULL THEN 11 WHEN 11 <= 5 AND 11 <= 2 THEN 11 WHEN 5 <= 2 THEN 5 ELSE 2 END;\n",
            "SELECT GREATEST('11', '5', '2') + 0;\n",
            "SELECT GREATEST('11', 5, 2) + 0;\n",
            "SELECT GREATEST(11, 5, 2) + 0;\n",
            "SELECT GREATEST('11', '5', '2') + 0.00;\n",
            "SELECT GREATEST('11', 5, 2) + 0.00;\n",
            "SELECT GREATEST(11, 5, 2) + 0.00;\n",
            "DROP TABLE IF EXISTS t0017;\n",
            "CREATE TABLE t0017 (c0002 BIGINT NOT NULL);\n",
            "INSERT INTO t0017 (c0002) VALUES (0);\n",
            "SELECT GREATEST(18446744073709551615, NULL) FROM t0017;\n",
            "DROP TABLE t0017;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 INT, c2 INT);\n",
            "INSERT INTO t1 VALUES (202, 1);\n",
            "SELECT * FROM t1 WHERE (GREATEST(c1, c2) = 42) AND (c2 = 1);\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DOUBLE, b DOUBLE);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (a INTEGER, b INTEGER);\n",
            "INSERT INTO t1 VALUES (1, NULL), (1, 1);\n",
            "INSERT INTO t2 VALUES (1, NULL), (1, 1);\n",
            "SELECT SUM(CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END) FROM t1;\n"
        ]
    },
    {
        "sql_id": 401,
        "database_name": "BUTTERTrans_401",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select from_unixtime(123456789); -- FROM_UNIXTIME",
        "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '123456789' SECOND;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "FROM_UNIXTIME",
                "start_pos": 7,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
                "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
                "examples": [
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
                    "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 402,
        "database_name": "BUTTERTrans_402",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select from_unixtime(234567890); -- FROM_UNIXTIME",
        "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '234567890' SECOND;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "FROM_UNIXTIME",
                "start_pos": 7,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
                "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
                "examples": [
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
                    "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
                ]
            }
        ],
        "source_related_schemas": [
            "select from_unixtime(123456789); -- FROM_UNIXTIME\n"
        ],
        "target_related_schemas": [
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '123456789' SECOND;\n"
        ]
    },
    {
        "sql_id": 403,
        "database_name": "BUTTERTrans_403",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select from_unixtime(1); -- FROM_UNIXTIME",
        "target_query": "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1' SECOND;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "FROM_UNIXTIME",
                "start_pos": 7,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
                "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
                "examples": [
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
                    "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
                ]
            }
        ],
        "source_related_schemas": [
            "select from_unixtime(123456789); -- FROM_UNIXTIME\n",
            "select from_unixtime(234567890); -- FROM_UNIXTIME\n"
        ],
        "target_related_schemas": [
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '123456789' SECOND;\n",
            "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '234567890' SECOND;\n"
        ]
    },
    {
        "sql_id": 404,
        "database_name": "BUTTERTrans_404",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT * FROM t WHERE CONCAT(x,x) = 'XX'; -- CONCAT",
        "target_query": "EXPLAIN SELECT * FROM t WHERE x || x = 'XX';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 30,
                "end_pos": 36
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(x VARCHAR(10));\n",
            "INSERT INTO t VALUES ('x');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(x VARCHAR(10));\n",
            "INSERT INTO t VALUES ('x');\n"
        ]
    },
    {
        "sql_id": 405,
        "database_name": "BUTTERTrans_405",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX",
        "target_query": "insert into t1(f1) select CASE WHEN max(f1) is null THEN '2000' ELSE max(f1) END from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 26,
                "end_pos": 28
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Returns the maximum value of the expression in an aggregation context.",
                "examples": [
                    "SELECT MAX(10), MAX(5), MAX(20);",
                    "SELECT MAX('apple'), MAX('banana'), MAX('pear');",
                    "SELECT MAX(ABS(-5)), MAX(ABS(3));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "MAX(expr)",
                "description": "Aggregates the maximum value of the input expression.",
                "examples": [
                    "SELECT MAX(2), MAX(4), MAX(8);",
                    "SELECT MAX('lion'), MAX('tiger'), MAX('bear');",
                    "SELECT MAX(sqrt(16)), MAX(sqrt(25));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(f1 varchar(5));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(f1 varchar(5));\n"
        ]
    },
    {
        "sql_id": 406,
        "database_name": "BUTTERTrans_406",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
        "target_query": "SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 19,
                "end_pos": 25
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(f1 varchar(5));\n",
            "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c VARCHAR(30));\n",
            "INSERT INTO t1 (c) VALUES ('7_chars'), ('13_characters');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(f1 varchar(5));\n",
            "insert into t1(f1) select CASE WHEN max(f1) is null THEN '2000' ELSE max(f1) END from t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c VARCHAR(30));\n",
            "INSERT INTO t1 (c) VALUES ('7_chars'), ('13_characters');\n"
        ]
    },
    {
        "sql_id": 407,
        "database_name": "BUTTERTrans_407",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH",
        "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 37,
                "end_pos": 43
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(f1 varchar(5));\n",
            "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c VARCHAR(30));\n",
            "INSERT INTO t1 (c) VALUES ('7_chars'), ('13_characters');\n",
            "SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (d VARCHAR(10));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(f1 varchar(5));\n",
            "insert into t1(f1) select CASE WHEN max(f1) is null THEN '2000' ELSE max(f1) END from t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c VARCHAR(30));\n",
            "INSERT INTO t1 (c) VALUES ('7_chars'), ('13_characters');\n",
            "SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (d VARCHAR(10));\n"
        ]
    },
    {
        "sql_id": 408,
        "database_name": "BUTTERTrans_408",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='7_chars') FROM t1; -- LENGTH",
        "target_query": "INSERT INTO t2 (d)SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='7_chars') FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 37,
                "end_pos": 43
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(f1 varchar(5));\n",
            "insert into t1(f1) select if(max(f1) is null, '2000',max(f1)) from t1; -- IF, MAX\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c VARCHAR(30));\n",
            "INSERT INTO t1 (c) VALUES ('7_chars'), ('13_characters');\n",
            "SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (d VARCHAR(10));\n",
            "INSERT INTO t2 (d)SELECT (SELECT SUM(LENGTH(c)) FROM t1 WHERE c='13_characters') FROM t1; -- LENGTH\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1(f1 varchar(5));\n",
            "insert into t1(f1) select CASE WHEN max(f1) is null THEN '2000' ELSE max(f1) END from t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c VARCHAR(30));\n",
            "INSERT INTO t1 (c) VALUES ('7_chars'), ('13_characters');\n",
            "SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (d VARCHAR(10));\n",
            "INSERT INTO t2 (d)SELECT (SELECT SUM(octet_length(c)) FROM t1 WHERE c='13_characters') FROM t1;\n"
        ]
    },
    {
        "sql_id": 409,
        "database_name": "BUTTERTrans_409",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES('valid-string',1),(UNHEX('11'),2); -- UNHEX",
        "target_query": "INSERT INTO t1 VALUES('valid-string',1),(NULL,2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UNHEX",
                "start_pos": 41,
                "end_pos": 46
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UNHEX(str)",
                "description": "Converts a hexadecimal string into a binary string. Returns NULL for invalid hex or NULL input.",
                "examples": [
                    "SELECT HEX(UNHEX('4D7953514C'));",
                    "SELECT UNHEX('48656C6C6F');",
                    "SELECT UNHEX(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "",
                "description": "",
                "examples": []
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);\n"
        ]
    },
    {
        "sql_id": 410,
        "database_name": "BUTTERTrans_410",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT pk,OCTET_LENGTH(tx),LENGTH(tx) FROM t1; -- OCTET_LENGTH, LENGTH",
        "target_query": "SELECT pk,LENGTH(tx),octet_length(tx) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "OCTET_LENGTH",
                "start_pos": 10,
                "end_pos": 22
            },
            {
                "dialect_token": "LENGTH",
                "start_pos": 27,
                "end_pos": 33
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "OCTET_LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT OCTET_LENGTH('Hello World');",
                    "SELECT OCTET_LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN OCTET_LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            },
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "LENGTH()",
                "description": "Returns the number of bytes in a string.",
                "examples": [
                    "SELECT LENGTH('Hello World');",
                    "SELECT LENGTH('Test String') = 11;",
                    "SELECT CASE WHEN LENGTH('Example') > 5 THEN 'Long' ELSE 'Short' END;"
                ]
            },
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);\n",
            "INSERT INTO t1 VALUES('valid-string',1),(UNHEX('11'),2); -- UNHEX\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (tx TEXT NULL,pk INTEGER PRIMARY KEY);\n",
            "INSERT INTO t1 VALUES('valid-string',1),(NULL,2);\n"
        ]
    },
    {
        "sql_id": 411,
        "database_name": "BUTTERTrans_411",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert ignore t1 values (1, repeat('a',110), repeat('b', 210)); -- REPEAT",
        "target_query": "insert into t1 values (1, repeat('a',110), repeat('b', 210));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 28,
                "end_pos": 34
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 45,
                "end_pos": 51
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, a char(200), b text, unique (a), unique (b));\n"
        ]
    },
    {
        "sql_id": 412,
        "database_name": "BUTTERTrans_412",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select i, length(a), length(b), char_length(a), char_length(b) from t1; -- LENGTH, CHAR_LENGTH",
        "target_query": "select i, octet_length(a), octet_length(b), char_length(a), char_length(b) from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 10,
                "end_pos": 16
            },
            {
                "dialect_token": "LENGTH",
                "start_pos": 21,
                "end_pos": 27
            },
            {
                "dialect_token": "CHAR_LENGTH",
                "start_pos": 32,
                "end_pos": 43
            },
            {
                "dialect_token": "CHAR_LENGTH",
                "start_pos": 48,
                "end_pos": 59
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "CHAR_LENGTH(expr)",
                "description": "Returns the number of characters in the string, not bytes.",
                "examples": [
                    "SELECT CHAR_LENGTH('abc');",
                    "SELECT CHAR_LENGTH('\u4f60\u597d');",
                    "SELECT CHAR_LENGTH('a\u4f60b\u597dc');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "char_length(expr)",
                "description": "Returns the number of characters in a string (char_length and length are equivalent).",
                "examples": [
                    "SELECT char_length('abc');",
                    "SELECT char_length('\u4f60\u597d');",
                    "SELECT char_length('a\u4f60b\u597dc');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));\n",
            "insert ignore t1 values (1, repeat('a',110), repeat('b', 210)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, a char(200), b text, unique (a), unique (b));\n",
            "insert into t1 values (1, repeat('a',110), repeat('b', 210));\n"
        ]
    },
    {
        "sql_id": 413,
        "database_name": "BUTTERTrans_413",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t1 values(1, 'a', 'a', NOW()), (1, 'b', 'b', NOW()); -- NOW",
        "target_query": "insert into t1 values(1, 'a', 'a', CURRENT_TIMESTAMP), (1, 'b', 'b', CURRENT_TIMESTAMP);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 35,
                "end_pos": 38
            },
            {
                "dialect_token": "NOW",
                "start_pos": 57,
                "end_pos": 60
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NOW()",
                "description": "Returns the current date and time in 'YYYY-MM-DD HH:MM:SS' format.",
                "examples": [
                    "SELECT NOW();",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > NOW()) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (NOW());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, a char(200), b text, unique (a), unique (b(300)));\n",
            "insert ignore t1 values (1, repeat('a',110), repeat('b', 210)); -- REPEAT\n",
            "select i, length(a), length(b), char_length(a), char_length(b) from t1; -- LENGTH, CHAR_LENGTH\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 int,c2 char(12),c3 varchar(123),c4 timestamp NOT NULL);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (i int, a char(200), b text, unique (a), unique (b));\n",
            "insert into t1 values (1, repeat('a',110), repeat('b', 210));\n",
            "select i, octet_length(a), octet_length(b), char_length(a), char_length(b) from t1;\n",
            "DROP TABLE t1;\n",
            "create table t1 (c1 int,c2 char(12),c3 varchar(123),c4 timestamp NOT NULL);\n"
        ]
    },
    {
        "sql_id": 414,
        "database_name": "BUTTERTrans_414",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select t1.time,t1.date,t1.timestamp,concat(date,\" \",time),t1.quarter+t1.week, t1.year+timestampadd,  timestampdiff from t1; -- CONCAT",
        "target_query": "select t1.\"time\",t1.\"date\",t1.\"timestamp\",\"date\" || ' ' || \"time\",t1.\"quarter\"+t1.\"week\", t1.\"year\"+\"timestampadd\",  timestampdiff from t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 36,
                "end_pos": 42
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (time time, date date, timestamp timestamp,quarter int, week int, year int, timestampadd int, timestampdiff int);\n",
            "insert into t1 values (\"12:22:22\",\"1997-01-01\",\"1997-01-02\",1,2,3,4,5);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (\"time\" time, \"date\" date, \"timestamp\" timestamp,\"quarter\" int, \"week\" int, \"year\" int, \"timestampadd\" int, \"timestampdiff\" int);\n",
            "insert into t1 values ('12:22:22','1997-01-01','1997-01-02',1,2,3,4,5);\n"
        ]
    },
    {
        "sql_id": 415,
        "database_name": "BUTTERTrans_415",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select concat('|',a,'|'), concat('|',b,'|') from t1; -- CONCAT",
        "target_query": "SELECT '|' || a || '|' AS a, '|' || b || '|' AS b FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "CONCAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a text, b text);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a TEXT, b TEXT);\n"
        ]
    },
    {
        "sql_id": 416,
        "database_name": "BUTTERTrans_416",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME",
        "target_query": "SELECT a, sys.timestamp_to_str(a, 'DY') as abday, dayname(a) as \"day\" FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 10,
                "end_pos": 21
            },
            {
                "dialect_token": "DAYNAME",
                "start_pos": 40,
                "end_pos": 47
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "DAYNAME(date)",
                "description": "Returns the full name of the day for a given date.",
                "examples": [
                    "SELECT DAYNAME('2023-11-25');",
                    "SELECT DAYNAME('2022-01-01');",
                    "SELECT DAYNAME('1999-03-14');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            },
            {
                "expression": "dayname(date)",
                "description": "MonetDB has a built-in function `dayname` that returns the full name of the day for a given date.",
                "examples": [
                    "SELECT dayname(CAST('2023-11-25' AS DATE));",
                    "SELECT dayname(CAST('2022-01-01' AS DATE));",
                    "SELECT dayname(CAST('1999-03-14' AS DATE));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n"
        ]
    },
    {
        "sql_id": 417,
        "database_name": "BUTTERTrans_417",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME",
        "target_query": "SELECT a, sys.timestamp_to_str(a, 'MON') as abmon, monthname(a) as mon FROM t1 ORDER BY a;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 10,
                "end_pos": 21
            },
            {
                "dialect_token": "MONTHNAME",
                "start_pos": 40,
                "end_pos": 49
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            },
            {
                "expression": "MONTHNAME(date)",
                "description": "Returns the full English name of the month for a given date.",
                "examples": [
                    "SELECT MONTHNAME(DATE '2023-05-01') AS mon1;",
                    "SELECT MONTHNAME(STR_TO_DATE('2024-12-31', '%Y-%m-%d')) AS mon2;",
                    "SELECT MONTHNAME(NOW()) AS current_month;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            },
            {
                "expression": "monthName(date)",
                "description": "Returns the full English name of the month for a given date.",
                "examples": [
                    "SELECT monthName(DATE '2023-05-01') AS mon1;",
                    "SELECT monthName(DATE '2024-12-31') AS mon2;",
                    "SELECT monthName(now()) AS current_month"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n",
            "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-02-01'),('2006-03-01'),('2006-04-01'),('2006-05-01'),('2006-06-01'),('2006-07-01'),('2006-08-01'),('2006-09-01'),('2006-10-01'),('2006-11-01'),('2006-12-01');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n",
            "SELECT a, sys.timestamp_to_str(a, 'DY') as abday, dayname(a) as \"day\" FROM t1 ORDER BY a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-02-01'),('2006-03-01'),('2006-04-01'),('2006-05-01'),('2006-06-01'),('2006-07-01'),('2006-08-01'),('2006-09-01'),('2006-10-01'),('2006-11-01'),('2006-12-01');\n"
        ]
    },
    {
        "sql_id": 418,
        "database_name": "BUTTERTrans_418",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATE_FORMAT('2001-01-01', '%w %a %W'); -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'D DY WW');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n",
            "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-02-01'),('2006-03-01'),('2006-04-01'),('2006-05-01'),('2006-06-01'),('2006-07-01'),('2006-08-01'),('2006-09-01'),('2006-10-01'),('2006-11-01'),('2006-12-01');\n",
            "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n",
            "SELECT a, sys.timestamp_to_str(a, 'DY') as abday, dayname(a) as \"day\" FROM t1 ORDER BY a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-02-01'),('2006-03-01'),('2006-04-01'),('2006-05-01'),('2006-06-01'),('2006-07-01'),('2006-08-01'),('2006-09-01'),('2006-10-01'),('2006-11-01'),('2006-12-01');\n",
            "SELECT a, sys.timestamp_to_str(a, 'MON') as abmon, monthname(a) as mon FROM t1 ORDER BY a;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 419,
        "database_name": "BUTTERTrans_419",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATE_FORMAT('2001-01-01', '%c %b %M'); -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'MM MON MONTH');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n",
            "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-02-01'),('2006-03-01'),('2006-04-01'),('2006-05-01'),('2006-06-01'),('2006-07-01'),('2006-08-01'),('2006-09-01'),('2006-10-01'),('2006-11-01'),('2006-12-01');\n",
            "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME\n",
            "DROP TABLE t1;\n",
            "SELECT DATE_FORMAT('2001-01-01', '%w %a %W'); -- DATE_FORMAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n",
            "SELECT a, sys.timestamp_to_str(a, 'DY') as abday, dayname(a) as \"day\" FROM t1 ORDER BY a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-02-01'),('2006-03-01'),('2006-04-01'),('2006-05-01'),('2006-06-01'),('2006-07-01'),('2006-08-01'),('2006-09-01'),('2006-10-01'),('2006-11-01'),('2006-12-01');\n",
            "SELECT a, sys.timestamp_to_str(a, 'MON') as abmon, monthname(a) as mon FROM t1 ORDER BY a;\n",
            "DROP TABLE t1;\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'D DY WW');\n"
        ]
    },
    {
        "sql_id": 420,
        "database_name": "BUTTERTrans_420",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT DATE_FORMAT('2010-03-23 11:00:00','%h %p'); -- DATE_FORMAT",
        "target_query": "SELECT sys.timestamp_to_str(TIMESTAMP '2010-03-23 11:00:00', 'HH12 AM');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 7,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n",
            "SELECT a, date_format(a,'%a') as abday, dayname(a) as day FROM t1 ORDER BY a; -- DATE_FORMAT, DAYNAME\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-02-01'),('2006-03-01'),('2006-04-01'),('2006-05-01'),('2006-06-01'),('2006-07-01'),('2006-08-01'),('2006-09-01'),('2006-10-01'),('2006-11-01'),('2006-12-01');\n",
            "SELECT a, date_format(a,'%b') as abmon, monthname(a) as mon FROM t1 ORDER BY a; -- DATE_FORMAT, MONTHNAME\n",
            "DROP TABLE t1;\n",
            "SELECT DATE_FORMAT('2001-01-01', '%w %a %W'); -- DATE_FORMAT\n",
            "SELECT DATE_FORMAT('2001-01-01', '%c %b %M'); -- DATE_FORMAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-01-02'),('2006-01-03'),('2006-01-04'),('2006-01-05'),('2006-01-06'),('2006-01-07');\n",
            "SELECT a, sys.timestamp_to_str(a, 'DY') as abday, dayname(a) as \"day\" FROM t1 ORDER BY a;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (a DATE);\n",
            "INSERT INTO t1 VALUES('2006-01-01'),('2006-02-01'),('2006-03-01'),('2006-04-01'),('2006-05-01'),('2006-06-01'),('2006-07-01'),('2006-08-01'),('2006-09-01'),('2006-10-01'),('2006-11-01'),('2006-12-01');\n",
            "SELECT a, sys.timestamp_to_str(a, 'MON') as abmon, monthname(a) as mon FROM t1 ORDER BY a;\n",
            "DROP TABLE t1;\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'D DY WW');\n",
            "SELECT sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'MM MON MONTH');\n"
        ]
    },
    {
        "sql_id": 421,
        "database_name": "BUTTERTrans_421",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 23,
                "end_pos": 29
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 39,
                "end_pos": 45
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 57,
                "end_pos": 63
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 422,
        "database_name": "BUTTERTrans_422",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 23,
                "end_pos": 29
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 39,
                "end_pos": 45
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 57,
                "end_pos": 63
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;\n"
        ]
    },
    {
        "sql_id": 423,
        "database_name": "BUTTERTrans_423",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 23,
                "end_pos": 29
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 38,
                "end_pos": 44
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 55,
                "end_pos": 61
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS prt1;\n",
            "CREATE TABLE prt1 (a int, b int, c varchar);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS prt1;\n",
            "CREATE TABLE prt1 (a int, b int, c varchar);\n"
        ]
    },
    {
        "sql_id": 424,
        "database_name": "BUTTERTrans_424",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 24,
                "end_pos": 30
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 41,
                "end_pos": 47
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 61,
                "end_pos": 67
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP\n",
            "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP\n",
            "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;\n"
        ]
    },
    {
        "sql_id": 425,
        "database_name": "BUTTERTrans_425",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP",
        "target_query": "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 22,
                "end_pos": 28
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 37,
                "end_pos": 43
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP\n",
            "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP\n",
            "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP\n",
            "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;\n"
        ]
    },
    {
        "sql_id": 426,
        "database_name": "BUTTERTrans_426",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 23,
                "end_pos": 29
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 38,
                "end_pos": 44
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 55,
                "end_pos": 61
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP\n",
            "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP\n",
            "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP\n",
            "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP\n",
            "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;\n"
        ]
    },
    {
        "sql_id": 427,
        "database_name": "BUTTERTrans_427",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('a','ss'),strcmp('ssa',''),strcmp('sssb','sa'),strcmp('','s'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'a' = 'ss' THEN 0 WHEN 'a' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 'ssa' = '' THEN 0 WHEN 'ssa' < '' THEN -1 ELSE 1 END, CASE WHEN 'sssb' = 'sa' THEN 0 WHEN 'sssb' < 'sa' THEN -1 ELSE 1 END, CASE WHEN '' = 's' THEN 0 WHEN '' < 's' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 24,
                "end_pos": 30
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 41,
                "end_pos": 47
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 61,
                "end_pos": 67
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP\n",
            "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP\n",
            "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP\n",
            "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP\n",
            "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP\n",
            "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;\n"
        ]
    },
    {
        "sql_id": 428,
        "database_name": "BUTTERTrans_428",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('u','a'),strcmp('u',''); -- STRCMP",
        "target_query": "SELECT CASE WHEN 'u' = 'a' THEN 0 WHEN 'u' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'u' = '' THEN 0 WHEN 'u' < '' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS prt1;\n",
            "CREATE TABLE prt1 (a int, b int, c varchar);\n",
            "INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0; -- TO_CHAR, GENERATE_SERIES\n",
            "DROP TABLE prt1;\n",
            "DROP TABLE IF EXISTS prt2;\n",
            "CREATE TABLE prt2 (a int, b int, c varchar);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS prt1;\n",
            "CREATE TABLE prt1 (a int, b int, c varchar);\n",
            "INSERT INTO prt1 SELECT i, i % 25, lpad(CAST(i AS string), 4, '0') FROM generate_series(0, 599 + 1) AS g(i) WHERE i % 2 = 0;\n",
            "DROP TABLE prt1;\n",
            "DROP TABLE IF EXISTS prt2;\n",
            "CREATE TABLE prt2 (a int, b int, c varchar);\n"
        ]
    },
    {
        "sql_id": 429,
        "database_name": "BUTTERTrans_429",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select strcmp('s', 'a'), strcmp('a', 'x'); -- STRCMP",
        "target_query": "SELECT CASE WHEN 's' = 'a' THEN 0 WHEN 's' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'x' THEN 0 WHEN 'a' < 'x' THEN -1 ELSE 1 END;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "STRCMP",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "STRCMP",
                "start_pos": 25,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "STRCMP(expr1, expr2)",
                "description": "Compares two strings lexicographically and returns 0 if they are equal, a negative number if the first string is smaller, and a positive number if the first string is larger.",
                "examples": [
                    "SELECT STRCMP('apple', 'banana');",
                    "SELECT STRCMP('grape', 'grape');",
                    "SELECT STRCMP('orange', 'apple');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN expr1 = expr2 THEN 0 WHEN expr1 < expr2 THEN -1 ELSE 1 END",
                "description": "MonetDB does not have a direct STRCMP function. This behavior can be simulated using a CASE statement to compare two strings lexicographically.",
                "examples": [
                    "SELECT CASE WHEN 'apple' = 'banana' THEN 0 WHEN 'apple' < 'banana' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'grape' = 'grape' THEN 0 WHEN 'grape' < 'grape' THEN -1 ELSE 1 END;",
                    "SELECT CASE WHEN 'orange' = 'apple' THEN 0 WHEN 'orange' < 'apple' THEN -1 ELSE 1 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP\n",
            "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP\n",
            "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP\n",
            "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP\n",
            "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP\n",
            "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP\n",
            "select strcmp('a','ss'),strcmp('ssa',''),strcmp('sssb','sa'),strcmp('','s'); -- STRCMP\n",
            "select strcmp('u','a'),strcmp('u',''); -- STRCMP\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'a' = 'ss' THEN 0 WHEN 'a' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 'ssa' = '' THEN 0 WHEN 'ssa' < '' THEN -1 ELSE 1 END, CASE WHEN 'sssb' = 'sa' THEN 0 WHEN 'sssb' < 'sa' THEN -1 ELSE 1 END, CASE WHEN '' = 's' THEN 0 WHEN '' < 's' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'u' = 'a' THEN 0 WHEN 'u' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'u' = '' THEN 0 WHEN 'u' < '' THEN -1 ELSE 1 END;\n"
        ]
    },
    {
        "sql_id": 430,
        "database_name": "BUTTERTrans_430",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select * from t1 where length(s1)=2 and s1='oe'; -- LENGTH",
        "target_query": "select * from t1 where octet_length(s1)=2 and s1='oe'; -- LENGTH",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "select strcmp('','ae'),strcmp('ae',''),strcmp('aeq','q'),strcmp('q','aeq'); -- STRCMP\n",
            "select strcmp('ss',''),strcmp('','ss'),strcmp('s','sss'),strcmp('q','ssq'); -- STRCMP\n",
            "select strcmp('','af'),strcmp('a',''),strcmp('','aeq'),strcmp('','aeaeq'); -- STRCMP\n",
            "select strcmp('ss','a'),strcmp('','ssa'),strcmp('sa','sssb'),strcmp('s',''); -- STRCMP\n",
            "select strcmp('','o'),strcmp('','u'),strcmp('','oeb'); -- STRCMP\n",
            "select strcmp('af',''),strcmp('','a'),strcmp('aeq',''),strcmp('aeaeq',''); -- STRCMP\n",
            "select strcmp('a','ss'),strcmp('ssa',''),strcmp('sssb','sa'),strcmp('','s'); -- STRCMP\n",
            "select strcmp('u','a'),strcmp('u',''); -- STRCMP\n",
            "select strcmp('s', 'a'), strcmp('a', 'x'); -- STRCMP\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (s1 CHAR(5));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "INSERT INTO t1 VALUES ('ue');\n",
            "DROP TABLE t1;\n",
            "create table t1 (s1 char(5));\n",
            "insert into t1 values ('oe');\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN '' = 'ae' THEN 0 WHEN '' < 'ae' THEN -1 ELSE 1 END, CASE WHEN 'ae' = '' THEN 0 WHEN 'ae' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = 'q' THEN 0 WHEN 'aeq' < 'q' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'aeq' THEN 0 WHEN 'q' < 'aeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = '' THEN 0 WHEN 'ss' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'ss' THEN 0 WHEN '' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 's' = 'sss' THEN 0 WHEN 's' < 'sss' THEN -1 ELSE 1 END, CASE WHEN 'q' = 'ssq' THEN 0 WHEN 'q' < 'ssq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'af' THEN 0 WHEN '' < 'af' THEN -1 ELSE 1 END, CASE WHEN 'a' = '' THEN 0 WHEN 'a' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeq' THEN 0 WHEN '' < 'aeq' THEN -1 ELSE 1 END, CASE WHEN '' = 'aeaeq' THEN 0 WHEN '' < 'aeaeq' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'ss' = 'a' THEN 0 WHEN 'ss' < 'a' THEN -1 ELSE 1 END, CASE WHEN '' = 'ssa' THEN 0 WHEN '' < 'ssa' THEN -1 ELSE 1 END, CASE WHEN 'sa' = 'sssb' THEN 0 WHEN 'sa' < 'sssb' THEN -1 ELSE 1 END, CASE WHEN 's' = '' THEN 0 WHEN 's' < '' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN '' = 'o' THEN 0 WHEN '' < 'o' THEN -1 ELSE 1 END, CASE WHEN '' = 'u' THEN 0 WHEN '' < 'u' THEN -1 ELSE 1 END, CASE WHEN '' = 'oeb' THEN 0 WHEN '' < 'oeb' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'af' = '' THEN 0 WHEN 'af' < '' THEN -1 ELSE 1 END, CASE WHEN '' = 'a' THEN 0 WHEN '' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'aeq' = '' THEN 0 WHEN 'aeq' < '' THEN -1 ELSE 1 END, CASE WHEN 'aeaeq' = '' THEN 0 WHEN 'aeaeq' < '' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'a' = 'ss' THEN 0 WHEN 'a' < 'ss' THEN -1 ELSE 1 END, CASE WHEN 'ssa' = '' THEN 0 WHEN 'ssa' < '' THEN -1 ELSE 1 END, CASE WHEN 'sssb' = 'sa' THEN 0 WHEN 'sssb' < 'sa' THEN -1 ELSE 1 END, CASE WHEN '' = 's' THEN 0 WHEN '' < 's' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 'u' = 'a' THEN 0 WHEN 'u' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'u' = '' THEN 0 WHEN 'u' < '' THEN -1 ELSE 1 END;\n",
            "SELECT CASE WHEN 's' = 'a' THEN 0 WHEN 's' < 'a' THEN -1 ELSE 1 END, CASE WHEN 'a' = 'x' THEN 0 WHEN 'a' < 'x' THEN -1 ELSE 1 END;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (s1 CHAR(5));\n",
            "INSERT INTO t1 VALUES ('');\n",
            "INSERT INTO t1 VALUES ('ue');\n",
            "DROP TABLE t1;\n",
            "create table t1 (s1 char(5));\n",
            "insert into t1 values ('oe');\n"
        ]
    },
    {
        "sql_id": 431,
        "database_name": "BUTTERTrans_431",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 432,
        "database_name": "BUTTERTrans_432",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n"
        ]
    },
    {
        "sql_id": 433,
        "database_name": "BUTTERTrans_433",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n"
        ]
    },
    {
        "sql_id": 434,
        "database_name": "BUTTERTrans_434",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n"
        ]
    },
    {
        "sql_id": 435,
        "database_name": "BUTTERTrans_435",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n"
        ]
    },
    {
        "sql_id": 436,
        "database_name": "BUTTERTrans_436",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('a', 5, NULL) AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n"
        ]
    },
    {
        "sql_id": 437,
        "database_name": "BUTTERTrans_437",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n"
        ]
    },
    {
        "sql_id": 438,
        "database_name": "BUTTERTrans_438",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('a', 0, 'x') AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n"
        ]
    },
    {
        "sql_id": 439,
        "database_name": "BUTTERTrans_439",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('a', 0, '') AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, 'x') AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n"
        ]
    },
    {
        "sql_id": 440,
        "database_name": "BUTTERTrans_440",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('', 0, 'x') AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH(''))), '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, '') AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n"
        ]
    },
    {
        "sql_id": 441,
        "database_name": "BUTTERTrans_441",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('', 0, '') AS result; -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH(''))), '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, 'x') AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n"
        ]
    },
    {
        "sql_id": 442,
        "database_name": "BUTTERTrans_442",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('a', -1, 'x'); -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, -1 - LENGTH('a'))), 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, '') AS result; -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n"
        ]
    },
    {
        "sql_id": 443,
        "database_name": "BUTTERTrans_443",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('123', 5, 'x'); -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH('123'))), '123');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('a', -1, 'x'); -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, -1 - LENGTH('a'))), 'a');\n"
        ]
    },
    {
        "sql_id": 444,
        "database_name": "BUTTERTrans_444",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD('a', 5, 'xy'); -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT('xy', GREATEST(0, 5 - LENGTH('a'))), 'a');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('a', -1, 'x'); -- LPAD\n",
            "SELECT LPAD('123', 5, 'x'); -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, -1 - LENGTH('a'))), 'a');\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH('123'))), '123');\n"
        ]
    },
    {
        "sql_id": 445,
        "database_name": "BUTTERTrans_445",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD(\"I LOVE SQL\", 20, \" \"); -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH('I LOVE SQL'))), 'I LOVE SQL');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('a', -1, 'x'); -- LPAD\n",
            "SELECT LPAD('123', 5, 'x'); -- LPAD\n",
            "SELECT LPAD('a', 5, 'xy'); -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, -1 - LENGTH('a'))), 'a');\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH('123'))), '123');\n",
            "SELECT CONCAT(REPEAT('xy', GREATEST(0, 5 - LENGTH('a'))), 'a');\n"
        ]
    },
    {
        "sql_id": 446,
        "database_name": "BUTTERTrans_446",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- LPAD",
        "target_query": "SELECT CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH('I LOVE SQL in the morning'))), 'I LOVE SQL in the morning');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LPAD(string, length, pad_string)",
                "description": "This function pads the left side of a string with a specified padding string until the desired length is reached.",
                "examples": [
                    "SELECT LPAD('hello', 10, 'x');",
                    "SELECT LPAD('abc', 6, '123');",
                    "SELECT LPAD('123', 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CONCAT(REPEAT(pad_string, GREATEST(0, length - LENGTH(string))), string)",
                "description": "MonetDB does not support LPAD directly, but it can be simulated using CONCAT, REPEAT, and LENGTH functions.",
                "examples": [
                    "SELECT CONCAT(REPEAT('x', GREATEST(0, 10 - LENGTH('hello'))), 'hello');",
                    "SELECT CONCAT(REPEAT('123', GREATEST(0, 6 - LENGTH('abc'))), 'abc');",
                    "SELECT CONCAT(REPEAT('0', GREATEST(0, 5 - LENGTH('123'))), '123');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT LPAD(NULL, 5, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD(NULL, NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', NULL, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD(NULL, 5, NULL) AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('a', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, 'x') AS result; -- LPAD\n",
            "SELECT LPAD('', 0, '') AS result; -- LPAD\n",
            "SELECT LPAD('a', -1, 'x'); -- LPAD\n",
            "SELECT LPAD('123', 5, 'x'); -- LPAD\n",
            "SELECT LPAD('a', 5, 'xy'); -- LPAD\n",
            "SELECT LPAD(\"I LOVE SQL\", 20, \" \"); -- LPAD\n"
        ],
        "target_related_schemas": [
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, NULL - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT(NULL, GREATEST(0, 5 - LENGTH(NULL))), NULL) AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH('a'))), 'a') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('', GREATEST(0, 0 - LENGTH(''))), '') AS result;\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, -1 - LENGTH('a'))), 'a');\n",
            "SELECT CONCAT(REPEAT('x', GREATEST(0, 5 - LENGTH('123'))), '123');\n",
            "SELECT CONCAT(REPEAT('xy', GREATEST(0, 5 - LENGTH('a'))), 'a');\n",
            "SELECT CONCAT(REPEAT(' ', GREATEST(0, 20 - LENGTH('I LOVE SQL'))), 'I LOVE SQL');\n"
        ]
    },
    {
        "sql_id": 447,
        "database_name": "BUTTERTrans_447",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 22,
                "end_pos": 28
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 46,
                "end_pos": 52
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 69,
                "end_pos": 75
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 93,
                "end_pos": 99
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 116,
                "end_pos": 122
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 140,
                "end_pos": 146
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 LONGTEXT , f2  INTEGER);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 TEXT , f2 INTEGER);\n"
        ]
    },
    {
        "sql_id": 448,
        "database_name": "BUTTERTrans_448",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT SUM(LENGTH(f1)) FROM t1; -- LENGTH",
        "target_query": "SELECT SUM(octet_length(f1)) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 11,
                "end_pos": 17
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 LONGTEXT , f2  INTEGER);\n",
            "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5); -- REPEAT\n",
            "INSERT INTO t1 SELECT f1, f2 + 6 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 12 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 24 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 48 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 96 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 192 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 384 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 768 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 1536 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 3072 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 6144 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 12288 FROM t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (f1 TEXT , f2 INTEGER);\n",
            "INSERT INTO t1 VALUES(REPEAT('a', 1024), 0), (REPEAT('b', 1024), 1),(REPEAT('c', 1024), 2), (REPEAT('d', 1024), 3),(REPEAT('e', 1024), 4), (REPEAT('f', 1024), 5);\n",
            "INSERT INTO t1 SELECT f1, f2 + 6 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 12 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 24 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 48 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 96 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 192 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 384 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 768 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 1536 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 3072 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 6144 FROM t1;\n",
            "INSERT INTO t1 SELECT f1, f2 + 12288 FROM t1;\n"
        ]
    },
    {
        "sql_id": 449,
        "database_name": "BUTTERTrans_449",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT COALESCE(d, d), IFNULL(d, d), IF(i, d, d),CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), LEAST(d, d)FROM t1 ORDER BY RAND(); -- COALESCE, IFNULL, IF, GREATEST, LEAST",
        "target_query": "SELECT COALESCE(d, d), COALESCE(d, d), CASE WHEN i THEN d ELSE d END, CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), CASE WHEN d <= d THEN d ELSE d END FROM t1 ORDER BY RAND();",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 7,
                "end_pos": 15
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 23,
                "end_pos": 29
            },
            {
                "dialect_token": "IF",
                "start_pos": 37,
                "end_pos": 39
            },
            {
                "dialect_token": "GREATEST",
                "start_pos": 82,
                "end_pos": 90
            },
            {
                "dialect_token": "LEAST",
                "start_pos": 98,
                "end_pos": 103
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            },
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            },
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            },
            {
                "expression": "LEAST(expr1, expr2, ...)",
                "description": "Returns the smallest value from the argument list. If any argument is NULL, the result is NULL regardless of other values. Implicit type conversion is applied before comparison.",
                "examples": [
                    "SELECT LEAST(5, 10, 3);",
                    "SELECT LEAST('2024-01-01', '2023-12-31');",
                    "SELECT LEAST(NULL, 2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            },
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            },
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "GREATEST(expr1, expr2, ..., exprN)",
                "description": "Returns the greatest value among the provided arguments, supporting numeric, string, and date types.",
                "examples": [
                    "SELECT GREATEST(3, 7, 2);",
                    "SELECT GREATEST(5.5, 7.2, 6.1) + 0.0;",
                    "SELECT GREATEST('2023-05-10', '2022-05-12') AS latest_date;"
                ]
            },
            {
                "expression": "CASE WHEN ... THEN ... END",
                "description": "MonetDB does not support a native LEAST function. Equivalent behavior can be emulated using nested CASE WHEN expressions to compare and return the smallest non-null value.",
                "examples": [
                    "SELECT CASE WHEN a IS NULL THEN b WHEN b IS NULL THEN a WHEN a <= b THEN a ELSE b END;",
                    "SELECT CASE WHEN a <= b AND a <= c THEN a WHEN b <= c THEN b ELSE c END;",
                    "SELECT CASE WHEN x IS NULL THEN y WHEN y IS NULL THEN x WHEN x < y THEN x ELSE y END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i INT, d DATE);\n",
            "INSERT INTO t1 VALUES (1, '2008-01-01'), (2, '2008-01-02'), (3, '2008-01-03');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (i INT, d DATE);\n",
            "INSERT INTO t1 VALUES (1, '2008-01-01'), (2, '2008-01-02'), (3, '2008-01-03');\n"
        ]
    },
    {
        "sql_id": 450,
        "database_name": "BUTTERTrans_450",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t5 values (1, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "insert into t5 values (1, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 26,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t5;\n",
            "create table t5 (c1 int, c2 varchar(128) not null);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t5;\n",
            "create table t5 (c1 int, c2 varchar(128) not null);\n"
        ]
    },
    {
        "sql_id": 451,
        "database_name": "BUTTERTrans_451",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t5 values (2, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "insert into t5 values (2, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 26,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t5;\n",
            "create table t5 (c1 int, c2 varchar(128) not null);\n",
            "insert into t5 values (1, date_format('2001-01-01','%W')); -- DATE_FORMAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t5;\n",
            "create table t5 (c1 int, c2 varchar(128) not null);\n",
            "insert into t5 values (1, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));\n"
        ]
    },
    {
        "sql_id": 452,
        "database_name": "BUTTERTrans_452",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "insert into t5 values (3, date_format('2001-01-01','%W')); -- DATE_FORMAT",
        "target_query": "insert into t5 values (3, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "DATE_FORMAT",
                "start_pos": 26,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "DATE_FORMAT(date_expr, format_str)",
                "description": "Formats a date/time expression according to the given format string using MySQL-specific format specifiers.",
                "examples": [
                    "SELECT DATE_FORMAT('2024-05-06 08:30:00', '%Y/%m/%d');",
                    "SELECT DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');",
                    "SELECT DATE_FORMAT('2023-01-15', '%d-%m-%Y');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "sys.timestamp_to_str(timestamp_expr, format_str)",
                "description": "Formats a timestamp using MonetDB's internal formatting function. Format specifiers follow standard SQL/Oracle-style.",
                "examples": [
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2024-05-06 08:30:00', 'YYYY/MM/DD');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2023-07-14 15:30:00', 'YYYY-MM-DD HH24:MI:SS');",
                    "SELECT sys.timestamp_to_str(TIMESTAMP '2022-01-01 08:45:30', 'HH24:MI:SS DD-MM-YYYY');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t5;\n",
            "create table t5 (c1 int, c2 varchar(128) not null);\n",
            "insert into t5 values (1, date_format('2001-01-01','%W')); -- DATE_FORMAT\n",
            "insert into t5 values (2, date_format('2001-01-01','%W')); -- DATE_FORMAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t5;\n",
            "create table t5 (c1 int, c2 varchar(128) not null);\n",
            "insert into t5 values (1, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));\n",
            "insert into t5 values (2, sys.timestamp_to_str(TIMESTAMP '2001-01-01', 'DAY'));\n"
        ]
    },
    {
        "sql_id": 453,
        "database_name": "BUTTERTrans_453",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 LONGTEXT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 TEXT);\n"
        ]
    },
    {
        "sql_id": 454,
        "database_name": "BUTTERTrans_454",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 LONGTEXT);\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 TEXT);\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));\n"
        ]
    },
    {
        "sql_id": 455,
        "database_name": "BUTTERTrans_455",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 LONGTEXT);\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 TEXT);\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234));\n"
        ]
    },
    {
        "sql_id": 456,
        "database_name": "BUTTERTrans_456",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456)); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 LONGTEXT);\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 TEXT);\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234));\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345));\n"
        ]
    },
    {
        "sql_id": 457,
        "database_name": "BUTTERTrans_457",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LENGTH(c1) FROM t1; -- LENGTH",
        "target_query": "SELECT octet_length(c1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 LONGTEXT);\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345)); -- REPEAT\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c1 TEXT);\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 123));\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 234));\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 345));\n",
            "INSERT INTO t1 VALUES (REPEAT('ManyMegaByteBlck', 456));\n"
        ]
    },
    {
        "sql_id": 458,
        "database_name": "BUTTERTrans_458",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL",
        "target_query": "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 28,
                "end_pos": 34
            },
            {
                "dialect_token": "IFNULL",
                "start_pos": 47,
                "end_pos": 53
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 459,
        "database_name": "BUTTERTrans_459",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD",
        "target_query": "SELECT FIELD(NULL, 'a', 'b', 'c');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "FIELD",
                "start_pos": 7,
                "end_pos": 12
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found.",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "FIELD(val, val1, val2, ..., valN)",
                "description": "Returns the index (1-based) of the first value in the list that is equal to 'val'. Returns 0 if no match is found. This behaves the same as MySQL FIELD().",
                "examples": [
                    "SELECT FIELD('c', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('x', 'a', 'b', 'c') AS result;",
                    "SELECT FIELD('b', 'b', 'b', 'b') AS result;"
                ]
            }
        ],
        "source_related_schemas": [
            "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL\n"
        ],
        "target_related_schemas": [
            "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;\n"
        ]
    },
    {
        "sql_id": 460,
        "database_name": "BUTTERTrans_460",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL\n",
            "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DECIMAL (1, 0), b DECIMAL (1, 0));\n",
            "INSERT INTO t1 (a, b) VALUES (0, 0);\n",
            "DROP TABLE IF EXISTS t2;\n"
        ],
        "target_related_schemas": [
            "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;\n",
            "SELECT FIELD(NULL, 'a', 'b', 'c');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DECIMAL(1, 0), b DECIMAL(1, 0));\n",
            "INSERT INTO t1 (a, b) VALUES (0, 0);\n",
            "DROP TABLE IF EXISTS t2;\n"
        ]
    },
    {
        "sql_id": 461,
        "database_name": "BUTTERTrans_461",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(a, NULL) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL\n",
            "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DECIMAL (1, 0), b DECIMAL (1, 0));\n",
            "INSERT INTO t1 (a, b) VALUES (0, 0);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL\n",
            "DROP TABLE t2;\n"
        ],
        "target_related_schemas": [
            "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;\n",
            "SELECT FIELD(NULL, 'a', 'b', 'c');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DECIMAL(1, 0), b DECIMAL(1, 0));\n",
            "INSERT INTO t1 (a, b) VALUES (0, 0);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;\n",
            "DROP TABLE t2;\n"
        ]
    },
    {
        "sql_id": 462,
        "database_name": "BUTTERTrans_462",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "CREATE TABLE t2 SELECT IFNULL(NULL, b) FROM t1; -- IFNULL",
        "target_query": "CREATE TABLE t2 AS SELECT COALESCE(NULL, b) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "select NULL=NULL,NULL<>NULL,IFNULL(NULL,1.1)+0,IFNULL(NULL,1) | 0; -- IFNULL\n",
            "select field(NULL,\"a\",\"b\",\"c\"); -- FIELD\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DECIMAL (1, 0), b DECIMAL (1, 0));\n",
            "INSERT INTO t1 (a, b) VALUES (0, 0);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 SELECT IFNULL(a, b) FROM t1; -- IFNULL\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t2 SELECT IFNULL(a, NULL) FROM t1; -- IFNULL\n",
            "DROP TABLE t2;\n"
        ],
        "target_related_schemas": [
            "SELECT NULL = NULL, NULL <> NULL, COALESCE(NULL, 1.1) + 0, COALESCE(NULL, 1) | 0;\n",
            "SELECT FIELD(NULL, 'a', 'b', 'c');\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (a DECIMAL(1, 0), b DECIMAL(1, 0));\n",
            "INSERT INTO t1 (a, b) VALUES (0, 0);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 AS SELECT COALESCE(a, b) FROM t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t2 AS SELECT COALESCE(a, NULL) FROM t1;\n",
            "DROP TABLE t2;\n"
        ]
    },
    {
        "sql_id": 463,
        "database_name": "BUTTERTrans_463",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2); -- REPEAT",
        "target_query": "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 24,
                "end_pos": 30
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 48,
                "end_pos": 54
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1( a VARCHAR( 10 ), b INT );\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1( a VARCHAR( 10 ), b INT );\n"
        ]
    },
    {
        "sql_id": 464,
        "database_name": "BUTTERTrans_464",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT GROUP_CONCAT(a) FROM t1; -- GROUP_CONCAT",
        "target_query": "SELECT GROUP_CONCAT(a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GROUP_CONCAT",
                "start_pos": 7,
                "end_pos": 19
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "group_concat(X)group_concat(X,Y)string_agg(X,Y)",
                "description": "The GROUP_CONCAT([DISTINCT] expr [,expr ...]  [ORDER BY {unsigned_integer | col_name | expr}  [ASC | DESC] [,col_name ...]]  [SEPARATOR str_val])\nfunction returns a string result with the concatenated non-NULL values from a group.\nDISTINGUISHED keyword can be used to eliminate duplicate values.\nORDER BY clause can be used to sort the values.\nSEPARATOR keyword specifies the separator between values, default is comma(,).\nThe maximum length of the result is controlled by group_concat_max_len system variable, default is 1024.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns a comma-separated list of names",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by '|'"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "group_concat(X) group_concat(X,Y)",
                "description": "The group_concat(X,Y) function returns a string which is the concatenation of all non-NULL values of X. If parameter Y is present, it is used as the separator between values. A comma (\",\") is used as the default separator if Y is omitted.\n\nThe order of concatenated elements is arbitrary unless an ORDER BY clause is explicitly used.",
                "examples": [
                    "SELECT group_concat(name) FROM students; -- Returns names separated by commas",
                    "SELECT group_concat(name, ' | ') FROM students; -- Returns names separated by ' | '",
                    "SELECT department, group_concat(name, '; ') FROM employees GROUP BY department; -- Groups names by department"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1( a VARCHAR( 10 ), b INT );\n",
            "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1( a VARCHAR( 10 ), b INT );\n",
            "INSERT INTO t1 VALUES ( repeat( 'a', 10 ), 1),( repeat( 'b', 10 ), 2);\n"
        ]
    },
    {
        "sql_id": 465,
        "database_name": "BUTTERTrans_465",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select repeat('a',2000); -- REPEAT",
        "target_query": "select repeat('a',2000);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 466,
        "database_name": "BUTTERTrans_466",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT length(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") as len; -- LENGTH",
        "target_query": "SELECT octet_length('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') as len;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "select repeat('a',2000); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "select repeat('a',2000);\n"
        ]
    },
    {
        "sql_id": 467,
        "database_name": "BUTTERTrans_467",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select length(repeat('a',2000)); -- LENGTH, REPEAT",
        "target_query": "select octet_length(repeat('a',2000));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 14,
                "end_pos": 20
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            },
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "select repeat('a',2000); -- REPEAT\n",
            "SELECT length(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") as len; -- LENGTH\n"
        ],
        "target_related_schemas": [
            "select repeat('a',2000);\n",
            "SELECT octet_length('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') as len;\n"
        ]
    },
    {
        "sql_id": 468,
        "database_name": "BUTTERTrans_468",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT c11, LENGTH(c12) FROM t1; -- LENGTH",
        "target_query": "SELECT c11, octet_length(c12) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 12,
                "end_pos": 18
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "select repeat('a',2000); -- REPEAT\n",
            "SELECT length(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\") as len; -- LENGTH\n",
            "select length(repeat('a',2000)); -- LENGTH, REPEAT\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c11 INT NOT NULL, c12 LONGTEXT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (c21 INT NOT NULL, c22 LONGTEXT);\n",
            "INSERT INTO t1 VALUES(100,'abcd');\n",
            "INSERT INTO t2 VALUES(100,'xyz');\n"
        ],
        "target_related_schemas": [
            "select repeat('a',2000);\n",
            "SELECT octet_length('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') as len;\n",
            "select octet_length(repeat('a',2000));\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (c11 INT NOT NULL, c12 TEXT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2 (c21 INT NOT NULL, c22 TEXT);\n",
            "INSERT INTO t1 VALUES(100,'abcd');\n",
            "INSERT INTO t2 VALUES(100,'xyz');\n"
        ]
    },
    {
        "sql_id": 469,
        "database_name": "BUTTERTrans_469",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "create table t1 as select to_seconds(null) as to_seconds; -- TO_SECONDS",
        "target_query": "create table t1 as select CASE WHEN NULL IS NULL THEN NULL ELSE EXTRACT(EPOCH FROM NULL) + 62167219200 END as to_seconds;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TO_SECONDS",
                "start_pos": 26,
                "end_pos": 36
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TO_SECONDS(datetime_expr)",
                "description": "Returns the number of seconds since year 0 to the given datetime.",
                "examples": [
                    "SELECT TO_SECONDS('2000-01-01 00:00:00');",
                    "SELECT TO_SECONDS(NOW());",
                    "SELECT TO_SECONDS(NULL);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "EXTRACT(EPOCH FROM ts) + 62167219200",
                "description": "Converts timestamp to the number of seconds since the year 0 by extracting the Unix epoch and adding the seconds from year 0 to 1970.",
                "examples": [
                    "SELECT EXTRACT(EPOCH FROM TIMESTAMP '2020-12-31 12:00:00') + 62167219200;",
                    "SELECT EXTRACT(EPOCH FROM NOW()) + 62167219200;",
                    "SELECT CASE WHEN NULL IS NULL THEN NULL ELSE EXTRACT(EPOCH FROM NULL) + 62167219200 END;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(50));\n",
            "insert into t1 values (0x00410000);\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "create table t1 (a varchar(50));\n",
            "insert into t1 values (X'00410000');\n",
            "drop table t1;\n"
        ]
    },
    {
        "sql_id": 470,
        "database_name": "BUTTERTrans_470",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF",
        "target_query": "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 7,
                "end_pos": 9
            },
            {
                "dialect_token": "IF",
                "start_pos": 28,
                "end_pos": 30
            },
            {
                "dialect_token": "IF",
                "start_pos": 47,
                "end_pos": 49
            },
            {
                "dialect_token": "IF",
                "start_pos": 68,
                "end_pos": 70
            },
            {
                "dialect_token": "IF",
                "start_pos": 78,
                "end_pos": 80
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 471,
        "database_name": "BUTTERTrans_471",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF",
        "target_query": "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 7,
                "end_pos": 9
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n"
        ]
    },
    {
        "sql_id": 472,
        "database_name": "BUTTERTrans_472",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF",
        "target_query": "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 7,
                "end_pos": 9
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n"
        ]
    },
    {
        "sql_id": 473,
        "database_name": "BUTTERTrans_473",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select nullif(u, 1) from t1; -- NULLIF",
        "target_query": "SELECT NULLIF(u, 1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NULLIF",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n"
        ]
    },
    {
        "sql_id": 474,
        "database_name": "BUTTERTrans_474",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "explain select nullif(u, 1) from t1; -- NULLIF",
        "target_query": "EXPLAIN SELECT NULLIF(u, 1) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NULLIF",
                "start_pos": 15,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n"
        ]
    },
    {
        "sql_id": 475,
        "database_name": "BUTTERTrans_475",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select sum(if(num is null,0.00,num)) from t1; -- IF",
        "target_query": "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 11,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n",
            "explain select nullif(u, 1) from t1; -- NULLIF\n",
            "drop table t1;\n",
            "create table t1 (num  double(12,2));\n",
            "insert into t1 values (144.54);\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n",
            "EXPLAIN SELECT NULLIF(u, 1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (num decimal(12,2));\n",
            "INSERT INTO t1 VALUES (144.54);\n"
        ]
    },
    {
        "sql_id": 476,
        "database_name": "BUTTERTrans_476",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF",
        "target_query": "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 11,
                "end_pos": 13
            },
            {
                "dialect_token": "IF",
                "start_pos": 37,
                "end_pos": 39
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n",
            "explain select nullif(u, 1) from t1; -- NULLIF\n",
            "drop table t1;\n",
            "create table t1 (num  double(12,2));\n",
            "insert into t1 values (144.54);\n",
            "select sum(if(num is null,0.00,num)) from t1; -- IF\n",
            "drop table t1;\n",
            "create table t1 (x int, y int);\n",
            "insert into t1 values (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n",
            "EXPLAIN SELECT NULLIF(u, 1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (num decimal(12,2));\n",
            "INSERT INTO t1 VALUES (144.54);\n",
            "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (x int, y int);\n",
            "INSERT INTO t1 VALUES (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n"
        ]
    },
    {
        "sql_id": 477,
        "database_name": "BUTTERTrans_477",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF",
        "target_query": "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NULLIF",
                "start_pos": 7,
                "end_pos": 13
            },
            {
                "dialect_token": "NULLIF",
                "start_pos": 28,
                "end_pos": 34
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n",
            "explain select nullif(u, 1) from t1; -- NULLIF\n",
            "drop table t1;\n",
            "create table t1 (num  double(12,2));\n",
            "insert into t1 values (144.54);\n",
            "select sum(if(num is null,0.00,num)) from t1; -- IF\n",
            "drop table t1;\n",
            "create table t1 (x int, y int);\n",
            "insert into t1 values (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF\n",
            "drop table t1;\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n",
            "EXPLAIN SELECT NULLIF(u, 1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (num decimal(12,2));\n",
            "INSERT INTO t1 VALUES (144.54);\n",
            "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (x int, y int);\n",
            "INSERT INTO t1 VALUES (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 478,
        "database_name": "BUTTERTrans_478",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME",
        "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord ASC;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 11,
                "end_pos": 13
            },
            {
                "dialect_token": "FROM_UNIXTIME",
                "start_pos": 33,
                "end_pos": 46
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
                "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
                "examples": [
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
                    "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n",
            "explain select nullif(u, 1) from t1; -- NULLIF\n",
            "drop table t1;\n",
            "create table t1 (num  double(12,2));\n",
            "insert into t1 values (144.54);\n",
            "select sum(if(num is null,0.00,num)) from t1; -- IF\n",
            "drop table t1;\n",
            "create table t1 (x int, y int);\n",
            "insert into t1 values (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF\n",
            "drop table t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF\n",
            "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n",
            "EXPLAIN SELECT NULLIF(u, 1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (num decimal(12,2));\n",
            "INSERT INTO t1 VALUES (144.54);\n",
            "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (x int, y int);\n",
            "INSERT INTO t1 VALUES (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;\n",
            "CREATE TABLE t1 (id int NOT NULL, date int DEFAULT NULL, text varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n"
        ]
    },
    {
        "sql_id": 479,
        "database_name": "BUTTERTrans_479",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME",
        "target_query": "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord DESC;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 11,
                "end_pos": 13
            },
            {
                "dialect_token": "FROM_UNIXTIME",
                "start_pos": 33,
                "end_pos": 46
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            },
            {
                "expression": "FROM_UNIXTIME(unix_timestamp [, format])",
                "description": "Converts a Unix timestamp to a datetime value. An optional format string can be used to format the output.",
                "examples": [
                    "SELECT FROM_UNIXTIME(1672531200);",
                    "SELECT FROM_UNIXTIME(1672531200, '%Y-%m-%d %H:%i:%s');",
                    "SELECT id, IF(created IS NULL, '-', FROM_UNIXTIME(created, '%d-%m-%Y')) AS created_fmt FROM logs;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            },
            {
                "expression": "TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '<seconds>' SECOND",
                "description": "Adds seconds to the UNIX epoch by using an INTERVAL expression with a string constant representing the number of seconds.",
                "examples": [
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND;",
                    "SELECT TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000.987' SECOND;",
                    "SELECT CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1700000000' SECOND AS STRING);"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n",
            "explain select nullif(u, 1) from t1; -- NULLIF\n",
            "drop table t1;\n",
            "create table t1 (num  double(12,2));\n",
            "insert into t1 values (144.54);\n",
            "select sum(if(num is null,0.00,num)) from t1; -- IF\n",
            "drop table t1;\n",
            "create table t1 (x int, y int);\n",
            "insert into t1 values (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF\n",
            "drop table t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF\n",
            "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n",
            "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n",
            "EXPLAIN SELECT NULLIF(u, 1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (num decimal(12,2));\n",
            "INSERT INTO t1 VALUES (144.54);\n",
            "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (x int, y int);\n",
            "INSERT INTO t1 VALUES (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;\n",
            "CREATE TABLE t1 (id int NOT NULL, date int DEFAULT NULL, text varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n",
            "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord ASC;\n"
        ]
    },
    {
        "sql_id": 480,
        "database_name": "BUTTERTrans_480",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IF",
        "target_query": "SELECT * FROM (SELECT MAX(CASE WHEN 1 THEN CAST(c AS BIGINT) ELSE 0 END) FROM t1) AS te;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IF",
                "start_pos": 26,
                "end_pos": 28
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IF(condition, true_value, false_value)",
                "description": "In MySQL, `IF` is a conditional expression that checks if the condition is true. If the condition is true, it returns the `true_value`; otherwise, it returns the `false_value`.",
                "examples": [
                    "SELECT IF(LENGTH('hello') > 3, 'long', 'short') AS string_length_status;",
                    "SELECT IF(2 + 2 = 5, 'true', 'false') AS math_check;",
                    "SELECT IF(LOWER('ABC') = 'abc', 'match', 'no match') AS case_check;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CASE WHEN condition THEN true_value ELSE false_value END",
                "description": "MonetDB does not support the `IF` function, but you can use the `CASE WHEN` expression to achieve similar functionality. It evaluates a condition and returns different values based on the truth value of the condition.",
                "examples": [
                    "SELECT CASE WHEN LENGTH('hello') > 3 THEN 'long' ELSE 'short' END AS string_length_status;",
                    "SELECT CASE WHEN 2 + 2 = 5 THEN 'true' ELSE 'false' END AS math_check;",
                    "SELECT CASE WHEN LOWER('ABC') = 'abc' THEN 'match' ELSE 'no match' END AS case_check;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n",
            "explain select nullif(u, 1) from t1; -- NULLIF\n",
            "drop table t1;\n",
            "create table t1 (num  double(12,2));\n",
            "insert into t1 values (144.54);\n",
            "select sum(if(num is null,0.00,num)) from t1; -- IF\n",
            "drop table t1;\n",
            "create table t1 (x int, y int);\n",
            "insert into t1 values (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF\n",
            "drop table t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF\n",
            "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n",
            "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME\n",
            "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c LONGTEXT);\n",
            "INSERT INTO t1 VALUES(1), (2), (3), (4), ('1234567890123456789');\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n",
            "EXPLAIN SELECT NULLIF(u, 1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (num decimal(12,2));\n",
            "INSERT INTO t1 VALUES (144.54);\n",
            "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (x int, y int);\n",
            "INSERT INTO t1 VALUES (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;\n",
            "CREATE TABLE t1 (id int NOT NULL, date int DEFAULT NULL, text varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n",
            "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord ASC;\n",
            "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord DESC;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c clob);  -- MonetDB \u4e0d\u652f\u6301 LONGTEXT\uff0c\u7528 clob \u8868\u793a\n",
            "INSERT INTO t1 VALUES(1), (2), (3), (4), ('1234567890123456789');\n"
        ]
    },
    {
        "sql_id": 481,
        "database_name": "BUTTERTrans_481",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM (SELECT MAX(IFNULL(CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IFNULL",
        "target_query": "SELECT * FROM (SELECT MAX(COALESCE(CAST(c AS BIGINT), 0)) FROM t1) AS te;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n",
            "explain select nullif(u, 1) from t1; -- NULLIF\n",
            "drop table t1;\n",
            "create table t1 (num  double(12,2));\n",
            "insert into t1 values (144.54);\n",
            "select sum(if(num is null,0.00,num)) from t1; -- IF\n",
            "drop table t1;\n",
            "create table t1 (x int, y int);\n",
            "insert into t1 values (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF\n",
            "drop table t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF\n",
            "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n",
            "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME\n",
            "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c LONGTEXT);\n",
            "INSERT INTO t1 VALUES(1), (2), (3), (4), ('1234567890123456789');\n",
            "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IF\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n",
            "EXPLAIN SELECT NULLIF(u, 1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (num decimal(12,2));\n",
            "INSERT INTO t1 VALUES (144.54);\n",
            "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (x int, y int);\n",
            "INSERT INTO t1 VALUES (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;\n",
            "CREATE TABLE t1 (id int NOT NULL, date int DEFAULT NULL, text varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n",
            "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord ASC;\n",
            "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord DESC;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c clob);  -- MonetDB \u4e0d\u652f\u6301 LONGTEXT\uff0c\u7528 clob \u8868\u793a\n",
            "INSERT INTO t1 VALUES(1), (2), (3), (4), ('1234567890123456789');\n",
            "SELECT * FROM (SELECT MAX(CASE WHEN 1 THEN CAST(c AS BIGINT) ELSE 0 END) FROM t1) AS te;\n"
        ]
    },
    {
        "sql_id": 482,
        "database_name": "BUTTERTrans_482",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT AVG(NULLIF(YEAR('2001-01-01'),10)); -- NULLIF, YEAR",
        "target_query": "SELECT AVG(NULLIF(EXTRACT(YEAR FROM DATE '2001-01-01'), 10));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NULLIF",
                "start_pos": 11,
                "end_pos": 17
            },
            {
                "dialect_token": "YEAR",
                "start_pos": 18,
                "end_pos": 22
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(YEAR('2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            },
            {
                "expression": "YEAR(date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT YEAR('2023-04-10');",
                    "SELECT YEAR(NOW());",
                    "SELECT YEAR('2022-03-15');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NULLIF(a, b)",
                "description": "The NULLIF function returns NULL if the two arguments are equal. Otherwise, it returns the first argument.",
                "examples": [
                    "SELECT NULLIF(5, 5) IS NULL AS result_1, NULLIF(5, 10) IS NOT NULL AS result_2;",
                    "SELECT NULLIF(EXTRACT(YEAR FROM DATE '2021-01-01'), 2021) AS year_check;",
                    "SELECT NULLIF(10.5, 10.5) AS result_3, NULLIF(10.5, 12.0) AS result_4;"
                ]
            },
            {
                "expression": "EXTRACT(YEAR FROM date)",
                "description": "Extracts the year from a date or datetime and returns it as an integer.",
                "examples": [
                    "SELECT EXTRACT(YEAR FROM DATE '2023-04-10');",
                    "SELECT EXTRACT(YEAR FROM CURRENT_DATE);",
                    "SELECT EXTRACT(YEAR FROM DATE '2022-03-15');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT IF(0,\"ERROR\",\"this\"),IF(1,\"is\",\"ERROR\"),IF(NULL,\"ERROR\",\"a\"),IF(1,2,3),IF(1,2.0,3.0)+0; -- IF\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT IF(1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "SELECT IF(u=1,st,st) s FROM t1 ORDER BY s; -- IF\n",
            "select nullif(u, 1) from t1; -- NULLIF\n",
            "explain select nullif(u, 1) from t1; -- NULLIF\n",
            "drop table t1;\n",
            "create table t1 (num  double(12,2));\n",
            "insert into t1 values (144.54);\n",
            "select sum(if(num is null,0.00,num)) from t1; -- IF\n",
            "drop table t1;\n",
            "create table t1 (x int, y int);\n",
            "insert into t1 values (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "select min(if(y -x > 5,y,NULL)), max(if(y - x > 5,y,NULL)) from t1; -- IF\n",
            "drop table t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL; -- NULLIF\n",
            "CREATE TABLE `t1` (`id` int(11) NOT NULL ,`date` int(10) default NULL,`text` varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n",
            "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord ASC; -- IF, FROM_UNIXTIME\n",
            "SELECT id, IF(date IS NULL, '-', FROM_UNIXTIME(date, '%d-%m-%Y')) AS date_ord, text FROM t1 ORDER BY date_ord DESC; -- IF, FROM_UNIXTIME\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c LONGTEXT);\n",
            "INSERT INTO t1 VALUES(1), (2), (3), (4), ('1234567890123456789');\n",
            "SELECT * FROM (SELECT MAX(IF(1, CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IF\n",
            "SELECT * FROM (SELECT MAX(IFNULL(CAST(c AS UNSIGNED), 0)) FROM t1) AS te; -- IFNULL\n",
            "DROP TABLE t1;\n"
        ],
        "target_related_schemas": [
            "SELECT CASE WHEN 0 THEN 'ERROR' ELSE 'this' END, CASE WHEN 1 THEN 'is' ELSE 'ERROR' END, CASE WHEN NULL THEN 'ERROR' ELSE 'a' END, CASE WHEN 1 THEN 2 ELSE 3 END, CASE WHEN 1 THEN 2.0 ELSE 3.0 END + 0;\n",
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1 (st varchar(255) NOT NULL, u int NOT NULL);\n",
            "INSERT INTO t1 VALUES ('a',1),('A',1),('aa',1),('AA',1),('a',1),('aaa',0),('BBB',0);\n",
            "SELECT CASE WHEN 1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT CASE WHEN u=1 THEN st ELSE st END AS s FROM t1 ORDER BY s;\n",
            "SELECT NULLIF(u, 1) FROM t1;\n",
            "EXPLAIN SELECT NULLIF(u, 1) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (num decimal(12,2));\n",
            "INSERT INTO t1 VALUES (144.54);\n",
            "SELECT SUM(CASE WHEN num IS NULL THEN 0.00 ELSE num END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (x int, y int);\n",
            "INSERT INTO t1 VALUES (0,6),(10,16),(20,26),(30,10),(40,46),(50,56);\n",
            "SELECT MIN(CASE WHEN y - x > 5 THEN y ELSE NULL END), MAX(CASE WHEN y - x > 5 THEN y ELSE NULL END) FROM t1;\n",
            "DROP TABLE t1;\n",
            "SELECT NULLIF(5,5) IS NULL, NULLIF(5,5) IS NOT NULL;\n",
            "CREATE TABLE t1 (id int NOT NULL, date int DEFAULT NULL, text varchar(32) NOT NULL);\n",
            "INSERT INTO t1 VALUES (1,1110000000,'Day 1'),(2,1111000000,'Day 2'),(3,1112000000,'Day 3');\n",
            "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord ASC;\n",
            "SELECT id, CASE WHEN date IS NULL THEN '-' ELSE CAST(TIMESTAMP '1970-01-01 00:00:00' + INTERVAL '1110000000' SECOND AS STRING) END AS date_ord, text FROM t1 ORDER BY date_ord DESC;\n",
            "DROP TABLE t1;\n",
            "CREATE TABLE t1 (c clob);  -- MonetDB \u4e0d\u652f\u6301 LONGTEXT\uff0c\u7528 clob \u8868\u793a\n",
            "INSERT INTO t1 VALUES(1), (2), (3), (4), ('1234567890123456789');\n",
            "SELECT * FROM (SELECT MAX(CASE WHEN 1 THEN CAST(c AS BIGINT) ELSE 0 END) FROM t1) AS te;\n",
            "SELECT * FROM (SELECT MAX(COALESCE(CAST(c AS BIGINT), 0)) FROM t1) AS te;\n",
            "DROP TABLE t1;\n"
        ]
    },
    {
        "sql_id": 483,
        "database_name": "BUTTERTrans_483",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT FROM_DAYS(3652499), FROM_DAYS(3652500), FROM_DAYS(3652501); -- FROM_DAYS",
        "target_query": "SELECT sql_add(DATE '0000-01-01', INTERVAL '3652499' DAY), sql_add(DATE '0000-01-01', INTERVAL '3652500' DAY), sql_add(DATE '0000-01-01', INTERVAL '3652501' DAY); -- FROM_DAYS",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "FROM_DAYS",
                "start_pos": 7,
                "end_pos": 16
            },
            {
                "dialect_token": "FROM_DAYS",
                "start_pos": 27,
                "end_pos": 36
            },
            {
                "dialect_token": "FROM_DAYS",
                "start_pos": 47,
                "end_pos": 56
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_DAYS(n)",
                "description": "Returns a date corresponding to the number of days since year 0.",
                "examples": [
                    "SELECT FROM_DAYS(1);",
                    "SELECT FROM_DAYS(730000);",
                    "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": " INTERVAL 'n' DAY)",
                "description": "Adds n days to the base date '0000-01-01' using sql_add to simulate FROM_DAYS.",
                "examples": [
                    "SELECT sql_add(DATE '0000-01-01', INTERVAL '1' DAY);",
                    "SELECT sql_add(DATE '0000-01-01', INTERVAL '730000' DAY);",
                    "SELECT 'Date is: ' || sql_add(DATE '0000-01-01', INTERVAL '738000' DAY);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 484,
        "database_name": "BUTTERTrans_484",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT FROM_DAYS(42949670), FROM_DAYS(42949671), FROM_DAYS(42949673); -- FROM_DAYS",
        "target_query": "SELECT sql_add(DATE '0000-01-01', INTERVAL '42949670' DAY), sql_add(DATE '0000-01-01', INTERVAL '42949671' DAY), sql_add(DATE '0000-01-01', INTERVAL '42949673' DAY); -- FROM_DAYS",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "FROM_DAYS",
                "start_pos": 7,
                "end_pos": 16
            },
            {
                "dialect_token": "FROM_DAYS",
                "start_pos": 28,
                "end_pos": 37
            },
            {
                "dialect_token": "FROM_DAYS",
                "start_pos": 49,
                "end_pos": 58
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "FROM_DAYS(n)",
                "description": "Returns a date corresponding to the number of days since year 0.",
                "examples": [
                    "SELECT FROM_DAYS(1);",
                    "SELECT FROM_DAYS(730000);",
                    "SELECT CONCAT('Date is: ', FROM_DAYS(738000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": " INTERVAL 'n' DAY)",
                "description": "Adds n days to the base date '0000-01-01' using sql_add to simulate FROM_DAYS.",
                "examples": [
                    "SELECT sql_add(DATE '0000-01-01', INTERVAL '1' DAY);",
                    "SELECT sql_add(DATE '0000-01-01', INTERVAL '730000' DAY);",
                    "SELECT 'Date is: ' || sql_add(DATE '0000-01-01', INTERVAL '738000' DAY);"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT FROM_DAYS(3652499), FROM_DAYS(3652500), FROM_DAYS(3652501); -- FROM_DAYS\n"
        ],
        "target_related_schemas": [
            "SELECT sql_add(DATE '0000-01-01', INTERVAL '3652499' DAY), sql_add(DATE '0000-01-01', INTERVAL '3652500' DAY), sql_add(DATE '0000-01-01', INTERVAL '3652501' DAY); -- FROM_DAYS\n"
        ]
    },
    {
        "sql_id": 485,
        "database_name": "BUTTERTrans_485",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000)); -- REPEAT",
        "target_query": "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 25,
                "end_pos": 31
            },
            {
                "dialect_token": "REPEAT",
                "start_pos": 51,
                "end_pos": 57
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns a string consisting of the string 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(i int, b LONGTEXT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(i int, b TEXT);\n"
        ]
    },
    {
        "sql_id": 486,
        "database_name": "BUTTERTrans_486",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT LENGTH(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived; -- LENGTH",
        "target_query": "SELECT octet_length(b) FROM (SELECT * FROM t INTERSECT SELECT * FROM t) derived;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "LENGTH",
                "start_pos": 7,
                "end_pos": 13
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "LENGTH(str)",
                "description": "Returns the number of bytes in the string. For multi-byte characters (e.g., UTF-8), the byte length may differ from character count.",
                "examples": [
                    "SELECT LENGTH('abc');",
                    "SELECT LENGTH('\u4f60\u597d');",
                    "SELECT LENGTH(REPEAT('a', 1000));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "octet_length(str)",
                "description": "Returns the byte size of a string. Matches MySQL's LENGTH().",
                "examples": [
                    "SELECT octet_length('abc');",
                    "SELECT octet_length('\u4f60\u597d');",
                    "SELECT octet_length(repeat('a', 1000));"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(i int, b LONGTEXT);\n",
            "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000)); -- REPEAT\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t;\n",
            "CREATE TABLE t(i int, b TEXT);\n",
            "INSERT INTO t VALUES (0, REPEAT('x', 120000)), (1, REPEAT('z', 12000));\n"
        ]
    },
    {
        "sql_id": 487,
        "database_name": "BUTTERTrans_487",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT argument FROM test_log WHERE argument LIKE CONCAT('%azun','dris%'); -- CONCAT",
        "target_query": "SELECT argument FROM test_log WHERE argument LIKE '%azun' || 'dris%';",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CONCAT",
                "start_pos": 50,
                "end_pos": 56
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CONCAT(str1, str2, ..., strN)",
                "description": "Concatenates two or more string values into a single string. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT CONCAT('Hello', ' ', 'World');",
                    "SELECT CONCAT('Year: ', 2025);",
                    "SELECT CONCAT(name, '_', id) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "str1 || str2 || ...",
                "description": "Concatenates two or more strings using the || operator. If any operand is NULL, result is NULL.",
                "examples": [
                    "SELECT 'Hello' || ' ' || 'World';",
                    "SELECT 'Year: ' || CAST(2025 AS STRING);",
                    "SELECT name || '_' || CAST(id AS STRING) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS test_log;\n",
            "CREATE TABLE test_log (argument TEXT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS test_log;\n",
            "CREATE TABLE test_log (argument TEXT);\n"
        ]
    },
    {
        "sql_id": 488,
        "database_name": "BUTTERTrans_488",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, 5, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 489,
        "database_name": "BUTTERTrans_489",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n"
        ]
    },
    {
        "sql_id": 490,
        "database_name": "BUTTERTrans_490",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n"
        ]
    },
    {
        "sql_id": 491,
        "database_name": "BUTTERTrans_491",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', NULL, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n"
        ]
    },
    {
        "sql_id": 492,
        "database_name": "BUTTERTrans_492",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', NULL, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n"
        ]
    },
    {
        "sql_id": 493,
        "database_name": "BUTTERTrans_493",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('a', 5, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n"
        ]
    },
    {
        "sql_id": 494,
        "database_name": "BUTTERTrans_494",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD",
        "target_query": "SELECT RPAD(NULL, 5, NULL) AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n"
        ]
    },
    {
        "sql_id": 495,
        "database_name": "BUTTERTrans_495",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('a', 0, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n"
        ]
    },
    {
        "sql_id": 496,
        "database_name": "BUTTERTrans_496",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('a', 0, '') AS result; -- RPAD",
        "target_query": "SELECT RPAD('a', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, 'x') AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n",
            "SELECT RPAD('a', 0, 'x') AS result;\n"
        ]
    },
    {
        "sql_id": 497,
        "database_name": "BUTTERTrans_497",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('', 0, 'x') AS result; -- RPAD",
        "target_query": "SELECT RPAD('', 0, 'x') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, '') AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n",
            "SELECT RPAD('a', 0, 'x') AS result;\n",
            "SELECT RPAD('a', 0, '') AS result;\n"
        ]
    },
    {
        "sql_id": 498,
        "database_name": "BUTTERTrans_498",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('', 0, '') AS result; -- RPAD",
        "target_query": "SELECT RPAD('', 0, '') AS result;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, 'x') AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n",
            "SELECT RPAD('a', 0, 'x') AS result;\n",
            "SELECT RPAD('a', 0, '') AS result;\n",
            "SELECT RPAD('', 0, 'x') AS result;\n"
        ]
    },
    {
        "sql_id": 499,
        "database_name": "BUTTERTrans_499",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('a', -1, 'x'); -- RPAD",
        "target_query": "SELECT RPAD('a', -1, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, '') AS result; -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n",
            "SELECT RPAD('a', 0, 'x') AS result;\n",
            "SELECT RPAD('a', 0, '') AS result;\n",
            "SELECT RPAD('', 0, 'x') AS result;\n",
            "SELECT RPAD('', 0, '') AS result;\n"
        ]
    },
    {
        "sql_id": 500,
        "database_name": "BUTTERTrans_500",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('123456787890', 1, 'x'); -- RPAD",
        "target_query": "SELECT RPAD('123456787890', 1, 'x');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('a', -1, 'x'); -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n",
            "SELECT RPAD('a', 0, 'x') AS result;\n",
            "SELECT RPAD('a', 0, '') AS result;\n",
            "SELECT RPAD('', 0, 'x') AS result;\n",
            "SELECT RPAD('', 0, '') AS result;\n",
            "SELECT RPAD('a', -1, 'x');\n"
        ]
    },
    {
        "sql_id": 501,
        "database_name": "BUTTERTrans_501",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD('a', 5, 'xy'); -- RPAD",
        "target_query": "SELECT RPAD('a', 5, 'xy');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('a', -1, 'x'); -- RPAD\n",
            "SELECT RPAD('123456787890', 1, 'x'); -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n",
            "SELECT RPAD('a', 0, 'x') AS result;\n",
            "SELECT RPAD('a', 0, '') AS result;\n",
            "SELECT RPAD('', 0, 'x') AS result;\n",
            "SELECT RPAD('', 0, '') AS result;\n",
            "SELECT RPAD('a', -1, 'x');\n",
            "SELECT RPAD('123456787890', 1, 'x');\n"
        ]
    },
    {
        "sql_id": 502,
        "database_name": "BUTTERTrans_502",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD(\"I LOVE SQL\", 20, \" \"); -- RPAD",
        "target_query": "SELECT RPAD('I LOVE SQL', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('a', -1, 'x'); -- RPAD\n",
            "SELECT RPAD('123456787890', 1, 'x'); -- RPAD\n",
            "SELECT RPAD('a', 5, 'xy'); -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n",
            "SELECT RPAD('a', 0, 'x') AS result;\n",
            "SELECT RPAD('a', 0, '') AS result;\n",
            "SELECT RPAD('', 0, 'x') AS result;\n",
            "SELECT RPAD('', 0, '') AS result;\n",
            "SELECT RPAD('a', -1, 'x');\n",
            "SELECT RPAD('123456787890', 1, 'x');\n",
            "SELECT RPAD('a', 5, 'xy');\n"
        ]
    },
    {
        "sql_id": 503,
        "database_name": "BUTTERTrans_503",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT RPAD(\"I LOVE SQL in the morning\", 20, \" \"); -- RPAD",
        "target_query": "SELECT RPAD('I LOVE SQL in the morning', 20, ' ');",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "RPAD",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "Pads the string to the right with a specified character.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "RPAD(expression, length, pad_string)",
                "description": "MonetDB can simulate RPAD by concatenating strings.",
                "examples": [
                    "SELECT RPAD('hello', 10, ' ');",
                    "SELECT RPAD('abc', 6, 'x');",
                    "SELECT RPAD(123, 5, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', NULL, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD(NULL, 5, NULL) AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('a', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, 'x') AS result; -- RPAD\n",
            "SELECT RPAD('', 0, '') AS result; -- RPAD\n",
            "SELECT RPAD('a', -1, 'x'); -- RPAD\n",
            "SELECT RPAD('123456787890', 1, 'x'); -- RPAD\n",
            "SELECT RPAD('a', 5, 'xy'); -- RPAD\n",
            "SELECT RPAD(\"I LOVE SQL\", 20, \" \"); -- RPAD\n"
        ],
        "target_related_schemas": [
            "SELECT RPAD(NULL, 5, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, 'x') AS result;\n",
            "SELECT RPAD(NULL, NULL, NULL) AS result;\n",
            "SELECT RPAD('a', NULL, 'x') AS result;\n",
            "SELECT RPAD('a', NULL, NULL) AS result;\n",
            "SELECT RPAD('a', 5, NULL) AS result;\n",
            "SELECT RPAD(NULL, 5, NULL) AS result;\n",
            "SELECT RPAD('a', 0, 'x') AS result;\n",
            "SELECT RPAD('a', 0, '') AS result;\n",
            "SELECT RPAD('', 0, 'x') AS result;\n",
            "SELECT RPAD('', 0, '') AS result;\n",
            "SELECT RPAD('a', -1, 'x');\n",
            "SELECT RPAD('123456787890', 1, 'x');\n",
            "SELECT RPAD('a', 5, 'xy');\n",
            "SELECT RPAD('I LOVE SQL', 20, ' ');\n"
        ]
    },
    {
        "sql_id": 504,
        "database_name": "BUTTERTrans_504",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE (t1.a IN (SELECT t3.a FROM t1 t3)) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "ISNULL",
                "start_pos": 31,
                "end_pos": 37
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL construct for detecting NULL values.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 * NULL) IS NULL;",
                    "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT, b INT);\n",
            "INSERT INTO t1 VALUES(1,1),(2,2),(3,3);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT, b INT);\n",
            "INSERT INTO t1 VALUES(1,1),(2,2),(3,3);\n"
        ]
    },
    {
        "sql_id": 505,
        "database_name": "BUTTERTrans_505",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL",
        "target_query": "SELECT * FROM t1 WHERE (t1.a IN (SELECT t3.a FROM t1 t3)) IS NULL;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "ISNULL",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "ISNULL(expr)",
                "description": "Returns 1 if the expression is NULL, otherwise returns 0.",
                "examples": [
                    "SELECT ISNULL(NULL);",
                    "SELECT ISNULL(5 + NULL);",
                    "SELECT IF(ISNULL(score), 'N/A', score) FROM students;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "expr IS NULL",
                "description": "Standard SQL construct for detecting NULL values.",
                "examples": [
                    "SELECT NULL IS NULL;",
                    "SELECT (5 * NULL) IS NULL;",
                    "SELECT CASE WHEN balance IS NULL THEN 0 ELSE balance END FROM accounts;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT, b INT);\n",
            "INSERT INTO t1 VALUES(1,1),(2,2),(3,3);\n",
            "EXPLAIN SELECT * FROM t1 WHERE ISNULL(t1.a IN (SELECT t3.a FROM t1 t3)); -- ISNULL\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(a INT, b INT);\n",
            "INSERT INTO t1 VALUES(1,1),(2,2),(3,3);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (t1.a IN (SELECT t3.a FROM t1 t3)) IS NULL;\n"
        ]
    },
    {
        "sql_id": 506,
        "database_name": "BUTTERTrans_506",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID",
        "target_query": "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS TEXT) = CAST(t2.a AS TEXT) ) > 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "UUID",
                "start_pos": 60,
                "end_pos": 64
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "UUID()",
                "description": "In MySQL, the UUID() function generates a unique 128-bit identifier, typically represented as a string containing numbers and letters, in the standard UUID format.",
                "examples": [
                    "SELECT UUID();",
                    "SELECT CONCAT(UUID(), 'some_random_string');",
                    "SELECT UPPER(UUID());"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "UUID()",
                "description": "MonetDB supports the UUID() function, which generates a UUID in the standard format.",
                "examples": [
                    "SELECT UUID();",
                    "SELECT CONCAT(UUID(), 'some_random_string');",
                    "SELECT UPPER(UUID());"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n"
        ]
    },
    {
        "sql_id": 507,
        "database_name": "BUTTERTrans_507",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
        "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 15,
                "end_pos": 23
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1(a INT);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a INT, b INT);\n",
            "INSERT INTO t1 VALUES (1), (2), (3), (4);\n",
            "INSERT INTO t3 VALUES (5,5), (6,6);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS TEXT) = CAST(t2.a AS TEXT) ) > 0;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1(a INT);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a INT, b INT);\n",
            "INSERT INTO t1 VALUES (1), (2), (3), (4);\n",
            "INSERT INTO t3 VALUES (5,5), (6,6);\n"
        ]
    },
    {
        "sql_id": 508,
        "database_name": "BUTTERTrans_508",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE",
        "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "COALESCE",
                "start_pos": 23,
                "end_pos": 31
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...) or ALTER TABLE table_name COALESCE PARTITION N",
                "description": "Returns the first non-NULL value, or merges table partitions.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1 GROUP BY 1;",
                    "ALTER TABLE t1 COALESCE PARTITION 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2, ...)",
                "description": "Standard SQL COALESCE function is supported.",
                "examples": [
                    "SELECT COALESCE(a, '') FROM t1;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1(a INT);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a INT, b INT);\n",
            "INSERT INTO t1 VALUES (1), (2), (3), (4);\n",
            "INSERT INTO t3 VALUES (5,5), (6,6);\n",
            "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS TEXT) = CAST(t2.a AS TEXT) ) > 0;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1(a INT);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a INT, b INT);\n",
            "INSERT INTO t1 VALUES (1), (2), (3), (4);\n",
            "INSERT INTO t3 VALUES (5,5), (6,6);\n",
            "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;\n"
        ]
    },
    {
        "sql_id": 509,
        "database_name": "BUTTERTrans_509",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
        "target_query": "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 15,
                "end_pos": 21
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1(a INT);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a INT, b INT);\n",
            "INSERT INTO t1 VALUES (1), (2), (3), (4);\n",
            "INSERT INTO t3 VALUES (5,5), (6,6);\n",
            "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE\n",
            "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS TEXT) = CAST(t2.a AS TEXT) ) > 0;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1(a INT);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a INT, b INT);\n",
            "INSERT INTO t1 VALUES (1), (2), (3), (4);\n",
            "INSERT INTO t3 VALUES (5,5), (6,6);\n",
            "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;\n",
            "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;\n"
        ]
    },
    {
        "sql_id": 510,
        "database_name": "BUTTERTrans_510",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "EXPLAIN SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL",
        "target_query": "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "IFNULL",
                "start_pos": 23,
                "end_pos": 29
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "IFNULL(expr1, expr2)",
                "description": "The IFNULL function checks if the first argument is NULL; if it is, the second argument is returned; otherwise, the first argument is returned.",
                "examples": [
                    "SELECT IFNULL(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT IFNULL(CAST('01-01-01' AS DATETIME), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = IFNULL(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "COALESCE(expr1, expr2)",
                "description": "MonetDB also uses COALESCE to return the first non-NULL value. This works the same way as IFNULL in MySQL.",
                "examples": [
                    "SELECT COALESCE(NULL, NULL);",
                    "CREATE TABLE t13 AS SELECT COALESCE(CAST('01-01-01' AS TIMESTAMP), CAST('01-01-01' AS DATE)) AS f4 FROM t1;",
                    "EXPLAIN SELECT (SELECT 1 FROM t2 WHERE d = COALESCE(c, NULL)) AS RESULT FROM t1 GROUP BY c;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS CHAR) = CAST(t2.a AS CHAR)) > 0; -- UUID\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1(a INT);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a INT, b INT);\n",
            "INSERT INTO t1 VALUES (1), (2), (3), (4);\n",
            "INSERT INTO t3 VALUES (5,5), (6,6);\n",
            "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE\n",
            "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- COALESCE\n",
            "SELECT (SELECT IFNULL(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1 ; -- IFNULL\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS t1;\n",
            "CREATE TABLE t1(x INT, y INT);\n",
            "DROP TABLE IF EXISTS t2;\n",
            "CREATE TABLE t2(a INT, b INT);\n",
            "EXPLAIN SELECT * FROM t1 WHERE (SELECT b FROM t2 WHERE CAST(UUID() AS TEXT) = CAST(t2.a AS TEXT) ) > 0;\n",
            "DROP TABLE t1;\n",
            "DROP TABLE t2;\n",
            "CREATE TABLE t1(a INT);\n",
            "DROP TABLE IF EXISTS t3;\n",
            "CREATE TABLE t3(a INT, b INT);\n",
            "INSERT INTO t1 VALUES (1), (2), (3), (4);\n",
            "INSERT INTO t3 VALUES (5,5), (6,6);\n",
            "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;\n",
            "EXPLAIN SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;\n",
            "SELECT (SELECT COALESCE(SUM(t3.b), 0) FROM t3 WHERE t1.a=t3.a) FROM t1;\n"
        ]
    },
    {
        "sql_id": 511,
        "database_name": "BUTTERTrans_511",
        "source_dbms": "mysql",
        "target_dbms": "monetdb",
        "source_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1; -- TRIM, COUNT",
        "target_query": "SELECT TRIM(f1), COUNT(*) FROM table_varchar_pad_space GROUP BY f1;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TRIM",
                "start_pos": 7,
                "end_pos": 11
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "The TRIM function removes unwanted characters from the beginning and/or end of a string. If no character is specified, it removes spaces by default. You can specify 'BOTH', 'LEADING', or 'TRAILING' to trim characters from both ends, the start, or the end, respectively.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            },
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN FORMAT=TREE SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "TRIM([BOTH | LEADING | TRAILING] 'char' FROM str)",
                "description": "MonetDB's TRIM function operates the same way as in MySQL and other databases. It removes unwanted characters from the start and/or end of a string.",
                "examples": [
                    "SELECT TRIM('x' FROM 'xxabcx');",
                    "SELECT TRIM(BOTH ' ' FROM '  hello world  ');",
                    "SELECT TRIM(LEADING '0' FROM '000123');"
                ]
            },
            {
                "expression": "COUNT()",
                "description": "Returns the number of rows or non-NULL values in a column, with support for DISTINCT.",
                "examples": [
                    "EXPLAIN SELECT COUNT(DISTINCT a) FROM t1 HAVING COUNT(DISTINCT c) < 10;",
                    "SELECT 1 FROM t1 HAVING COUNT(*) > 1 ORDER BY COUNT(*);",
                    "SELECT (SELECT COUNT(*) FROM t HAVING COUNT(*) <> 0);"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS table_varchar_pad_space;\n",
            "CREATE TABLE table_varchar_pad_space (f1 VARCHAR(20));\n",
            "INSERT INTO table_varchar_pad_space VALUES ('ABC  ');\n",
            "INSERT INTO table_varchar_pad_space VALUES ('XYZ');\n",
            "INSERT INTO table_varchar_pad_space VALUES ('XYZ ');\n",
            "INSERT INTO table_varchar_pad_space VALUES ('ABC ');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS table_varchar_pad_space;\n",
            "CREATE TABLE table_varchar_pad_space (f1 VARCHAR(20));\n",
            "INSERT INTO table_varchar_pad_space VALUES ('ABC  ');\n",
            "INSERT INTO table_varchar_pad_space VALUES ('XYZ');\n",
            "INSERT INTO table_varchar_pad_space VALUES ('XYZ ');\n",
            "INSERT INTO table_varchar_pad_space VALUES ('ABC ');\n"
        ]
    },
    {
        "sql_id": 512,
        "database_name": "BUTTERTrans_512",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', repeat('xyzzy', 10000)); -- REPEAT",
        "target_query": "INSERT INTO clstr_tst (a, b, c, d) VALUES (32, 6, 'seis', REPEAT('xyzzy', 10000));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 58,
                "end_pos": 64
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS clstr_tst;\n",
            "CREATE TABLE clstr_tst (a SERIAL PRIMARY KEY,b INT,c TEXT,d TEXT);\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (1, 11, 'once');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (2, 10, 'diez');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (3, 31, 'treinta y uno');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (4, 22, 'veintidos');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (5, 3, 'tres');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (6, 20, 'veinte');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (7, 23, 'veintitres');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (8, 21, 'veintiuno');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (9, 4, 'cuatro');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (10, 14, 'catorce');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (11, 2, 'dos');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (12, 18, 'dieciocho');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (13, 27, 'veintisiete');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (14, 25, 'veinticinco');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (15, 13, 'trece');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (16, 28, 'veintiocho');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (17, 32, 'treinta y dos');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (18, 5, 'cinco');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (19, 29, 'veintinueve');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (20, 1, 'uno');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (21, 24, 'veinticuatro');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (22, 30, 'treinta');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (23, 12, 'doce');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (24, 17, 'diecisiete');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (25, 9, 'nueve');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (26, 19, 'diecinueve');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (27, 26, 'veintiseis');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (28, 15, 'quince');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (29, 7, 'siete');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (30, 16, 'dieciseis');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (31, 8, 'ocho');\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS clstr_tst;\n",
            "CREATE TABLE clstr_tst (a INT PRIMARY KEY,b INT,c TEXT,d TEXT);\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (1, 11, 'once');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (2, 10, 'diez');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (3, 31, 'treinta y uno');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (4, 22, 'veintidos');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (5, 3, 'tres');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (6, 20, 'veinte');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (7, 23, 'veintitres');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (8, 21, 'veintiuno');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (9, 4, 'cuatro');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (10, 14, 'catorce');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (11, 2, 'dos');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (12, 18, 'dieciocho');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (13, 27, 'veintisiete');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (14, 25, 'veinticinco');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (15, 13, 'trece');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (16, 28, 'veintiocho');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (17, 32, 'treinta y dos');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (18, 5, 'cinco');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (19, 29, 'veintinueve');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (20, 1, 'uno');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (21, 24, 'veinticuatro');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (22, 30, 'treinta');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (23, 12, 'doce');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (24, 17, 'diecisiete');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (25, 9, 'nueve');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (26, 19, 'diecinueve');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (27, 26, 'veintiseis');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (28, 15, 'quince');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (29, 7, 'siete');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (30, 16, 'dieciseis');\n",
            "INSERT INTO clstr_tst (a, b, c) VALUES (31, 8, 'ocho');\n"
        ]
    },
    {
        "sql_id": 513,
        "database_name": "BUTTERTrans_513",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200) AS s(i); -- REPEAT, GENERATE_SERIES",
        "target_query": "INSERT INTO tidrangescan SELECT i,repeat('x', 100) FROM generate_series(1,200 + 1) AS s(i);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 34,
                "end_pos": 40
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            },
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS tidrangescan;\n",
            "CREATE TABLE tidrangescan(id integer, data text);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS tidrangescan;\n",
            "CREATE TABLE tidrangescan(id integer, data text);\n"
        ]
    },
    {
        "sql_id": 514,
        "database_name": "BUTTERTrans_514",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "SELECT generate_series(1, 3); -- GENERATE_SERIES",
        "target_query": "SELECT * FROM generate_series(1, 3 + 1);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GENERATE_SERIES",
                "start_pos": 7,
                "end_pos": 22
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 515,
        "database_name": "BUTTERTrans_515",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "SELECT generate_series(1, 3) AS val1, generate_series(3,5) AS val2; -- GENERATE_SERIES",
        "target_query": "SELECT * FROM generate_series(1, 3 + 1) AS t1(val1), generate_series(3, 5 + 1) AS t2(val2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GENERATE_SERIES",
                "start_pos": 7,
                "end_pos": 22
            },
            {
                "dialect_token": "GENERATE_SERIES",
                "start_pos": 38,
                "end_pos": 53
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT generate_series(1, 3); -- GENERATE_SERIES\n"
        ],
        "target_related_schemas": [
            "SELECT * FROM generate_series(1, 3 + 1);\n"
        ]
    },
    {
        "sql_id": 516,
        "database_name": "BUTTERTrans_516",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "SELECT generate_series(1, 2) AS val1, generate_series(1,4) AS val2; -- GENERATE_SERIES",
        "target_query": "SELECT * FROM generate_series(1, 2 + 1) AS t1(val1), generate_series(1, 4 + 1) AS t2(val2);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GENERATE_SERIES",
                "start_pos": 7,
                "end_pos": 22
            },
            {
                "dialect_token": "GENERATE_SERIES",
                "start_pos": 38,
                "end_pos": 53
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "SELECT generate_series(1, 3); -- GENERATE_SERIES\n",
            "SELECT generate_series(1, 3) AS val1, generate_series(3,5) AS val2; -- GENERATE_SERIES\n"
        ],
        "target_related_schemas": [
            "SELECT * FROM generate_series(1, 3 + 1);\n",
            "SELECT * FROM generate_series(1, 3 + 1) AS t1(val1), generate_series(3, 5 + 1) AS t2(val2);\n"
        ]
    },
    {
        "sql_id": 517,
        "database_name": "BUTTERTrans_517",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000)); -- REPEAT",
        "target_query": "INSERT INTO cmdata VALUES(repeat('1234567890', 1000));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 26,
                "end_pos": 32
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS cmdata;\n",
            "CREATE TABLE cmdata(f1 text);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS cmdata;\n",
            "CREATE TABLE cmdata(f1 text);\n"
        ]
    },
    {
        "sql_id": 518,
        "database_name": "BUTTERTrans_518",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004)); -- REPEAT",
        "target_query": "INSERT INTO cmdata1 VALUES(repeat('1234567890', 1004));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 27,
                "end_pos": 33
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS cmdata;\n",
            "CREATE TABLE cmdata(f1 text);\n",
            "INSERT INTO cmdata VALUES(repeat('1234567890', 1000)); -- REPEAT\n",
            "DROP TABLE cmdata;\n",
            "DROP TABLE IF EXISTS cmdata1;\n",
            "CREATE TABLE cmdata1(f1 TEXT);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS cmdata;\n",
            "CREATE TABLE cmdata(f1 text);\n",
            "INSERT INTO cmdata VALUES(repeat('1234567890', 1000));\n",
            "DROP TABLE cmdata;\n",
            "DROP TABLE IF EXISTS cmdata1;\n",
            "CREATE TABLE cmdata1(f1 TEXT);\n"
        ]
    },
    {
        "sql_id": 519,
        "database_name": "BUTTERTrans_519",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, repeat('x', 10000)); -- REPEAT",
        "target_query": "INSERT INTO delete_test (id, a, b) VALUES (2, 50, repeat('x', 10000));",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "REPEAT",
                "start_pos": 50,
                "end_pos": 56
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns 'str' repeated 'count' times. Returns NULL if any argument is NULL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "REPEAT(str, count)",
                "description": "Returns the string 'str' repeated 'count' times. Behavior on NULL matches MySQL.",
                "examples": [
                    "SELECT REPEAT('x', 5);",
                    "SELECT REPEAT('ab', 3);",
                    "SELECT REPEAT('*', 0);",
                    "SELECT REPEAT(name, 2) FROM users;"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS delete_test;\n",
            "CREATE TABLE delete_test (id SERIAL PRIMARY KEY,a INT,b text);\n",
            "INSERT INTO delete_test (id, a) VALUES (1, 10);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS delete_test;\n",
            "CREATE TABLE delete_test (id INT PRIMARY KEY, a INT, b text);\n",
            "INSERT INTO delete_test (id, a) VALUES (1, 10);\n"
        ]
    },
    {
        "sql_id": 520,
        "database_name": "BUTTERTrans_520",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "SELECT current_timestamp = NOW(); -- NOW",
        "target_query": "SELECT current_timestamp = CURRENT_TIMESTAMP;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NOW",
                "start_pos": 27,
                "end_pos": 30
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "In PostgreSQL, CURRENT_TIMESTAMP is used to retrieve the current date and time, equivalent to NOW() in MySQL and MariaDB.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "CURRENT_TIMESTAMP",
                "description": "MonetDB uses CURRENT_TIMESTAMP to return the current date and time, similar to PostgreSQL's approach.",
                "examples": [
                    "SELECT CURRENT_TIMESTAMP;",
                    "CREATE TABLE t12 SELECT * FROM t1 WHERE b = 67 AND (c IS NULL OR c > CURRENT_TIMESTAMP) ORDER BY 3 DESC;",
                    "INSERT INTO t1 VALUES (CURRENT_TIMESTAMP);"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 521,
        "database_name": "BUTTERTrans_521",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "select current_schemas(false); -- CURRENT_SCHEMAS",
        "target_query": "SELECT current_schema;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "CURRENT_SCHEMAS",
                "start_pos": 7,
                "end_pos": 22
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "current_schemas(include_implicit boolean)",
                "description": "Returns a text array of schema names in the current search path. The boolean parameter controls whether implicit schemas such as pg_catalog are included.",
                "examples": [
                    "SELECT current_schemas(false);",
                    "SELECT current_schemas(true);",
                    "SELECT unnest(current_schemas(false));"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "current_schema",
                "description": "Returns the name of the current database for the session, used as equivalent to schema name in PostgreSQL.",
                "examples": [
                    "SELECT current_schema;"
                ]
            }
        ],
        "source_related_schemas": [],
        "target_related_schemas": []
    },
    {
        "sql_id": 522,
        "database_name": "BUTTERTrans_522",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES",
        "target_query": "CREATE TABLE simple1 AS SELECT * FROM generate_series(1, 200 + 1) AS id;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GENERATE_SERIES",
                "start_pos": 31,
                "end_pos": 46
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS simple1;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS simple1;\n"
        ]
    },
    {
        "sql_id": 523,
        "database_name": "BUTTERTrans_523",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES",
        "target_query": "CREATE TABLE bigger_than_it_looks AS SELECT * FROM generate_series(1, 200 + 1) AS id;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "GENERATE_SERIES",
                "start_pos": 44,
                "end_pos": 59
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS simple1;\n",
            "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES\n",
            "DROP TABLE IF EXISTS bigger_than_it_looks;\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS simple1;\n",
            "CREATE TABLE simple1 AS SELECT * FROM generate_series(1, 200 + 1) AS id;\n",
            "DROP TABLE IF EXISTS bigger_than_it_looks;\n"
        ]
    },
    {
        "sql_id": 524,
        "database_name": "BUTTERTrans_524",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "insert into extremely_skewed select 42 as id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'from generate_series(1, 200); -- GENERATE_SERIES",
        "target_query": "INSERT INTO extremely_skewed SELECT 42 AS id, 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' FROM generate_series(1, 200 + 1);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [],
        "source_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS simple1;\n",
            "create table simple1 as select generate_series(1, 200) AS id; -- GENERATE_SERIES\n",
            "DROP TABLE IF EXISTS bigger_than_it_looks;\n",
            "create table bigger_than_it_looks as select generate_series(1, 200) as id; -- GENERATE_SERIES\n",
            "DROP TABLE IF EXISTS extremely_skewed;\n",
            "create table extremely_skewed (id int, t text);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS simple1;\n",
            "CREATE TABLE simple1 AS SELECT * FROM generate_series(1, 200 + 1) AS id;\n",
            "DROP TABLE IF EXISTS bigger_than_it_looks;\n",
            "CREATE TABLE bigger_than_it_looks AS SELECT * FROM generate_series(1, 200 + 1) AS id;\n",
            "DROP TABLE IF EXISTS extremely_skewed;\n",
            "CREATE TABLE extremely_skewed (id INT, t TEXT);\n"
        ]
    },
    {
        "sql_id": 525,
        "database_name": "BUTTERTrans_525",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO pagg_tab SELECT i % 20, i % 30, to_char(i % 12, 'FM0000'), i % 30 FROM generate_series(0, 2999) i; -- TO_CHAR, GENERATE_SERIES",
        "target_query": "INSERT INTO pagg_tab SELECT i % 20, i % 30, lpad(CAST(i % 12 AS STRING), 4, '0'), i % 30 FROM generate_series(0, 2999 + 1) AS g(i);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TO_CHAR",
                "start_pos": 44,
                "end_pos": 51
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "to_char(numeric, 'FM0000')",
                "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
                "examples": [
                    "SELECT to_char(5, 'FM0000');   -- 0005",
                    "SELECT to_char(123, 'FM0000'); -- 0123",
                    "SELECT to_char(0, 'FM0000');   -- 0000"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lpad(CAST(value AS string), 4, '0')",
                "description": "Pads numeric value with zeros using lpad.",
                "examples": [
                    "SELECT lpad(CAST(5 AS string), 4, '0');",
                    "SELECT lpad(CAST(123 AS string), 4, '0');",
                    "SELECT lpad(CAST(0 AS string), 4, '0');"
                ]
            },
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS pagg_tab;\n",
            "CREATE TABLE pagg_tab (a int, b int, c text, d int);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS pagg_tab;\n",
            "CREATE TABLE pagg_tab (a int, b int, c text, d int);\n"
        ]
    },
    {
        "sql_id": 526,
        "database_name": "BUTTERTrans_526",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, to_char(i % 4, 'FM0000') FROM generate_series(0, 29999) i; -- TO_CHAR",
        "target_query": "INSERT INTO pagg_tab_ml SELECT i % 30, i % 10, lpad(CAST(i % 4 AS string), 4, '0') FROM generate_series(0, 29999 + 1) AS g(i);",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TO_CHAR",
                "start_pos": 47,
                "end_pos": 54
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "to_char(numeric, 'FM0000')",
                "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
                "examples": [
                    "SELECT to_char(5, 'FM0000');   -- 0005",
                    "SELECT to_char(123, 'FM0000'); -- 0123",
                    "SELECT to_char(0, 'FM0000');   -- 0000"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lpad(CAST(value AS string), 4, '0')",
                "description": "Pads numeric value with zeros using lpad.",
                "examples": [
                    "SELECT lpad(CAST(5 AS string), 4, '0');",
                    "SELECT lpad(CAST(123 AS string), 4, '0');",
                    "SELECT lpad(CAST(0 AS string), 4, '0');"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS pagg_tab;\n",
            "CREATE TABLE pagg_tab (a int, b int, c text, d int);\n",
            "INSERT INTO pagg_tab SELECT i % 20, i % 30, to_char(i % 12, 'FM0000'), i % 30 FROM generate_series(0, 2999) i; -- TO_CHAR, GENERATE_SERIES\n",
            "DROP TABLE pagg_tab;\n",
            "DROP TABLE IF EXISTS pagg_tab_ml;\n",
            "CREATE TABLE pagg_tab_ml (a int, b int, c text);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS pagg_tab;\n",
            "CREATE TABLE pagg_tab (a int, b int, c text, d int);\n",
            "INSERT INTO pagg_tab SELECT i % 20, i % 30, lpad(CAST(i % 12 AS STRING), 4, '0'), i % 30 FROM generate_series(0, 2999 + 1) AS g(i);\n",
            "DROP TABLE pagg_tab;\n",
            "DROP TABLE IF EXISTS pagg_tab_ml;\n",
            "CREATE TABLE pagg_tab_ml (a int, b int, c text);\n"
        ]
    },
    {
        "sql_id": 527,
        "database_name": "BUTTERTrans_527",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0; -- TO_CHAR, GENERATE_SERIES",
        "target_query": "INSERT INTO prt1 SELECT i, i % 25, lpad(CAST(i AS string), 4, '0') FROM generate_series(0, 599 + 1) AS g(i) WHERE i % 2 = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TO_CHAR",
                "start_pos": 35,
                "end_pos": 42
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "to_char(numeric, 'FM0000')",
                "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
                "examples": [
                    "SELECT to_char(5, 'FM0000');   -- 0005",
                    "SELECT to_char(123, 'FM0000'); -- 0123",
                    "SELECT to_char(0, 'FM0000');   -- 0000"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lpad(CAST(value AS string), 4, '0')",
                "description": "Pads numeric value with zeros using lpad.",
                "examples": [
                    "SELECT lpad(CAST(5 AS string), 4, '0');",
                    "SELECT lpad(CAST(123 AS string), 4, '0');",
                    "SELECT lpad(CAST(0 AS string), 4, '0');"
                ]
            },
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS prt1;\n",
            "CREATE TABLE prt1 (a int, b int, c varchar);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS prt1;\n",
            "CREATE TABLE prt1 (a int, b int, c varchar);\n"
        ]
    },
    {
        "sql_id": 528,
        "database_name": "BUTTERTrans_528",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "INSERT INTO prt2 SELECT i % 25, i, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 3 = 0; -- TO_CHAR, GENERATE_SERIES",
        "target_query": "INSERT INTO prt2 SELECT i % 25, i, lpad(CAST(i AS string), 4, '0') FROM generate_series(0, 599 + 1) AS g(i) WHERE i % 3 = 0;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "TO_CHAR",
                "start_pos": 35,
                "end_pos": 42
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "to_char(numeric, 'FM0000')",
                "description": "Formats a number as a zero-padded 4-digit string without leading spaces.",
                "examples": [
                    "SELECT to_char(5, 'FM0000');   -- 0005",
                    "SELECT to_char(123, 'FM0000'); -- 0123",
                    "SELECT to_char(0, 'FM0000');   -- 0000"
                ]
            },
            {
                "expression": "generate_series(start, stop [, step])",
                "description": "Generates a series of integers or timestamps between start and stop with an optional step.",
                "examples": [
                    "SELECT generate_series(1, 5);",
                    "SELECT generate_series(3, 9, 2);",
                    "SELECT generate_series(10, 6, -2);"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "lpad(CAST(value AS string), 4, '0')",
                "description": "Pads numeric value with zeros using lpad.",
                "examples": [
                    "SELECT lpad(CAST(5 AS string), 4, '0');",
                    "SELECT lpad(CAST(123 AS string), 4, '0');",
                    "SELECT lpad(CAST(0 AS string), 4, '0');"
                ]
            },
            {
                "expression": "generate_series(start, stop [+/-] 1 [, step])",
                "description": "MonetDB's generate_series excludes the stop value by default. To emulate PostgreSQL behavior (which includes the stop value), add 1 to stop when step > 0, or subtract 1 from stop when step < 0.",
                "examples": [
                    "SELECT * FROM generate_series(1, 5 + 1);           -- Generates 1 to 5",
                    "SELECT * FROM generate_series(3, 9 + 2, 2);        -- Generates 3, 5, 7, 9",
                    "SELECT * FROM generate_series(10, 6 - 2, -2);      -- Generates 10, 8, 6"
                ]
            }
        ],
        "source_related_schemas": [
            "DROP TABLE IF EXISTS prt1;\n",
            "CREATE TABLE prt1 (a int, b int, c varchar);\n",
            "INSERT INTO prt1 SELECT i, i % 25, to_char(i, 'FM0000') FROM generate_series(0, 599) i WHERE i % 2 = 0; -- TO_CHAR, GENERATE_SERIES\n",
            "DROP TABLE prt1;\n",
            "DROP TABLE IF EXISTS prt2;\n",
            "CREATE TABLE prt2 (a int, b int, c varchar);\n"
        ],
        "target_related_schemas": [
            "DROP TABLE IF EXISTS prt1;\n",
            "CREATE TABLE prt1 (a int, b int, c varchar);\n",
            "INSERT INTO prt1 SELECT i, i % 25, lpad(CAST(i AS string), 4, '0') FROM generate_series(0, 599 + 1) AS g(i) WHERE i % 2 = 0;\n",
            "DROP TABLE prt1;\n",
            "DROP TABLE IF EXISTS prt2;\n",
            "CREATE TABLE prt2 (a int, b int, c varchar);\n"
        ]
    },
    {
        "sql_id": 529,
        "database_name": "BUTTERTrans_529",
        "source_dbms": "postgresql",
        "target_dbms": "monetdb",
        "source_query": "SELECT nextval('seq3'); -- NEXTVAL",
        "target_query": "SELECT NEXT VALUE FOR seq3;",
        "semantic_equivalent_type": "exact_equivalence",
        "source_query_dialect_token_positions": [
            {
                "dialect_token": "NEXTVAL",
                "start_pos": 7,
                "end_pos": 14
            }
        ],
        "source_dialect_knowledge": [
            {
                "expression": "nextval('sequence_name')",
                "description": "Returns the next value from a named sequence and increments the counter atomically.",
                "examples": [
                    "SELECT nextval('my_seq');",
                    "SELECT nextval('my_seq') + 5;",
                    "SELECT nextval('my_seq') * 2;"
                ]
            }
        ],
        "target_dialect_knowledge": [
            {
                "expression": "NEXT VALUE FOR sequence_name",
                "description": "Returns the next value from a named sequence using standard SQL syntax.",
                "examples": [
                    "SELECT NEXT VALUE FOR my_seq;",
                    "SELECT NEXT VALUE FOR my_seq + 5;",
                    "SELECT NEXT VALUE FOR my_seq * 2;"
                ]
            }
        ],
        "source_related_schemas": [
            "CREATE SEQUENCE seq3;\n"
        ],
        "target_related_schemas": [
            "CREATE SEQUENCE seq3;\n"
        ]
    }
]